#include <ultra64.h>
#include <macros.h>
#include <defines.h>
#include <actor_types.h>
#include "math_util.h"
#include "memory.h"
#include "code_802B0210.h"
#include "code_80296A50.h"

void func_802B0210(UnkActorInner *arg0, UnkActorInner *arg1) {
    arg1->unk30 = arg0->unk30;
    arg1->unk32 = arg0->unk32;
    arg1->unk34 = arg0->unk34;
    arg1->unk36 = arg0->unk36;
    arg1->unk38 = arg0->unk38;
    arg1->unk3A = arg0->unk3A;
    arg1->unk3C = arg0->unk3C;
    arg1->unk40 = arg0->unk40;

    arg1->unk44 = arg0->unk44;
    vec3f_copy(arg1->unk48, arg0->unk48);
    vec3f_copy(arg1->unk54, arg0->unk54);
    vec3f_copy(arg1->unk60, arg0->unk60);
}

void func_802B02B4(struct ShellActor *shell, s32 shellType) {
    struct TripleShellParent *parent = &gActorList[shell->parentIndex];

    parent->shellsAvailable--;

    switch((s16)shell->shellId) {
        case 0:
            parent->shellIndices[0] = -1.0f;
            break;
        case 1:
            parent->shellIndices[1] = -1.0f;
            break;
        case 2:
            parent->shellIndices[2] = -1.0f;
            break;
    }

    shell->flags = 0x8000; // bitflag
    shell->rotAngle = 0;
    shell->velocity[1] = 3.0f;
    shell->someTimer = 60;

    switch(shellType) {
        case ACTOR_GREEN_SHELL:
            shell->state = 5;
            break;
        case ACTOR_RED_SHELL:
            shell->state = 7;
            break;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern f64 D_802B9E80;
extern f64 D_802B9E88;
extern f64 D_802B9E90;

void func_802B039C(void *arg0) {
    f32 temp_f6;
    s32 temp_v0;
    f32 phi_f6;

    arg0->unk6 = 1;
    arg0->unk_04 = 0xB4;
    arg0->velocity = (random_int(0xC8) - 0x64) * D_802B9E80;
    temp_v0 = random_int(0xC8);
    temp_f6 = temp_v0;
    phi_f6 = temp_f6;
    if (temp_v0 < 0) {
        phi_f6 = temp_f6 + 4294967296.0f;
    }
    arg0->unk28 = phi_f6 * D_802B9E88;
    arg0->unk2C = (random_int(0xC8) - 0x64) * D_802B9E90;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B039C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307

void func_802B0464(s16 arg0) {
    s16 temp_s0;
    void *temp_a0;
    s16 phi_s0;

    phi_s0 = arg0;
    if (arg0 != -1) {
        do {
            temp_a0 = &gActorList + (phi_s0 * 0x70);
            func_802B039C(temp_a0);
            temp_s0 = temp_a0->unk14;
            phi_s0 = temp_s0;
        } while (temp_s0 != -1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0464.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_802B039C(void *); // extern
extern ? gActorList;

void func_802B04E8(s32 arg0, s16 arg1) {
    s16 temp_s0;
    void *temp_a0;
    s16 phi_s0;

    phi_s0 = arg1;
    if (arg1 != -1) {
        do {
            temp_a0 = &gActorList + (phi_s0 * 0x70);
            func_802B039C(temp_a0);
            temp_s0 = temp_a0->unk12;
            phi_s0 = temp_s0;
        } while (temp_s0 != -1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B04E8.s")
#endif

void func_802B0570(struct BananaActor *banana) {
    struct BananaBunchParent *temp_v0_2;

    func_802B0464(banana->youngerIndex);
    func_802B04E8(banana, banana->elderIndex);
    if ((gPlayers[banana->playerId].unk_000 & 0x4000) != 0) {
        func_800C9060(banana->playerId, 0x19019053);
    }
    banana->flags = -0x8000;
    banana->unk_04 = 0x003C;
    banana->state = 5;
    banana->velocity[1] = 3.0f;
    temp_v0_2 = &gActorList[banana->parentIndex];
    temp_v0_2->bananaIndices[0] = -1;
    temp_v0_2->bananaIndices[1] = -1;
    temp_v0_2->bananaIndices[2] = -1;
    temp_v0_2->bananaIndices[3] = -1;
    temp_v0_2->bananaIndices[4] = -1;
}

#ifdef MIPS_TO_C
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b
void func_802B0648(struct BananaBunchParent *banana_bunch) {
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s16 temp_v0_5;
    s16 temp_v0_6;
    s32 temp_lo;
    s32 temp_lo_2;
    s32 temp_lo_3;
    s32 temp_lo_4;
    s32 temp_lo_5;
    void *phi_v1;

    temp_v0 = banana_bunch->bananaIndices[4];
    banana_bunch->bananasAvailable -= 1;
    if (temp_v0 != -1) {
        temp_lo = temp_v0 * 0x70;
        banana_bunch->bananaIndices[4] = -1;
        phi_v1 = gActorList + temp_lo;
        goto block_10;
    }
    temp_v0_2 = banana_bunch->bananaIndices[3];
    if (temp_v0_2 != -1) {
        temp_lo_2 = temp_v0_2 * 0x70;
        banana_bunch->bananaIndices[3] = -1;
        phi_v1 = gActorList + temp_lo_2;
        goto block_10;
    }
    temp_v0_3 = banana_bunch->bananaIndices[2];
    if (temp_v0_3 != -1) {
        temp_lo_3 = temp_v0_3 * 0x70;
        banana_bunch->bananaIndices[2] = -1;
        phi_v1 = gActorList + temp_lo_3;
        goto block_10;
    }
    temp_v0_4 = banana_bunch->bananaIndices[1];
    if (temp_v0_4 != -1) {
        temp_lo_4 = temp_v0_4 * 0x70;
        banana_bunch->bananaIndices[1] = -1;
        phi_v1 = gActorList + temp_lo_4;
        goto block_10;
    }
    temp_v0_5 = banana_bunch->bananaIndices[0];
    if (temp_v0_5 != -1) {
        temp_lo_5 = temp_v0_5 * 0x70;
        banana_bunch->bananaIndices[0] = -1;
        phi_v1 = gActorList + temp_lo_5;
block_10:
        temp_v0_6 = phi_v1->unk12;
        phi_v1->unk6 = 1;
        phi_v1->unk4 = 0x00B4;
        phi_v1->unk24 = 0.0f;
        phi_v1->unk2C = 0.0f;
        phi_v1->unk28 = 1.5f;
        if (temp_v0_6 != -1) {
            (gActorList + (temp_v0_6 * 0x70))->unk14 = -1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0648.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b
? func_802B64C4(f32 *, s16);                        /* extern */

void func_802B0788(s16 rawStickY, struct BananaBunchParent *banana_bunch, Player *player) {
    f32 sp34;
    void *sp30;
    f32 temp_f0;
    f32 temp_f2;
    s16 temp_a0;
    s16 temp_a0_2;
    s16 temp_a0_3;
    s16 temp_a0_4;
    s16 temp_a1;
    s16 temp_a3;
    s32 temp_lo;
    s32 temp_lo_2;
    s32 temp_lo_3;
    s32 temp_lo_4;
    s32 temp_lo_5;
    void *phi_v0;
    f32 phi_f0;
    f32 phi_f12;

    temp_a3 = banana_bunch->bananaIndices[4];
    banana_bunch->bananasAvailable += -1;
    if (temp_a3 != -1) {
        temp_lo = temp_a3 * 0x70;
        banana_bunch->bananaIndices[4] = -1;
        phi_v0 = gActorList + temp_lo;
        goto block_10;
    }
    temp_a0 = banana_bunch->bananaIndices[3];
    if (temp_a0 != -1) {
        temp_lo_2 = temp_a0 * 0x70;
        banana_bunch->bananaIndices[3] = -1;
        phi_v0 = gActorList + temp_lo_2;
        goto block_10;
    }
    temp_a0_2 = banana_bunch->bananaIndices[2];
    if (temp_a0_2 != -1) {
        temp_lo_3 = temp_a0_2 * 0x70;
        banana_bunch->bananaIndices[2] = -1;
        phi_v0 = gActorList + temp_lo_3;
        goto block_10;
    }
    temp_a0_3 = banana_bunch->bananaIndices[1];
    if (temp_a0_3 != -1) {
        temp_lo_4 = temp_a0_3 * 0x70;
        banana_bunch->bananaIndices[1] = -1;
        phi_v0 = gActorList + temp_lo_4;
        goto block_10;
    }
    temp_a0_4 = banana_bunch->bananaIndices[0];
    if (temp_a0_4 != -1) {
        temp_lo_5 = temp_a0_4 * 0x70;
        banana_bunch->bananaIndices[0] = -1;
        phi_v0 = gActorList + temp_lo_5;
block_10:
        temp_a1 = phi_v0->unk12;
        phi_v0->unk6 = 1;
        phi_v0->unk4 = 0x001E;
        if (temp_a1 != -1) {
            (gActorList + (temp_a1 * 0x70))->unk14 = -1;
        }
        temp_f2 = player->unk_094;
        if (temp_f2 < 2.0f) {
            phi_f0 = (((f32) rawStickY - 30.0f) / 20.0f) + 1.5f;
            phi_f12 = 4.0f;
        } else {
            temp_f0 = (((f32) rawStickY - 30.0f) / 20.0f) + 1.5f;
            phi_f0 = temp_f0;
            phi_f12 = (temp_f2 * 0.75f) + 4.5f + temp_f0;
        }
        sp30 = phi_v0;
        vec3f_set(&sp34, 0.0f, phi_f0, phi_f12);
        func_802B64C4(&sp34, (s16) (player->unk_02E + player->unk_0C0));
        sp30->unk24 = sp34;
        sp30->unk28 = sp38;
        sp30->unk2C = sp3C;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0788.s")
#endif

s32 func_802B09C0(s16 bananaId) {
    struct BananaActor *banana;
    if (bananaId == -1) {
        return 0;
    }
    banana = (struct BananaActor*) &gActorList[bananaId];
    if (banana->state == 2) {
        return 1;
    }
    if (banana->state == 3) {
        return 1;
    }
    return 0;
}

#ifdef NEEDS_RODATA
// Needs jpt_802B9E98, otherwise this matches

void update_obj_banana_bunch(struct BananaBunchParent *banana_bunch) {
    s32 pad[2];
    Player *owner;
    struct Controller *controller;
    s32 someCount;

    owner = &gPlayers[banana_bunch->playerId];
    switch (banana_bunch->state) {
    case 0:
        func_802B2914(banana_bunch, owner, 0);
        banana_bunch->unk_04 = 4;
        banana_bunch->state = 1;
        banana_bunch->bananasAvailable = 1;
        break;
    case 1:
        banana_bunch->unk_04 -= 1;
        if (banana_bunch->unk_04 == 0) {
            func_802B2914(banana_bunch, owner, 1);
            banana_bunch->unk_04 = 4;
            banana_bunch->state = 2;
            banana_bunch->bananasAvailable += 1;
        }
        break;
    case 2:
        banana_bunch->unk_04 -= 1;
        if (banana_bunch->unk_04 == 0) {
            func_802B2914(banana_bunch, owner, 2);
            banana_bunch->unk_04 = 4;
            banana_bunch->state = 3;
            banana_bunch->bananasAvailable += 1;
        }
        break;
    case 3:
        banana_bunch->unk_04 -= 1;
        if (banana_bunch->unk_04 == 0) {
            func_802B2914(banana_bunch, owner, 3);
            banana_bunch->unk_04 = 4;
            banana_bunch->state = 4;
            banana_bunch->bananasAvailable += 1;
        }
        break;
    case 4:
        banana_bunch->unk_04 -= 1;
        if (banana_bunch->unk_04 == 0) {
            func_802B2914(banana_bunch, owner, 4);
            banana_bunch->unk_04 = 4;
            banana_bunch->state = 5;
            banana_bunch->bananasAvailable += 1;
        }
        break;
    case 5:
        banana_bunch->state = 6;
        // Unnecessary type-casting done here purely to help with understanding.
        // We're setting the ->flags of BananaActors, not plain Actors.
        ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[0]])->flags |= 0x5000;
        ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[1]])->flags |= 0x5000;
        ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[2]])->flags |= 0x5000;
        ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[3]])->flags |= 0x5000;
        ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[4]])->flags |= 0x5000;
        break;
    case 6:
        someCount = 0;
        if (func_802B09C0(banana_bunch->bananaIndices[0]) == 1) {
            someCount = 1;
        }
        if (func_802B09C0(banana_bunch->bananaIndices[1]) == 1) {
            someCount += 1;
        }
        if (func_802B09C0(banana_bunch->bananaIndices[2]) == 1) {
            someCount += 1;
        }
        if (func_802B09C0(banana_bunch->bananaIndices[3]) == 1) {
            someCount += 1;
        }
        if (func_802B09C0(banana_bunch->bananaIndices[4]) == 1) {
            someCount += 1;
        }
        if (someCount == 0) {
            destroy_actor(banana_bunch);
            owner->unk_00C &= ~0x40000;
        } else if ((owner->unk_000 & 0x4000) != 0) {
            controller = &gControllers[banana_bunch->playerId];
            if ((controller->buttonPressed & 0x2000) != 0) {
                controller->buttonPressed &= ~0x2000;
                func_800C9060(owner - gPlayerOne, 0x19008012);
                if ((controller->rawStickY >= 0x1F) && ((controller->rawStickX < 0x28) && (controller->rawStickX >= -0x27))) {
                    func_802B0788(controller->rawStickY, banana_bunch, owner);
                } else {
                    func_802B0648(banana_bunch);
                }
            }
        }
        break;
    default:
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_banana_bunch.s")
#endif

s32 func_802B0E14(s16 arg0) {
    struct ShellActor *temp;
    if (arg0 < 0) {
        return 0;
    }
    temp = (struct ShellActor*) &gActorList[arg0];
    if (temp->type == ACTOR_GREEN_SHELL) {
        if (temp->state == 4) {
            return 1;
        }
        return 0;
    }
    if (temp->state == 6) {
        return 1;
    }
    return 0;
}

#ifdef NEEDS_RODATA
s32 func_8000ED80(s32);                               /* extern */
s32 func_8000EDC8(s32);                               /* extern */
void func_802B64C4(Vec3f, s16);                        /* extern */

void update_obj_triple_shell(struct TripleShellParent *parent, s16 shellType) {
    s32 pad4;
    s32 pad3;
    s16 playerId;
    s16 pad0;
    s32 pad1;
    struct ShellActor *shell;
    Vec3f someVelocity;
    s32 pad2;
    s16 someCount;
    u16 someRotAngle;
    Player *player;

    playerId = parent->playerId;
    player = &gPlayers[playerId];
    parent->rotAngle += parent->rotVelocity;
    someRotAngle = parent->rotAngle;
    switch (parent->state) {
    case 0:
        if (func_802B19EC(parent, &gPlayers[playerId], shellType, 0U) != -1) {
            func_800C9060(playerId, 0x19008012);
            parent->shellsAvailable += 1;
        }
        parent->state = 1;
        break;
    case 1:
        if (parent->rotVelocity > 0) {
            if (someRotAngle >= 0xD556) {
                if (func_802B19EC(parent, &gPlayers[playerId], shellType, 1U) != -1) {
                    func_800C9060(playerId, 0x19008012);
                    parent->shellsAvailable += 1;
                }
                parent->state = 2;
            }
        } else {
            if (someRotAngle < 0x2AAA) {
                if (func_802B19EC(parent, &gPlayers[playerId], shellType, 1U) != -1) {
                    func_800C9060(playerId, 0x19008012);
                    parent->shellsAvailable += 1;
                }
                parent->state = 2;
            }
        }
        break;
    case 2:
        if (parent->rotVelocity > 0) {
            if ((someRotAngle >= 0x2AAB) && (someRotAngle < 0x31C7)) {
                if (func_802B19EC(parent, &gPlayers[playerId], shellType, 2U) != -1) {
                    func_800C9060(playerId, 0x19008012);
                    parent->shellsAvailable += 1;
                }
                parent->state = 3;
            }
        } else if ((someRotAngle < 0xD555) && (someRotAngle >= 0xCE39)) {
            if (func_802B19EC(parent, &gPlayers[playerId], shellType, 2U) != -1) {
                func_800C9060(playerId, 0x19008012);
                parent->shellsAvailable += 1;
            }
            parent->state = 3;
        }
        break;
    case 3:
        parent->state = 4;
        shell = (struct ShellActor*)&gActorList[(s16) parent->shellIndices[0]];
        shell->flags |= 0x4000;
        shell = (struct ShellActor*)&gActorList[(s16) parent->shellIndices[1]];
        shell->flags |= 0x4000;
        shell = (struct ShellActor*)&gActorList[(s16) parent->shellIndices[2]];
        shell->flags |= 0x4000;
        break;
    case 4:
        someCount = 0;
        if (func_802B0E14(parent->shellIndices[0]) == 1) {
            someCount = 1;
        } else {
            parent->shellIndices[0] = -1.0f;
        }
        if (func_802B0E14(parent->shellIndices[1]) == 1) {
            someCount++;
        } else {
            parent->shellIndices[1] = -1.0f;
        }
        if (func_802B0E14(parent->shellIndices[2]) == 1) {
            someCount++;
        } else {
            parent->shellIndices[2] = -1.0f;
        }
        if (someCount == 0) {
            destroy_actor((struct Actor *) parent);
            break;
        }
        if ((gControllers[parent->playerId].buttonPressed & 0x2000) != 0) {
            parent->unk_08 += 1.0f;
            gControllers[parent->playerId].buttonPressed &= ~0x2000;
        }
        if (parent->unk_08 > 0.0f) {
            if (parent->shellIndices[0] > 0.0f) {
                shell = &gActorList[(s16)parent->shellIndices[0]];
                if((shell->rotAngle < 0x38E) || (shell->rotAngle >= -0x38D)) {
                    someVelocity[0] = 0;
                    someVelocity[1] = 0;
                    someVelocity[2] = 8;
                    func_802B64C4(someVelocity, player->unk_02E + player->unk_0C0);
                    shell->velocity[0] = someVelocity[0];
                    shell->velocity[1] = someVelocity[1];
                    shell->velocity[2] = someVelocity[2];
                    shell->state = 2;
                    shell->someTimer = 0x001E;
                    func_800C9060(parent->playerId, 0x19008004);
                    func_800C90F4(parent->playerId, (player->characterId * 0x10) + 0x29008000);
                    if (parent->type == ACTOR_TRIPLE_RED_SHELL) {
                        func_8000ED80(parent->shellIndices[0]);
                    } else {
                        func_8000EDC8(parent->shellIndices[0]);
                    }
                    parent->shellIndices[0] = -1.0f;
                    parent->shellsAvailable -= 1;
                    parent->unk_08 -= 1.0f;
                    break;
                }
            }
            if (parent->shellIndices[1] > 0.0f) {
                shell = &gActorList[(s16)parent->shellIndices[1]];
                if((shell->rotAngle < 0xAA1) || (shell->rotAngle >= 0x38F)) {
                    someVelocity[0] = 0;
                    someVelocity[1] = 0;
                    someVelocity[2] = 8;
                    func_802B64C4(someVelocity, player->unk_02E + player->unk_0C0);
                    shell->velocity[0] = someVelocity[0];
                    shell->velocity[1] = someVelocity[1];
                    shell->velocity[2] = someVelocity[2];
                    shell->state = 2;
                    shell->someTimer = 0x001E;
                    func_800C90F4(parent->playerId, (player->characterId * 0x10) + 0x29008000);
                    func_800C9060(parent->playerId, 0x19008004);
                    if (parent->type == ACTOR_TRIPLE_RED_SHELL) {
                        func_8000ED80(parent->shellIndices[1]);
                    } else {
                        func_8000EDC8(parent->shellIndices[1]);
                    }
                    parent->shellIndices[1] = -1.0f;
                    parent->shellsAvailable -= 1;
                    parent->unk_08 -= 1.0f;
                    break;
                }
            }
            if (parent->shellIndices[2] > 0.0f) {
                shell = &gActorList[(s16)parent->shellIndices[2]];
                if((shell->rotAngle < -0x38E) || (shell->rotAngle >= -0x71B)) {
                    someVelocity[0] = 0;
                    someVelocity[1] = 0;
                    someVelocity[2] = 8;
                    func_802B64C4(someVelocity, player->unk_02E + player->unk_0C0);
                    shell->velocity[0] = someVelocity[0];
                    shell->velocity[1] = someVelocity[1];
                    shell->velocity[2] = someVelocity[2];
                    shell->state = 2;
                    shell->someTimer = 0x001E;
                    func_800C9060(parent->playerId, 0x19008004);
                    func_800C90F4(parent->playerId, (player->characterId * 0x10) + 0x29008000);
                    if (parent->type == ACTOR_TRIPLE_RED_SHELL) {
                        func_8000ED80(parent->shellIndices[2]);
                    } else {
                        func_8000EDC8(parent->shellIndices[2]);
                    }
                    parent->shellIndices[2] = -1.0f;
                    parent->shellsAvailable -= 1;
                    parent->unk_08 -= 1.0f;
                    break;
                }
            }
        }
        break;
    default:
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_triple_shell.s")
#endif

#ifdef NEEDS_RODATA
// The initial values for the starting* variables end up in D_802B9140, D_802B914C, and D_802B9154
// This function could reasonably be called "spawn_banana_bunch" or something similar

s32 func_802B17F4(Player *player) {
    Vec3f startingVelocity = {0.0f, 0.0f, 0.0f};
    Vec3s startingRot      = {0, 0, 0};
    Vec3f startingPos      = {0.0f, 0.0f, 0.0f};
    s16 actorIndex;
    struct BananaBunchParent *bananaBunch;

    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, ACTOR_BANANA_BUNCH);
    if (actorIndex < 0) {
        return actorIndex;
    }
    bananaBunch = &gActorList[actorIndex];
    bananaBunch->state = 0;
    bananaBunch->playerId = player - gPlayerOne;
    player->unk_00C |= 0x40000;
    return actorIndex;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B17F4.s")
#endif

#ifdef NEEDS_RODATA
// The initial values for the starting* variables end up in D_802B9160, D_802B916C, and D_802B9174
// This function could reasonably be called "spawn_triple_shell" or something similar

s32 func_802B18E4(Player *player, s16 tripleShellType) {
    Vec3f startingVelocity = {0.0f, 0.0f, 0.0f};
    Vec3s startingRot      = {0, 0, 0};
    Vec3f startingPos      = {0.0f, 0.0f, 0.0f};
    s16 actorIndex;
    struct TripleShellParent *parent;

    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, tripleShellType);
    if (actorIndex < 0) {
        return actorIndex;
    }
    parent = &gActorList[actorIndex];
    parent->state = 0;
    parent->rotVelocity = 0x05B0;
    parent->rotAngle = -0x8000;
    parent->playerId = player - gPlayerOne;
    parent->shellsAvailable = 0;
    parent->unk_08 = 0.0f;
    return actorIndex;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B18E4.s")
#endif

#ifdef NEEDS_RODATA
// The initial values for the starting* variables end up in D_802B9180 and D_802B918C
// This function could reasonably be called "spawn_shell_for_triple_shell" or something similar

s32 func_802B19EC(struct TripleShellParent *parent, Player *player, s16 shellType, u16 shellId) {
    Vec3f startingVelocity = {0.0f, 0.0f, 0.0f};
    Vec3s startingRot      = {0, 0, 0};
    Vec3f startingPos;
    s16 actorIndex;
    struct ShellActor *shell;

    startingPos[0] = 0.0f;
    startingPos[1] = -player->boundingBoxSize;
    startingPos[2] = player->boundingBoxSize - 4.0f;
    func_802B63B8(startingPos, player->unk_174);
    startingPos[0] += player->pos[0];
    startingPos[1] += player->pos[1];
    startingPos[2] += player->pos[2];

    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, shellType);
    if (actorIndex < 0) {
        parent->shellIndices[shellId] = -1.0f;
        return -1;
    }

    shell = &gActorList[actorIndex];
    startingPos[0] = player->pos[0];
    startingPos[1] = player->pos[1];
    startingPos[2] = player->pos[2];
    func_802AD950(&shell->unk30, shell->boundingBoxSize + 1.0f, shell->pos[0], shell->pos[1], shell->pos[2], startingPos[0], startingPos[1], startingPos[2]);
    func_802B4E30(shell);
    shell->flags = 0x9000;
    switch (shellType) {
    case ACTOR_GREEN_SHELL:
        shell->state = 4;
        break;
    case ACTOR_RED_SHELL:
        shell->state = 6;
        break;
    }
    shell->rotVelocity = 0;
    shell->rotAngle = -0x8000;
    shell->playerId = player - gPlayerOne;
    shell->parentIndex = (struct Actor*)parent - gActorList;
    shell->shellId = shellId;
    parent->shellIndices[shellId] = (struct Actor*)shell - gActorList;
    return 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B19EC.s")
#endif

#ifdef NEEDS_RODATA
// The initial values for the starting* variables end up in D_802B9194 and D_802B91A0
// This function could reasonably be called "spawn_green_shell" or something similar

s32 func_802B1C9C(Player *player) {
    Vec3f startingVelocity = {0.0f, 0.0f, 0.0f};
    Vec3s startingRot      = {0, 0, 0};
    Vec3f startingPos;
    s16 actorIndex;
    struct ShellActor *shell;

    startingPos[0] = 0.0f;
    startingPos[1] = -player->boundingBoxSize;
    startingPos[2] = player->boundingBoxSize - 4.0f;
    func_802B63B8(startingPos, player->unk_174);
    startingPos[0] += player->pos[0];
    startingPos[1] += player->pos[1];
    startingPos[2] += player->pos[2];
    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, ACTOR_GREEN_SHELL);
    if (actorIndex < 0) {
        return actorIndex;
    }

    shell = &gActorList[actorIndex];
    startingPos[0] = player->pos[0];
    startingPos[1] = player->pos[1];
    startingPos[2] = player->pos[2];
    func_802AD950(&shell->unk30, shell->boundingBoxSize + 1.0f, shell->pos[0], shell->pos[1], shell->pos[2], startingPos[0], startingPos[1], startingPos[2]);
    func_802B4E30(shell);
    shell->state = 0;
    shell->rotVelocity = 0;
    shell->rotAngle = -0x8000;
    shell->playerId = player - gPlayerOne;
    return actorIndex;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B1C9C.s")
#endif

#if NEEDS_RODATA
// The initial values for the starting* variables end up in D_802B91A8 and D_802B91B4
// This function could reasonably be called "spawn_red_blue_shell" or something similar

s32 func_802B1E48(Player *player) {
    Vec3f startingVelocity = {0.0f, 0.0f, 0.0f};
    Vec3s startingRot      = {0, 0, 0};
    Vec3f startingPos;
    s16 actorIndex;
    struct ShellActor *shell;

    startingPos[0] = 0.0f;
    startingPos[1] = -player->boundingBoxSize;
    startingPos[2] = player->boundingBoxSize - 4.0f;
    func_802B63B8(startingPos, player->unk_174);
    startingPos[0] += player->pos[0];
    startingPos[1] += player->pos[1];
    startingPos[2] += player->pos[2];
    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, ACTOR_RED_SHELL);
    if (actorIndex < 0) {
        return actorIndex;
    }

    shell = &gActorList[actorIndex];
    startingPos[0] = player->pos[0];
    startingPos[1] = player->pos[1];
    startingPos[2] = player->pos[2];
    func_802AD950(&shell->unk30, shell->boundingBoxSize + 1.0f, shell->pos[0], shell->pos[1], shell->pos[2], startingPos[0], startingPos[1], startingPos[2]);
    func_802B4E30(shell);
    shell->state = 0;
    shell->rotVelocity = 0;
    shell->rotAngle = player->unk_02E - 0x8000;
    shell->playerId = player - gPlayerOne;
    return actorIndex;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B1E48.s")
#endif

// This function could reasonably be called "spawn_blue_shell"
// Interestingly blue shells start their life as a red shell,
// and then just change the type from red to blue shell
void func_802B1FFC(Player *player) {
    gActorList[func_802B1E48(player)].type = ACTOR_BLUE_SPINY_SHELL;
}

#ifdef INCORRECT_REGALLOC
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b
void func_802B64C4(Vec3f, s16);                        /* extern */
extern u16 D_800DC51C;
extern s16 D_8015F6E8;
extern s16 D_8015F6EA;
extern s16 D_8015F6F0;
extern s16 D_8015F6F2;
extern struct Controller *gControllerOne;
// NEED_RODATA
extern f32 D_802B9EE0;// = 0.2f;
extern f32 D_802B9EE4;// = 0.15f;
extern f32 D_802B9EE8;// = 0.2f;
extern f32 D_802B9EEC;// = 0.2f;
extern f32 D_802B9EF0;// = 0.3f;

void update_obj_banana(struct BananaActor *banana) {
    f32 pad0;
    Player *player;
    struct BananaActor *elderBanana;
    struct Controller *controller;
    Vec3f someOtherVelocity;
    Vec3f someVelocity;
    f32 pad1;
    f32 pad2;
    f32 pad3;
    f32 pad4;
    f32 pad5;
    f32 temp_f0_3;
    f32 temp_f12;
    f32 x_dist;
    f32 y_dist;
    f32 z_dist;
    f32 x_pos;
    f32 y_pos;
    f32 z_pos;

    player = &gPlayers[banana->playerId];
    switch (banana->state) {
    case 0:
        x_dist = player->pos[0] - banana->pos[0];
        y_dist = player->pos[1] - banana->pos[1];
        z_dist = player->pos[2] - banana->pos[2];
        temp_f12 = sqrtf((x_dist * x_dist) + (y_dist * y_dist) + (z_dist * z_dist)) / 10.0f;
        if (temp_f12 == 0.0f) {
            banana->pos[0] = player->pos[0] + 0.2f;
            banana->pos[1] = player->pos[1] + 0.2f;
            banana->pos[2] = player->pos[2] + 0.2f;
        } else {
            x_dist /= temp_f12;
            y_dist /= temp_f12;
            z_dist /= temp_f12;
            banana->pos[0] =  player->pos[0] - x_dist;
            banana->pos[1] = (player->pos[1] - y_dist) - 2.0f;
            banana->pos[2] =  player->pos[2] - z_dist;
        }
        func_802ADDC8(&banana->unk30, banana->boundingBoxSize + 1.0f, banana->pos[0], banana->pos[1], banana->pos[2]);
        func_802B4E30((struct Actor *) banana);
        if ((player->unk_000 & 0x4000) != 0) {
            if (D_800DC51C != 0) {
                controller = gControllerOne;
            } else {
                controller = &gControllers[banana->playerId];
            }
            if ((controller->buttonDepressed & 0x2000) != 0) {
                controller->buttonDepressed &= ~0x2000;
                banana->state = 1;
                banana->unk_04 = 0x00B4;
                player->unk_00C &= ~0x40000;
                func_800C9060(player - gPlayerOne, 0x19008012);
                if (controller->rawStickY > 30.0f) {
                    if ((controller->rawStickX < 0xA) && (controller->rawStickX >= -9)) {
                        temp_f0_3 = ((controller->rawStickY - (f32)30) / 20.0f) + 0.5f;
                        if (player->unk_094 < 2.0f) {
                            temp_f12 = 4.0f;
                        } else {
                            temp_f12 = (player->unk_094 * 0.75f) + 3.5f + temp_f0_3;
                        }
                        vec3f_set(someVelocity, 0, temp_f0_3, temp_f12);
                        func_802B64C4(someVelocity, player->unk_02E + player->unk_0C0);
                        banana->velocity[0] = someVelocity[0];
                        banana->velocity[1] = someVelocity[1];
                        banana->velocity[2] = someVelocity[2];
                        break;
                    }
                }
                banana->velocity[0] = 0;
                banana->velocity[2] = 0;
                banana->velocity[1] = 1.5f;
            }
        }
        break;
    case 1:
        if (banana->unk_04 != 0) {
            banana->unk_04 -= 1;
            if (banana->unk_04 == 0) {
                banana->flags &= ~0x1000;
            }
        }
        banana->pos[0] += banana->velocity[0];
        banana->pos[2] += banana->velocity[2];
        if (banana->velocity[1] > -1.0f) {
            banana->velocity[1] -= 0.15f;
        }
        banana->pos[1] += banana->velocity[1];
        if ((banana->pos[2] < D_8015F6F2) || (D_8015F6F0 < banana->pos[2]) ||
            (banana->pos[0] < D_8015F6EA) || (D_8015F6E8 < banana->pos[0]) ||
            (banana->pos[1] < D_8015F6EE)) {
            func_8029FDC8((struct Actor *) banana);
        } else {
            func_802ADDC8(&banana->unk30, banana->boundingBoxSize + 1.0f, banana->pos[0], banana->pos[1], banana->pos[2]);
            banana->unk30.unk34 = 1;
            if ((banana->unk30.unk34 != 0) && (banana->unk30.unk44 < 0.0f)) {
                someOtherVelocity[0] = -banana->unk30.unk60[0];
                someOtherVelocity[1] = -banana->unk30.unk60[1];
                someOtherVelocity[2] = -banana->unk30.unk60[2];
                banana->pos[0] += someOtherVelocity[0] * banana->unk30.unk44;
                banana->pos[1] += someOtherVelocity[1] * banana->unk30.unk44;
                banana->pos[2] += someOtherVelocity[2] * banana->unk30.unk44;
                banana->flags &= ~0x1000;
                banana->state = 4;
            }
        }
        break;
    case 2:
        someVelocity[0] = 0.0f;
        someVelocity[1] = 0.0f;
        someVelocity[2] = -5.0f;
        func_802B64C4(someVelocity, player->unk_02E + player->unk_0C0);
        x_pos = someVelocity[0] + player->pos[0];
        y_pos = someVelocity[1] + player->pos[1];
        z_pos = someVelocity[2] + player->pos[2];
        x_dist = x_pos - banana->pos[0];
        y_dist = y_pos - banana->pos[1];
        z_dist = z_pos - banana->pos[2];
        // There lots of regalloc differences throughout this function, but it seems to
        // originate with an extra line of assembly near this function call
        temp_f12 = sqrtf((x_dist * x_dist) + (y_dist * y_dist) + (z_dist * z_dist));
        if (temp_f12 == 0.0f) {
            banana->pos[0] = player->pos[0] + 0.2f;
            banana->pos[1] = player->pos[1] + 0.2f;
            banana->pos[2] = player->pos[2] + 0.2f;
        } else {
            x_dist /= temp_f12;
            y_dist /= temp_f12;
            z_dist /= temp_f12;
            banana->pos[0] = someVelocity[0] + (x_pos - x_dist);
            banana->pos[1] = (y_pos - y_dist) - 2.0f;
            banana->pos[2] = z_pos - z_dist;
        }
        func_802ADDC8(&banana->unk30, banana->boundingBoxSize + 1.0f, banana->pos[0], banana->pos[1], banana->pos[2]);
        func_802B4E30((struct Actor *) banana);
        break;
    case 3:
        elderBanana = &gActorList[banana->elderIndex];
        x_dist = elderBanana->pos[0] - banana->pos[0];
        y_dist = elderBanana->pos[1] - banana->pos[1];
        z_dist = elderBanana->pos[2] - banana->pos[2];
        temp_f12 = sqrtf((x_dist * x_dist) + (y_dist * y_dist) + (z_dist * z_dist)) / 5.0f;
        if (temp_f12 == 0.0f) {
            banana->pos[0] = elderBanana->pos[0] + 0.2f;
            banana->pos[1] = elderBanana->pos[1] + 0.2f;
            banana->pos[2] = elderBanana->pos[2] + 0.2f;
        } else {
            x_dist /= temp_f12;
            y_dist /= temp_f12;
            z_dist /= temp_f12;
            banana->pos[0] =  elderBanana->pos[0] - x_dist;
            banana->pos[1] = (elderBanana->pos[1] - y_dist) - 2.0f;
            banana->pos[2] =  elderBanana->pos[2] - z_dist;
        }
        func_802ADDC8(&banana->unk30, banana->boundingBoxSize + 1.0f, banana->pos[0], banana->pos[1], banana->pos[2]);
        func_802B4E30((struct Actor *) banana);
        break;
    case 5:
        banana->velocity[1] -= 0.3f;
        if (banana->velocity[1] < -5.0f) {
            banana->velocity[1] = -5.0f;
        }
        banana->unk_04 += -1;
        banana->pos[1] += banana->velocity[1];
        banana->rot[0] += 0x16C;
        banana->rot[1] -= 0x5B0;
        banana->rot[2] += 0x38E;
        if (banana->unk_04 == 0) {
            destroy_actor((struct Actor *) banana);
        }
        break;
    case 4:
        banana->flags |= 0xC000;
        banana->flags &= ~0x1000;
        break;
    default:
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_banana.s")
#endif

#ifdef INCORRECT_REGALLOC
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b

void func_802B2914(struct BananaBunchParent *banana_bunch, Player *player, s16 bananaId) {
    s32 pad;
    Vec3f startingVelocity;
    Vec3s startingRot;
    Vec3f startingPos;
    s32 pad2;
    s16 actorIndex;
    struct BananaActor *newBanana;

    startingPos[0] = 0.0f;
    startingPos[1] = -player->boundingBoxSize;
    startingPos[2] = -(player->boundingBoxSize + 4.0f);
    func_802B63B8(startingPos, player->unk_174);
    startingPos[0] += player->pos[0];
    startingPos[1] += player->pos[1];
    startingPos[2] += player->pos[2];
    startingVelocity[0] = player->unk_034[0];
    startingVelocity[1] = player->unk_034[1];
    startingVelocity[2] = player->unk_034[2];
    startingRot[0] = 0;
    startingRot[1] = 0;
    startingRot[2] = 0;
    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, ACTOR_BANANA);
    if (actorIndex >= 0) {
        newBanana = &gActorList[actorIndex];
        startingPos[0] = player->pos[0];
        startingPos[1] = player->pos[1];
        startingPos[2] = player->pos[2];
        // This should be functionally correct, but there's a lot of bad regalloc nonsense going on starting here >:(
        func_802AD950(&newBanana->unk30, newBanana->boundingBoxSize + 1.0f, newBanana->pos[0], newBanana->pos[1], newBanana->pos[2], startingPos[0], startingPos[1], startingPos[2]);
        func_802B4E30(newBanana);
        newBanana->flags = 0x9000;
        newBanana->playerId = player - gPlayerOne;
        newBanana->parentIndex = (struct Actor*)banana_bunch - gActorList;
        newBanana->youngerIndex = -1;
        newBanana->unk_04 = 0x0014;
        newBanana->bananaId = bananaId;
        switch (bananaId) {
        case 0:
            newBanana->state = 2;
            banana_bunch->bananaIndices[0] = actorIndex;
            newBanana->elderIndex = -1;
            break;
        case 1:
            newBanana->state = 3;
            banana_bunch->bananaIndices[1] = actorIndex;
            newBanana->elderIndex = banana_bunch->bananaIndices[0];
            ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[0]])->youngerIndex = actorIndex;
            break;
        case 2:
            newBanana->state = 3;
            banana_bunch->bananaIndices[2] = actorIndex;
            newBanana->elderIndex = banana_bunch->bananaIndices[1];
            ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[1]])->youngerIndex = actorIndex;
            break;
        case 3:
            newBanana->state = 3;
            banana_bunch->bananaIndices[3] = actorIndex;
            newBanana->elderIndex = banana_bunch->bananaIndices[2];
            ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[2]])->youngerIndex = actorIndex;
            break;
        case 4:
            newBanana->state = 3;
            banana_bunch->bananaIndices[4] = actorIndex;
            newBanana->elderIndex = banana_bunch->bananaIndices[3];
            ((struct BananaActor*)&gActorList[banana_bunch->bananaIndices[3]])->youngerIndex = actorIndex;
            break;
        }
        if ((player->unk_000 & 0x4000) != 0) {
            func_800C9060(player - gPlayerOne, 0x19008012);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2914.s")
#endif

#ifdef INCORRECT_REGALLOC
// This function could reasonably be called "spawn_fake_item_box" or similar

s32 func_802B2C40(Player *player) {
    struct FakeItemBox *itemBox;
    s32 pad[4];
    s32 playerId;
    s16 actorIndex;
    Vec3f startingVelocity;
    Vec3s startingRot;
    Vec3f startingPos;

    startingPos[0] = 0.0f;
    startingPos[1] = -player->boundingBoxSize;
    startingPos[2] = -(player->boundingBoxSize + 4.0f);
    func_802B63B8(startingPos, player->unk_174);
    startingPos[0] += player->pos[0];
    startingPos[1] += player->pos[1];
    startingPos[2] += player->pos[2];
    startingVelocity[0] = player->unk_034[0];
    startingVelocity[1] = player->unk_034[1];
    startingVelocity[2] = player->unk_034[2];
    startingRot[0] = 0;
    startingRot[1] = 0;
    startingRot[2] = 0;
    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, ACTOR_FAKE_ITEM_BOX);
    if (actorIndex < 0) {
        return actorIndex;
    }
    // Dumb regalloc differences starting here >:(
    playerId = player - gPlayerOne;
    itemBox = &gActorList[actorIndex];
    itemBox->state = 0;
    itemBox->playerId = playerId;
    player->unk_00C |= 0x40000;
    return actorIndex;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2C40.s")
#endif

// This function could reasonably be called "spawn_banana" or similar
s32 func_802B2D70(Player *player) {
    s32 pad[6];
    u16 playerId;
    s16 actorIndex;
    struct BananaActor *banana;
    Vec3f startingVelocity;
    Vec3s startingRot;
    Vec3f startingPos;

    playerId = player - gPlayerOne;
    if (playerId >= 8) {
        return -1;
    }
    // Extremely weird fake match to fix a tiny stack difference
    startingPos[0, 0] = 0.0f;
    startingPos[1] = -player->boundingBoxSize;
    startingPos[2] = -(player->boundingBoxSize + 4.0f);
    func_802B63B8(startingPos, player->unk_174);
    startingPos[0] += player->pos[0];
    startingPos[1] += player->pos[1];
    startingPos[2] += player->pos[2];
    startingVelocity[0] = player->unk_034[0];
    startingVelocity[1] = player->unk_034[1];
    startingVelocity[2] = player->unk_034[2];
    startingRot[0] = 0;
    startingRot[1] = 0;
    startingRot[2] = 0;
    actorIndex = func_8029EC88(startingPos, startingRot, startingVelocity, ACTOR_BANANA);
    if (actorIndex < 0) {
        return actorIndex;
    }
    banana = &gActorList[actorIndex];
    banana->playerId = playerId;
    banana->state = 0;
    banana->unk_04 = 0x0014;
    player->unk_00C |= 0x40000;
    return actorIndex;
}

// Something related to the thunderbolt item
void func_802B2EBC(Player *player) {
    s32 playerIndex;
    Player *otherPlayer;

    func_8009E5BC();
    if ((player->unk_000 & 0x4000) != 0) {
        func_800CAB4C(player - gPlayerOne);
    }

    for (playerIndex = 0; playerIndex < 8; playerIndex++) {
        otherPlayer = &gPlayers[playerIndex];
        if (player != otherPlayer) {
            otherPlayer->unk_00C |= 0x4000;
        }
    }
}

#ifdef NEEDS_RODATA
// Needs jpt_802B9F08, otherwise this matches

void func_802B2FA0(Player *player) {
    s32 playerId = player - gPlayerOne;

    switch (player->unk_010) {
    case ITEM_GREEN_SHELL:
        func_802B1C9C(player);
        break;
    case ITEM_RED_SHELL:
        func_802B1E48(player);
        break;
    case ITEM_BLUE_SPINY_SHELL:
        func_802B1FFC(player);
        break;
    case ITEM_BANANA:
        func_802B2D70(player);
        break;
    case ITEM_BANANA_BUNCH:
        func_802B17F4(player);
        break;
    case ITEM_MUSHROOM:
        player->unk_00C |= 0x200;
        break;
    case ITEM_DOUBLE_MUSHROOM:
        player->unk_00C |= 0x200;
        break;
    case ITEM_TRIPLE_MUSHROOM:
        player->unk_00C |= 0x200;
        break;
    case ITEM_SUPER_MUSHROOM:
        player->unk_00C |= 0x200;
        break;
    case ITEM_BOO:
        player->unk_00C |= 0x800;
        break;
    case ITEM_STAR:
        player->unk_00C |= 0x2000;
        break;
    case ITEM_THUNDERBOLT:
        func_802B2EBC(player);
        break;
    case ITEM_FAKE_ITEM_BOX:
        func_802B2C40(player);
        break;
    case ITEM_TRIPLE_GREEN_SHELL:
        func_802B18E4(player, ACTOR_TRIPLE_GREEN_SHELL);
        break;
    case ITEM_TRIPLE_RED_SHELL:
        func_802B18E4(player, ACTOR_TRIPLE_RED_SHELL);
        break;
    }
    func_8007AC9C(playerId);
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2FA0.s")
#endif

void func_802B30EC(void) {
    Player *player;
    struct Controller *target;
    struct Controller *controller;
    struct Controller *loopController;

    for (player = &gPlayers[0], loopController = &gControllers[0], target = &gControllers[4]; loopController != target; player++, loopController++) {
        controller = loopController;
        if (func_800910E4(player) == 0) {
            if((player->unk_000 & 0x100) != 0){
                if ((player - gPlayerTwo) == 0) {
                    controller = gControllerSix;
                } else if((player - gPlayerThree) == 0) {
                    controller = gControllerSeven;
                } else {
                    if ((player - gPlayerOne) == 0) {
                        controller = gControllerEight;
                    }
                }
            }

            if (((player->unk_000 & 0x4000) != 0) && (player->unk_010 != ITEM_NONE) && ((player->unk_000 & 0x2000) == 0)) {
                if ((controller->buttonPressed & 0x2000) != 0) {
                    controller->buttonPressed &= ~0x2000;
                    func_802B2FA0(player);
                }
            }
        }
    }
}

#ifdef MIPS_TO_C
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b
? func_8000EDC8(s32);                               /* extern */
? func_802AC098(UnkActorInner *, f32 *);            /* extern */
? func_802AD950(UnkActorInner *, ?, f32, f32, f32, f32, f32, f32); /* extern */
? func_802B63B8(f32 *, f32 *, f32 *);               /* extern */
? func_802B64C4(f32 *, s16);                        /* extern */
extern s16 D_8015F6E8;
extern s16 D_8015F6EA;
extern s16 D_8015F6F0;
extern s16 D_8015F6F2;
static f32 D_802B9F5C = 1.2f;
static f32 D_802B9F60 = 1.2f;
static f32 D_802B9F64 = 0.3f;

void update_obj_green_shell(struct ShellActor *shell) {
    f32 sp80;
    f32 sp7C;
    f32 sp78;
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp54;
    UnkActorInner *sp34;
    Player *temp_s1;
    Player *temp_s1_2;
    Player *temp_s1_4;
    UnkActorInner *temp_a0;
    f32 *temp_s1_3;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f14;
    f32 temp_f2;
    f32 temp_f2_2;
    s16 temp_t4;
    s16 temp_v0_2;
    s16 temp_v0_3;
    struct Controller *temp_v0;
    struct TripleShellParent *temp_v0_4;
    u16 temp_t3;
    u16 temp_v1;
    f32 phi_f2;
    f32 phi_f2_2;

    temp_f2 = shell->pos[2];
    temp_f0 = shell->pos[0];
    if ((temp_f2 < (f32) D_8015F6F2) || ((f32) D_8015F6F0 < temp_f2) || (temp_f0 < (f32) D_8015F6EA) || ((f32) D_8015F6E8 < temp_f0) || (shell->pos[1] < (f32) D_8015F6EE)) {
        func_8029FDC8((struct Actor *) shell);
    }
    temp_t3 = (u16) shell->state;
    shell->rotVelocity += 0x71C;
    switch (temp_t3) {
    case 0:
        temp_s1 = &gPlayers[shell->playerId];
        func_802B0210(&temp_s1->unk_110, &shell->unk30);
        sp6C = 0.0f;
        sp70 = temp_s1->boundingBoxSize;
        sp74 = -(temp_s1->boundingBoxSize + shell->boundingBoxSize + 2.0f);
        func_802B63B8(&sp6C, temp_s1->unk_174);
        shell->pos[0] = sp6C + temp_s1->pos[0];
        temp_f14 = temp_s1->pos[1] - sp70;
        shell->pos[2] = sp74 + temp_s1->pos[2];
        sp54 = temp_f14;
        temp_f0_2 = func_802ABE30(shell->pos[0], temp_f14, shell->pos[2], temp_s1->unk_110.unk3A);
        temp_f2_2 = temp_f14 - temp_f0_2;
        if ((temp_f2_2 < 5.0f) && (temp_f2_2 > -5.0f)) {
            shell->pos[1] = shell->boundingBoxSize + temp_f0_2;
        } else {
            shell->pos[1] = temp_f14;
        }
        if ((temp_s1->unk_000 & 0x4000) != 0) {
            temp_v0 = &gControllers[shell->playerId];
            temp_v1 = temp_v0->buttonDepressed;
            if ((temp_v1 & 0x2000) != 0) {
                temp_v0->buttonDepressed = temp_v1 & 0xDFFF;
                if (temp_v0->rawStickY < -0x2D) {
                    temp_f0_3 = temp_s1->unk_094;
                    phi_f2 = 8.0f;
                    if (temp_f0_3 > 8.0f) {
                        phi_f2 = temp_f0_3 * D_802B9F5C;
                    }
                    sp6C = 0.0f;
                    sp70 = 0.0f;
                    sp74 = -phi_f2;
                    func_802B64C4(&sp6C, (s16) (temp_s1->unk_02E + temp_s1->unk_0C0));
                    shell->velocity[0] = sp6C;
                    shell->velocity[1] = sp70;
                    shell->state = 2;
                    shell->velocity[2] = sp74;
                    func_800C9060((Player *) shell->unk15, 0x19008004);
                    func_800C90F4((Player *) shell->unk15, (temp_s1->characterId * 0x10) + 0x29008000);
                    func_8000EDC8((s32) (shell - gActorList) / 112);
                    return;
                }
                shell->state = 1;
                if (temp_s1->unk_0C0 > 0) {
                    shell->rotAngle = 0x78E3;
                    return;
                }
                shell->rotAngle = -0x78E4;
                return;
            }
        }
    default:
        return;
    case 1:
        temp_v0_2 = shell->rotAngle;
        temp_s1_2 = &gPlayers[shell->playerId];
        if (temp_v0_2 > 0) {
            shell->rotAngle = temp_v0_2 - 0xE38;
            if (shell->rotAngle < 0) {
                shell->state = 2;
                shell->parentIndex = 0x001E;
                func_800C9060((Player *) shell->unk15, 0x19008004);
                func_800C90F4((Player *) shell->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                func_8000EDC8((s32) (shell - gActorList) / 112);
            }
        } else {
            shell->rotAngle = temp_v0_2 + 0xE38;
            if (shell->rotAngle > 0) {
                shell->state = 2;
                shell->parentIndex = 0x001E;
                func_800C9060((Player *) shell->unk15, 0x19008004);
                func_800C90F4((Player *) shell->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                func_8000EDC8((s32) (shell - gActorList) / 112);
            }
        }
        if (shell->state == 2) {
            temp_f0_4 = temp_s1_2->unk_094;
            phi_f2_2 = 8.0f;
            if (temp_f0_4 > 8.0f) {
                phi_f2_2 = temp_f0_4 * D_802B9F60;
            }
            sp6C = 0.0f;
            sp70 = 0.0f;
            sp74 = phi_f2_2;
            func_802B64C4(&sp6C, (s16) (temp_s1_2->unk_02E + temp_s1_2->unk_0C0));
            shell->velocity[0] = sp6C;
            shell->velocity[1] = sp70;
            shell->velocity[2] = sp74;
            return;
        }
        sp6C = sins((u16) shell->rotAngle) * 6.0f;
        sp70 = shell->boundingBoxSize - temp_s1_2->boundingBoxSize;
        sp74 = coss((u16) shell->rotAngle) * 6.0f;
        func_802B63B8(&sp6C, temp_s1_2->unk_174);
        shell->pos[0] = sp6C + temp_s1_2->pos[0];
        shell->pos[1] = sp70 + temp_s1_2->pos[1];
        shell->pos[2] = sp74 + temp_s1_2->pos[2];
        return;
    case 2:
        temp_v0_3 = shell->parentIndex;
        if (temp_v0_3 > 0) {
            shell->parentIndex = temp_v0_3 - 1;
            if (shell->parentIndex == 0) {
                shell->flags &= 0xEFFF;
            }
        }
        shell->velocity[1] -= 0.5f;
        if (shell->velocity[1] < -2.0f) {
            shell->velocity[1] = -2.0f;
        }
        temp_a0 = &shell->unk30;
        sp78 = shell->pos[0];
        sp7C = shell->pos[1];
        sp80 = shell->pos[2];
        shell->pos[0] += shell->velocity[0];
        shell->pos[1] += shell->velocity[1];
        shell->pos[2] += shell->velocity[2];
        sp34 = temp_a0;
        func_802AD950(temp_a0, 0x40800000, shell->pos[0], shell->pos[1], shell->pos[2], sp78, sp7C, sp80);
        func_802B4E30((struct Actor *) shell);
        temp_s1_3 = shell->velocity;
        if ((shell->unk30.unk3C < 0.0f) || (shell->unk30.unk40 < 0.0f)) {
            func_802AC098(temp_a0, temp_s1_3);
            func_800C98B8(shell->pos, temp_s1_3, 0x19008054U);
            shell->flags |= 0x80;
            return;
        }
        break;
    case 4:
        temp_v0_4 = &gActorList[shell->parentIndex];
        temp_s1_4 = &gPlayers[shell->playerId];
        if (temp_v0_4->type != 0x0015) {
            func_8029FDC8((struct Actor *) shell);
            return;
        }
        temp_t4 = shell->rotAngle + temp_v0_4->rotVelocity;
        shell->rotAngle = temp_t4;
        sp6C = sins(temp_t4 & 0xFFFF) * 8.0f;
        sp70 = shell->boundingBoxSize - temp_s1_4->boundingBoxSize;
        sp74 = coss((u16) shell->rotAngle) * 8.0f;
        func_802B63B8((bitwise f32 *) 8.0f, &sp6C, temp_s1_4->unk_174);
        sp78 = shell->pos[0];
        sp7C = shell->pos[1];
        sp80 = shell->pos[2];
        shell->pos[0] = sp6C + temp_s1_4->pos[0];
        shell->pos[1] = sp70 + temp_s1_4->pos[1];
        shell->pos[2] = sp74 + temp_s1_4->pos[2];
        func_802AD950(&shell->unk30, 0x40800000, shell->pos[0], shell->pos[1], shell->pos[2], sp78, sp7C, sp80);
        func_802B4E30((struct Actor *) shell);
        return;
    case 5:
        shell->velocity[1] -= D_802B9F64;
        if (shell->velocity[1] < -5.0f) {
            shell->velocity[1] = -5.0f;
        }
        shell->parentIndex -= 1;
        shell->rotAngle += 0x5B0;
        shell->pos[1] += shell->velocity[1];
        if (shell->parentIndex == 0) {
            destroy_actor((struct Actor *) shell);
        }
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_green_shell.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b
? func_802AD950(UnkActorInner *, f32, f32, f32, f32, f32, f32, f32); /* extern */
extern u16 D_80164430;
extern s32 D_80164490;

void func_802B3B44(struct ShellActor *shell) {
    f32 spAC;
    f32 spA8;
    f32 spA4;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp60;
    f32 sp5C;
    f32 sp58;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f12_3;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f16_3;
    f32 temp_f18;
    f32 temp_f18_2;
    f32 temp_f18_3;
    f32 temp_f20;
    f32 temp_f22;
    f32 temp_f22_2;
    f32 temp_f24;
    f32 temp_f26;
    f32 temp_f28;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    s32 temp_a1;
    s32 temp_a3;
    s32 temp_t1;
    u16 temp_t0;
    u16 temp_v1;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    s16 phi_a2;
    f32 phi_f2;
    f32 phi_f14;
    f32 phi_f16;

    temp_v1 = (u16) shell->rotAngle;
    temp_t1 = D_80164490;
    temp_v0 = temp_t1 + (temp_v1 * 8);
    temp_t0 = D_80164430;
    temp_a1 = temp_v1 + 1;
    temp_a3 = temp_a1 & 0xFFFF;
    temp_f2 = (f32) temp_v0->unk0;
    temp_f12 = (f32) temp_v0->unk2;
    temp_f28 = (f32) temp_v0->unk4;
    phi_a2 = temp_a1 & 0xFFFF;
    if (temp_a3 >= (s32) temp_t0) {
        phi_a2 = (temp_a3 - temp_t0) & 0xFFFF;
    }
    temp_f0 = shell->pos[0];
    temp_f16 = shell->pos[1];
    temp_f18 = shell->pos[2];
    temp_f20 = temp_f2 - temp_f0;
    temp_f22 = temp_f12 - temp_f16;
    temp_v0_2 = temp_t1 + (phi_a2 * 8);
    temp_f24 = temp_f28 - temp_f18;
    sp60 = temp_f0;
    sp5C = temp_f16;
    sp58 = temp_f18;
    temp_f14 = (temp_f20 * temp_f20) + (temp_f22 * temp_f22) + (temp_f24 * temp_f24);
    if (temp_f14 > 400.0f) {
        temp_f0_2 = (f32) temp_v0_2->unk0 - sp60;
        temp_f2_2 = (f32) temp_v0_2->unk2 - sp5C;
        temp_f12_2 = (f32) temp_v0_2->unk4 - sp58;
        if (((temp_f0_2 * temp_f0_2) + (temp_f2_2 * temp_f2_2) + (temp_f12_2 * temp_f12_2)) < temp_f14) {
            shell->rotAngle = phi_a2;
            return;
        }
        temp_f18_2 = sqrtf(temp_f14) * 4.0f;
        temp_f22_2 = temp_f22 / temp_f18_2;
        temp_f2_3 = shell->velocity[0] + (temp_f20 / temp_f18_2);
        temp_f10 = temp_f2_3 * temp_f2_3;
        spAC = temp_f2_3;
        temp_f14_2 = shell->velocity[1] + temp_f22_2;
        spA8 = temp_f14_2;
        temp_f16_2 = shell->velocity[2] + (temp_f24 / temp_f18_2);
        spA4 = temp_f16_2;
        temp_f0_3 = sqrtf(temp_f10 + (temp_f14_2 * temp_f14_2) + (temp_f16_2 * temp_f16_2));
        phi_f2 = temp_f2_3;
        phi_f14 = temp_f14_2;
        phi_f16 = temp_f16_2;
        if (temp_f0_3 > 6.0f) {
            temp_f12_3 = temp_f0_3 / 6.0f;
            phi_f2 = temp_f2_3 / temp_f12_3;
            phi_f14 = temp_f14_2 / temp_f12_3;
            phi_f16 = temp_f16_2 / temp_f12_3;
        }
        shell->velocity[0] = phi_f2;
        shell->velocity[1] = phi_f14;
        shell->velocity[2] = phi_f16;
        sp68 = shell->pos[0];
        sp6C = shell->pos[1];
        sp70 = shell->pos[2];
        shell->pos[0] += phi_f2;
        shell->pos[1] += phi_f14;
        shell->pos[2] += phi_f16;
        func_802AD950(&shell->unk30, 4.0f, shell->pos[0], shell->pos[1], shell->pos[2], sp68, sp6C, sp70);
        func_802B4E30((struct Actor *) shell);
        return;
    }
    temp_v0_3 = temp_t1 + (phi_a2 * 8);
    if (temp_f14 > 5.0f) {
        shell->pos[0] = temp_f2;
        shell->pos[2] = temp_f28;
        shell->rotAngle = phi_a2;
        shell->pos[1] = shell->boundingBoxSize + temp_f12;
        return;
    }
    temp_f16_3 = (f32) temp_v0_3->unk0;
    temp_f18_3 = (f32) temp_v0_3->unk2;
    temp_f26 = (f32) temp_v0_3->unk4;
    shell->pos[0] = (temp_f2 + temp_f16_3) * 0.5f;
    shell->pos[1] = ((temp_f12 + temp_f18_3) * 0.5f) + shell->boundingBoxSize;
    shell->pos[2] = (temp_f28 + temp_f26) * 0.5f;
    shell->velocity[0] = (temp_f16_3 - temp_f2) * 0.5f;
    shell->velocity[1] = (temp_f18_3 - temp_f12) * 0.5f;
    shell->velocity[2] = (temp_f26 - temp_f28) * 0.5f;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B3B44.s")
#endif

#ifdef INCORRECT_REGALLOC
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b

void func_802B3E7C(struct ShellActor *shell, Player *player) {
    f32 x_dist;
    f32 z_dist;
    f32 xz_dist;
    Vec3f oldPosition;
    f32 x_velocity;
    f32 z_velocity;

    x_dist = player->pos[0];
    x_dist -= shell->pos[0];
    z_dist = player->pos[2];
    z_dist -= shell->pos[2];
    // Dumb register allocation difference occuring here >:(
    xz_dist = sqrtf((x_dist * x_dist) + (z_dist * z_dist)) / 8;
    if (xz_dist == 0.0f) {
        x_velocity = 0.0f;
        z_velocity = 0.0f;
    } else {
        x_velocity = x_dist / xz_dist;
        // Weird fake match
        if (1) {};
        z_velocity = z_dist / xz_dist;
    }
    oldPosition[0] = shell->pos[0];
    oldPosition[1] = shell->pos[1];
    oldPosition[2] = shell->pos[2];
    shell->pos[0] += x_velocity;
    shell->pos[1] -= 2.0f;
    shell->pos[2] += z_velocity;
    shell->velocity[0] = x_velocity;
    shell->velocity[1] = -2.0f;
    shell->velocity[2] = z_velocity;
    if (player->unk_0BC & 0x80000000) {
        func_8029FDC8((struct Actor *) shell);
    } else {
        func_802AD950(&shell->unk30, 4.0f, shell->pos[0], shell->pos[1], shell->pos[2], oldPosition[0], oldPosition[1], oldPosition[2]);
        func_802B4E30((struct Actor *) shell);
        func_802B4104(shell);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B3E7C.s")
#endif

#ifdef INCORRECT_REGALLOC
// Something to do with red shells
// Only used in Battle mode
// Probably trying to find the player that is not the shell owner, is still alive and is closest to the shell

s16 func_802B3FD0(Player *owner, struct ShellActor *shell) {
    Player *player;
    s32 playerIndex;
    f32 playerToShellDistance;
    s16 playerId = -1;
    f32 minimumDistance = D_802B9F68; // 2.5e7, so a really big starting number

    for (playerIndex = 0; playerIndex < 4; playerIndex++) {
        player = &gPlayers[playerIndex];
        if (((player->unk_000 & 0x8000) != 0) && (player != owner) && (gPlayerBalloonCount[playerIndex] >= 0)) {
            // func_802B51E8 is not quite a 3D distance function, it doubles (rather than squares) the Z difference of the positions
            playerToShellDistance = func_802B51E8(player->pos, shell->pos);
            if (playerToShellDistance < minimumDistance) {
                playerId = player - gPlayerOne;
                minimumDistance = playerToShellDistance;
            }
        }
    }

    return playerId;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B3FD0.s")
#endif

void func_802B4104(struct ShellActor *shell) {
    if ((shell->unk30.unk3C < 0.0f) && ((shell->unk30.unk48[1] < 0.25f) || (shell->unk30.unk48[1] > -0.25f))) {
        func_8029FDC8((struct Actor *) shell);
        func_800C98B8(shell->pos, shell->velocity, 0x19008054U);
        shell->flags |= 0x80;
    } else if ((shell->unk30.unk40 < 0.0f) && ((shell->unk30.unk54[1] < 0.25f) || (shell->unk30.unk54[1] < -0.25f))) {
        func_8029FDC8((struct Actor *) shell);
        func_800C98B8(shell->pos, shell->velocity, 0x19008054U);
        shell->flags |= 0x80;
    }
}

#ifdef MIPS_TO_C
//generated by m2c commit a8f43e46d33dcb7e04d9cdc44a10b3daf4c92c3b
? func_8000ED80(s32);                               /* extern */
? func_8000EE10(s32);                               /* extern */
? func_802B3B44(struct ShellActor *);               /* extern */
s16 func_802B3FD0(Player *, struct ShellActor *);   /* extern */
? func_802B63B8(f32 *, f32 *);                      /* extern */
? func_802B64C4(f32 *, s16);                        /* extern */
extern s16 D_8015F6E8;
extern s16 D_8015F6EA;
extern s16 D_8015F6F0;
extern s16 D_8015F6F2;
extern u16 D_80164430;
extern ? D_80164438;
extern struct Controller *gControllerOne;
extern s16 gPlayerPositionLUT;
static f32 D_802B9F94 = 1.2f;
static f32 D_802B9F98 = 40000.0f;
static f32 D_802B9F9C = 0.3f;
static f32 D_802B9FA0 = 40000.0f;

void update_obj_red_blue_shell(struct ShellActor *shell) {
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp68;
    s16 sp56;
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    Player *temp_s1;
    Player *temp_s1_2;
    Player *temp_s1_3;
    Player *temp_s1_4;
    Player *temp_s1_5;
    Player *temp_s1_6;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f14;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    f32 temp_f2_4;
    f32 temp_f2_5;
    s16 temp_t6;
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s16 temp_v0_5;
    s16 temp_v0_6;
    struct TripleShellParent *temp_v0_7;
    u16 temp_t4;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    u16 temp_v1_4;
    struct Controller *phi_v0;
    f32 phi_f0;
    s16 phi_v0_2;
    s16 phi_v0_3;
    s16 phi_v0_4;

    temp_f2 = shell->pos[2];
    temp_f0 = shell->pos[0];
    sp56 = shell->type;
    if ((temp_f2 < (f32) D_8015F6F2) || ((f32) D_8015F6F0 < temp_f2) || (temp_f0 < (f32) D_8015F6EA) || ((f32) D_8015F6E8 < temp_f0) || (shell->pos[1] < (f32) D_8015F6EE)) {
        func_8029FDC8((struct Actor *) shell);
    }
    temp_t4 = (u16) shell->state;
    shell->rotVelocity += 0x71C;
    switch (temp_t4) {
    case 0:
        temp_s1 = &gPlayers[shell->playerId];
        func_802B0210(&temp_s1->unk_110, &shell->unk30);
        sp8C = 0.0f;
        sp90 = temp_s1->boundingBoxSize;
        sp94 = -(temp_s1->boundingBoxSize + shell->boundingBoxSize + 2.0f);
        func_802B63B8(&sp8C, temp_s1->unk_174);
        shell->pos[0] = sp8C + temp_s1->pos[0];
        temp_f14 = temp_s1->pos[1] - sp90;
        shell->pos[2] = sp94 + temp_s1->pos[2];
        sp68 = temp_f14;
        temp_f0_2 = func_802ABE30(shell->pos[0], temp_f14, shell->pos[2], temp_s1->unk_110.unk3A);
        temp_f2_2 = temp_f14 - temp_f0_2;
        if ((temp_f2_2 < 5.0f) && (temp_f2_2 > -5.0f)) {
            shell->pos[1] = shell->boundingBoxSize + temp_f0_2;
        } else {
            shell->pos[1] = temp_f14;
        }
        if ((temp_s1->unk_000 & 0x4000) != 0) {
            if (D_800DC51C != 0) {
                goto block_16;
            }
            phi_v0 = &gControllers[shell->playerId];
        } else {
block_16:
            phi_v0 = gControllerOne;
        }
        temp_v1 = phi_v0->buttonDepressed;
        if ((temp_v1 & 0x2000) != 0) {
            phi_v0->buttonDepressed = temp_v1 & 0xDFFF;
            shell->state = 1;
            if (temp_s1->unk_0C0 > 0) {
                shell->rotAngle = 0x78E3;
                return;
            }
            shell->rotAngle = -0x78E4;
            return;
        }
    default:
        return;
    case 1:
        temp_v0 = shell->rotAngle;
        temp_s1_2 = &gPlayers[shell->playerId];
        if (temp_v0 > 0) {
            shell->rotAngle = temp_v0 - 0x71C;
            if (shell->rotAngle < 0) {
                shell->state = 2;
                func_800C9060(shell->unk15, 0x19008004);
                func_800C90F4(shell->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                if (sp56 == 8) {
                    func_8000ED80((s32) (shell - gActorList) / 112);
                } else {
                    func_8000EE10((s32) (shell - gActorList) / 112);
                    func_800C9D80((f32 (*)[3]) shell->pos, (f32 (*)[3]) shell->velocity, 0x51018008U);
                }
            }
        } else {
            shell->rotAngle = temp_v0 + 0x71C;
            if (shell->rotAngle > 0) {
                shell->state = 2;
                func_800C9060(shell->unk15, 0x19008004);
                func_800C90F4(shell->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                if (sp56 == 8) {
                    func_8000ED80((s32) (shell - gActorList) / 112);
                } else {
                    func_8000EE10((s32) (shell - gActorList) / 112);
                    func_800C9D80((f32 (*)[3]) shell->pos, (f32 (*)[3]) shell->velocity, 0x51018008U);
                }
            }
        }
        if (shell->state == 2) {
            shell->parentIndex = 0x001E;
            temp_f2_3 = temp_s1_2->unk_094;
            phi_f0 = 8.0f;
            if (temp_f2_3 > 8.0f) {
                phi_f0 = temp_f2_3 * D_802B9F94;
            }
            sp94 = phi_f0;
            sp8C = 0.0f;
            sp90 = 0.0f;
            func_802B64C4(&sp8C, (s16) (temp_s1_2->unk_02E + temp_s1_2->unk_0C0));
            shell->velocity[0] = sp8C;
            shell->velocity[1] = sp90;
            shell->velocity[2] = sp94;
            return;
        }
        sp8C = sins((u16) shell->rotAngle) * 8.0f;
        sp90 = shell->boundingBoxSize - temp_s1_2->boundingBoxSize;
        sp94 = coss((u16) shell->rotAngle) * 8.0f;
        func_802B63B8(&sp8C, temp_s1_2->unk_174);
        shell->pos[0] = sp8C + temp_s1_2->pos[0];
        shell->pos[1] = sp90 + temp_s1_2->pos[1];
        shell->pos[2] = sp94 + temp_s1_2->pos[2];
        return;
    case 2:
        shell->parentIndex += -1;
        temp_s1_3 = &gPlayers[shell->playerId];
        if (shell->parentIndex == 0) {
            shell->flags &= 0xEFFF;
            if (shell->type == 0x002A) {
                shell->state = 8;
                shell->parentIndex = gPlayerPositionLUT;
                shell->shellId = 1000.0f;
                temp_v1_2 = D_80164430;
                temp_v0_2 = *(&D_80164438 + (((s32) (temp_s1_3 - gPlayerOne) / 3544) * 2)) + 8;
                phi_v0_2 = temp_v0_2;
                if ((s32) temp_v1_2 < temp_v0_2) {
                    phi_v0_2 = (s16) (temp_v0_2 - temp_v1_2);
                }
                shell->rotAngle = phi_v0_2;
            } else if (gModeSelection == (s32) 3) {
                shell->shellId = 1000.0f;
                shell->parentIndex = func_802B3FD0(temp_s1_3, shell);
                if (shell->parentIndex < 0) {
                    shell->flags = -0x8000;
                    shell->rotAngle = 0;
                    shell->parentIndex = 0x003C;
                    shell->state = 7;
                    shell->velocity[1] = 3.0f;
                } else {
                    shell->state = 3;
                }
            } else {
                temp_v0_3 = temp_s1_3->currentRank;
                if (temp_v0_3 == 0) {
                    shell->state = 4;
                    shell->parentIndex = 0x0258;
                    temp_v1_3 = D_80164430;
                    temp_v0_4 = *(&D_80164438 + (((s32) (temp_s1_3 - gPlayerOne) / 3544) * 2)) + 8;
                    phi_v0_3 = temp_v0_4;
                    if ((s32) temp_v1_3 < temp_v0_4) {
                        phi_v0_3 = (s16) (temp_v0_4 - temp_v1_3);
                    }
                    shell->rotAngle = phi_v0_3;
                } else if (temp_v0_3 >= 5) {
                    shell->state = 5;
                    shell->shellId = 1000.0f;
                    temp_v1_4 = D_80164430;
                    temp_v0_5 = *(&D_80164438 + (((s32) (temp_s1_3 - gPlayerOne) / 3544) * 2)) + 8;
                    phi_v0_4 = temp_v0_5;
                    if ((s32) temp_v1_4 < temp_v0_5) {
                        phi_v0_4 = (s16) (temp_v0_5 - temp_v1_4);
                    }
                    shell->rotAngle = phi_v0_4;
                    shell->parentIndex = (&gPlayerPositionLUT)[temp_s1_3->currentRank].unk-2;
                } else {
                    shell->state = 3;
                    shell->shellId = 1000.0f;
                    shell->parentIndex = (&gPlayerPositionLUT)[temp_s1_3->currentRank].unk-2;
                }
            }
        }
        shell->velocity[1] = (f32) ((f64) shell->velocity[1] - 0.5);
        if (shell->velocity[1] < -2.0f) {
            shell->velocity[1] = -2.0f;
        }
        sp38 = shell->pos[0];
        sp3C = shell->pos[1];
        sp40 = shell->pos[2];
        shell->pos[0] += shell->velocity[0];
        shell->pos[1] += shell->velocity[1];
        shell->pos[2] += shell->velocity[2];
        func_802AD950(&shell->unk30, 4.0f, shell->pos[0], shell->pos[1], shell->pos[2], sp38, sp3C, sp40);
        func_802B4E30((struct Actor *) shell);
        func_802B4104(shell);
        return;
    case 3:
        func_802B3E7C(shell, &gPlayers[shell->parentIndex]);
        return;
    case 4:
        func_802B3B44(shell);
        temp_v0_6 = shell->parentIndex;
        if (temp_v0_6 == 0) {
            if ((shell->flags & 0xF) == 0) {
                func_8029FDC8((struct Actor *) shell);
                return;
            }
            shell->parentIndex = temp_v0_6 - 1;
            return;
        }
        break;
    case 5:
        func_802B3B44(shell);
        temp_s1_4 = &gPlayers[shell->parentIndex];
        temp_f0_3 = temp_s1_4->pos[0] - shell->pos[0];
        temp_f2_4 = temp_s1_4->pos[2] - shell->pos[2];
        if (((temp_f0_3 * temp_f0_3) + (temp_f2_4 * temp_f2_4)) < D_802B9F98) {
            shell->state = 3;
            return;
        }
        break;
    case 6:
        temp_v0_7 = &gActorList[shell->parentIndex];
        temp_s1_5 = &gPlayers[shell->playerId];
        if (temp_v0_7->type != 0x0016) {
            func_8029FDC8((struct Actor *) shell);
            return;
        }
        temp_t6 = shell->rotAngle + temp_v0_7->rotVelocity;
        shell->rotAngle = temp_t6;
        sp8C = sins(temp_t6 & 0xFFFF) * 8.0f;
        sp90 = shell->boundingBoxSize - temp_s1_5->boundingBoxSize;
        sp94 = coss((u16) shell->rotAngle) * 8.0f;
        func_802B63B8(&sp8C, temp_s1_5->unk_174);
        sp38 = shell->pos[0];
        sp3C = shell->pos[1];
        sp40 = shell->pos[2];
        shell->pos[0] = sp8C + temp_s1_5->pos[0];
        shell->pos[1] = sp90 + temp_s1_5->pos[1];
        shell->pos[2] = sp94 + temp_s1_5->pos[2];
        func_802AD950(&shell->unk30, 4.0f, shell->pos[0], shell->pos[1], shell->pos[2], sp38, sp3C, sp40);
        func_802B4E30((struct Actor *) shell);
        return;
    case 7:
        shell->velocity[1] -= D_802B9F9C;
        if (shell->velocity[1] < -5.0f) {
            shell->velocity[1] = -5.0f;
        }
        shell->parentIndex += -1;
        shell->rotAngle += 0x5B0;
        shell->pos[1] += shell->velocity[1];
        if (shell->parentIndex == 0) {
            destroy_actor((struct Actor *) shell);
            return;
        }
        break;
    case 8:
        func_802B3B44(shell);
        shell->parentIndex = gPlayerPositionLUT;
        temp_s1_6 = &gPlayers[gPlayerPositionLUT];
        temp_f0_4 = temp_s1_6->pos[0] - shell->pos[0];
        temp_f2_5 = temp_s1_6->pos[2] - shell->pos[2];
        if (((temp_f0_4 * temp_f0_4) + (temp_f2_5 * temp_f2_5)) < D_802B9FA0) {
            shell->state = 9;
            return;
        }
        break;
    case 9:
        func_802B3E7C(shell, &gPlayers[shell->parentIndex]);
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_red_blue_shell.s")
#endif

void func_802B4E30(struct Actor *arg0) {
    if ((arg0->unk30.unk44 < 0.0f) && (arg0->unk30.unk34 == 1)) {
        arg0->pos[0] -= (arg0->unk30.unk60[0] * arg0->unk30.unk44);
        arg0->pos[1] -= (arg0->unk30.unk60[1] * arg0->unk30.unk44);
        arg0->pos[2] -= (arg0->unk30.unk60[2] * arg0->unk30.unk44);
    }
    if ((arg0->unk30.unk3C < 0.0f) && (arg0->unk30.unk30 == 1)) {
        arg0->pos[0] -= (arg0->unk30.unk48[0] * arg0->unk30.unk3C);
        arg0->pos[1] -= (arg0->unk30.unk48[1] * arg0->unk30.unk3C);
        arg0->pos[2] -= (arg0->unk30.unk48[2] * arg0->unk30.unk3C);
    }
    if ((arg0->unk30.unk40 < 0.0f) && (arg0->unk30.unk32 == 1)) {
        arg0->pos[0] -= (arg0->unk30.unk54[0] * arg0->unk30.unk40);
        arg0->pos[1] -= (arg0->unk30.unk54[1] * arg0->unk30.unk40);
        arg0->pos[2] -= (arg0->unk30.unk54[2] * arg0->unk30.unk40);
    }
}
