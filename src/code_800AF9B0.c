#include <ultra64.h>
#include <macros.h>
#include <defines.h>
#include "global.h"

#include "code_800AF9B0.h"

#include "code_80091750.h"
#include "memory.h"
#include "main.h"

void func_800AF9B0(void) {
    D_8018EDB8 = func_802A7B70(7680);
    D_8018EDBC = func_802A7B70(7680);
}

#define SQ(x) ((x) * (x))
#define WEIRD_TO_VIRTUAL(x) ((void *)((uintptr_t)(x) + 0x80000000))

// could be a normal vertex, not a color...
void func_800AF9E4(Vtx *arg0, s32 arg1, s32 arg2, s32 arg3, s16 arg4, s16 arg5, s32 arg6, s32 arg7) {
    s32 r, g, b;
    s32 i;

    for (i = 0; i < 4; i++) {
        (arg0 + i)->v.ob[0] = ((i % 2) * arg7) + arg6 - 504;
        if (i / 2 == 0) {
            (arg0 + i)->v.ob[1] = (arg2 * arg3) - 420;
        } else {
            (arg0 + i)->v.ob[1] = (arg2 * arg3) + arg3 - 420;
        }
        if (i % 2 == 0) {
            (arg0 + i)->v.ob[1] += (f32)SQ(arg1) * -0.07f;
        } else {
            (arg0 + i)->v.ob[1] += (f32)SQ(arg1 + 1) * -0.07f;
        }

        (arg0 + i)->v.cn[0] = 0;
        (arg0 + i)->v.cn[1] = 0;
        (arg0 + i)->v.cn[2] = 120;
        (arg0 + i)->v.cn[3] = 255;

        if (i % 2 == 0) {
            (arg0 + i)->v.ob[2] = arg4;
        } else {
            (arg0 + i)->v.ob[2] = arg5;
        }
    }

    if ((((arg1 / 2) + (arg2 / 2)) & 1) == 0) {
        r = g = b = 0;
    } else {
        r = g = b = 255;
    }

    gDPSetPrimColor(gDisplayListHead++, 0, 0, r, g, b, 255);
    gDPPipeSync(gDisplayListHead++);
    gSPVertex(gDisplayListHead++, WEIRD_TO_VIRTUAL(arg0), 4, 0);
    gSP1Triangle(gDisplayListHead++, 1, 2, 0, 0);
    gSP1Triangle(gDisplayListHead++, 3, 2, 1, 0);
}

void func_800AFC54(Vtx *arg0, s32 arg1, s32 arg2, s32 arg3, s16 arg4[3]);
#ifdef NON_MATCHING
// guess on Vtx type?
void func_800AFC54(Vtx *arg0, s32 arg1, s32 arg2, s32 arg3, s16 arg4[3]) {
    Vtx *a1, *a2, *a3;
    s32 saved1, saved2, saved3;
    f32 res;
    s32 a, b, c, d, e, f;
    f32 f14, f16, f18;

    a1 = &arg0[arg1];
    a2 = &arg0[arg2];
    a3 = &arg0[arg3];   

    saved1 = a2->v.ob[0];
    saved2 = a2->v.ob[1];
    saved3 = a2->v.ob[2];


    a = saved2 - a1->v.ob[1];
    e = saved3 - a1->v.ob[2];
    d = a3->v.ob[1] - saved2;
    b = a3->v.ob[2] - saved3;
    f = a3->v.ob[0] - saved1;
    c = saved1 - a1->v.ob[0];


    f14 = ((a) * (b)) - ((e) * (d));
    f16 = ((e) * (f)) - ((c) * (b));
    f18 = ((c) * (d)) - ((a) * (f));


    res = sqrtf(SQ(f14) + SQ(f16) + SQ(f18));

    if (res < 0.001) {
        res = 0.001;
    }

    arg4[0] = f14 * (f32)(1.0 / res) * 120.0f;
    arg4[1] = f16 * (f32)(1.0 / res) * 120.0f;
    arg4[2] = f18 * (f32)(1.0 / res) * 120.0f;
}
#else
GLOBAL_ASM("asm/non_matchings/code_800AF9B0/func_800AFC54.s")
#endif

void func_800AFE00(Vtx *arg0, s16 (*arg1)[3], s32 arg2, s32 arg3);
#ifdef MIPS_TO_C
// guessing on the Vtx kind again
void func_800AFE00(Vtx *arg0, s16 (*arg1)[3], s32 arg2, s32 arg3) {
    s32 idx1; // v0
    s32 idx2; // v0
    s16 sp14[6];
    Vtx *sec, *third, *fourth;
    s32 i;

    if (arg2 == 0) {
        idx1 = 0;
    } else {
        idx1 = arg2 - 1;
    }

    if (arg2 == arg3) {
        idx2 = arg3;
    } else {
        idx2 = arg2 + 1;
    }

    for (i = 0; i < 3; i++) {
        sp14[i + 0] = (arg1[arg2][i] + arg1[idx1][i]) / 2;
        sp14[i + 3] = (arg1[arg2][i] + arg1[idx2][i]) / 2;
        // L800AFEB4
    }


    i = 0;
    sec = arg0 + 1;
    third = arg0 + 2;
    fourth = arg0 + 3;
    
    while (i != 480) {
        (arg0 + i)->v.cn[0] = sp14[0];
        (arg0 + i)->v.cn[1] = sp14[1];
        (arg0 + i)->v.cn[2] = sp14[2];
        (sec + i)->v.cn[0] = sp14[3];
        (sec + i)->v.cn[1] = sp14[4];
        (sec + i)->v.cn[2] = sp14[5];
        (third + i)->v.cn[0] = sp14[0];
        (third + i)->v.cn[1] = sp14[1];
        (third + i)->v.cn[2] = sp14[2];
        (fourth + i)->v.cn[0] = sp14[3];
        (fourth + i)->v.cn[1] = sp14[4];
        (fourth + i)->v.cn[2] = sp14[5];

        i += 3 * sizeof(Vtx);
        i++;i--;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_800AF9B0/func_800AFE00.s")
#endif

void func_800AFF58(Vtx *arg0) {
    UNUSED u32 pad88[26];
    s32 i, j;
    s16 sp40[12][3];
    
    for (i = 0, j = 0; i < ARRAY_COUNT(sp40); i++, j += 4) {
        func_800AFC54(&arg0[j], 1, 2, 0, sp40[i]);
    }

    for (i = 0, j = 0; i < ARRAY_COUNT(sp40); i++, j += 4) {
        func_800AFE00(&arg0[j], sp40, i, 11);
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800AF9E4(s32, s32, s32, ?, s32, s32, s32, s32); // extern
? func_800AFF58(s32); // extern
f32 sins(s32); // extern
extern ? D_800E8680;
extern ? D_800E8688;
extern f32 D_800F2B44;
extern s16 D_8018EDB0;
extern s16 D_8018EDB2;
extern s16 D_8018EDB4;
extern s32 D_8018EDB8;
extern s32 D_8018EDBC;
extern void *gDisplayListHead;

void func_800B0004(void) {
    s32 spBC;
    s32 sp64;
    f32 temp_f22;
    s32 temp_fp;
    s32 temp_s1;
    s32 temp_s4;
    void *temp_a0;
    void *temp_a1;
    void *temp_a2;
    void *temp_a3;
    void *temp_t0;
    void *temp_t1;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    s32 phi_s0;
    s32 phi_s3;
    s32 phi_fp;
    s32 phi_s2;

    temp_a0 = gDisplayListHead;
    gDisplayListHead = temp_a0 + 8;
    temp_a0->unk0 = 0x3860010;
    temp_a0->unk4 = &D_800E8688 - 0x80000000;
    temp_a1 = gDisplayListHead;
    gDisplayListHead = temp_a1 + 8;
    temp_a1->unk0 = 0x3880010;
    temp_a1->unk4 = &D_800E8680 - 0x80000000;
    temp_a2 = gDisplayListHead;
    gDisplayListHead = temp_a2 + 8;
    temp_a2->unk4 = 0x80000040;
    temp_a2->unk0 = 0xBC000002;
    temp_a3 = gDisplayListHead;
    gDisplayListHead = temp_a3 + 8;
    temp_a3->unk4 = 0x204;
    temp_a3->unk0 = 0xB7000000;
    temp_t0 = gDisplayListHead;
    gDisplayListHead = temp_t0 + 8;
    temp_t0->unk4 = -0x604;
    temp_t0->unk0 = 0xFC327E64;
    temp_t1 = gDisplayListHead;
    gDisplayListHead = temp_t1 + 8;
    temp_t1->unk4 = 0x2000;
    temp_t1->unk0 = 0xB6000000;
    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk4 = 0x20000;
    temp_v0->unk0 = 0xB7000000;
    if ((D_8018EDB4 % 2) != 0) {
        spBC = D_8018EDB8;
    } else {
        spBC = D_8018EDBC;
    }
    D_8018EDB2 = 0x9C0;
    temp_f22 = D_800F2B44;
    sp64 = 0;
    phi_fp = 0;
    do {
        phi_s0 = 0;
        phi_s3 = 0;
        phi_s2 = 0;
loop_5:
        temp_s1 = phi_s0 + 1;
        temp_s4 = sins((D_8018EDB0 - (phi_s0 * D_8018EDB2)) & 0xFFFF) * 84.0f * phi_s0 * temp_f22;
        func_800AF9E4((phi_s3 * 0x10) + spBC + (sp64 * 0x10), phi_s0, phi_fp, 0x54, temp_s4, sins((D_8018EDB0 - (temp_s1 * D_8018EDB2)) & 0xFFFF) * 84.0f * temp_s1 * temp_f22, phi_s2, 0x54);
        phi_s0 = temp_s1;
        phi_s3 += 4;
        phi_s2 += 0x54;
        if (temp_s1 != 0xC) {
            goto loop_5;
        }
        temp_fp = phi_fp + 1;
        sp64 += 0x30;
        phi_fp = temp_fp;
    } while (temp_fp != 0xA);
    func_800AFF58(spBC);
    D_8018EDB0 = D_8018EDB0 + D_8018EDB2;
    D_8018EDB4 = D_8018EDB4 + 1;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xB7000000;
    temp_v0_2->unk4 = 0x2000;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = 0x80000040;
    temp_v0_3->unk0 = 0xBC000002;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = 0x20000;
    temp_v0_4->unk0 = 0xB6000000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_800AF9B0/func_800B0004.s")
#endif


