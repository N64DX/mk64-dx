#include <ultra64.h>
#include <macros.h>

#include "audio/port_eu.h"
#include "audio/load.h"

OSMesgQueue D_801937C0;
OSMesgQueue D_801937D8;
OSMesgQueue D_801937F0;
OSMesgQueue D_80193808;

struct EuAudioCmd D_80193820[0x100];

// Seems oversized by 1
OSMesg D_80194020[2];
OSMesg D_80194028[4];
OSMesg D_80194038[1];
OSMesg D_8019403C[1];

u8 D_800EA3A0[] = { 0, 0, 0, 0 };

u8 D_800EA3A4[] = { 0, 0, 0, 0 };

OSMesgQueue *D_800EA3A8 = &D_801937C0;
OSMesgQueue *D_800EA3AC = &D_801937D8;
OSMesgQueue *D_800EA3B0 = &D_801937F0;
OSMesgQueue *D_800EA3B4 = &D_80193808;

char port_eu_unused_string0[] = "DAC:Lost 1 Frame.\n";
char port_eu_unused_string1[] = "DMA: Request queue over.( %d )\n";
char port_eu_unused_string2[] = "DMA [ %d lines] TIMEOUT\n";
char port_eu_unused_string3[] = "Warning: WaveDmaQ contains %d msgs.\n";
char port_eu_unused_string4[] = "Audio:now-max tasklen is %d / %d\n";
char port_eu_unused_string5[] = "Audio:Warning:ABI Tasklist length over (%d)\n";

s32 D_800EA484 = 128;

char port_eu_unused_string6[] = "AudioSend: %d -> %d (%d)\n";

s32 D_800EA4A4 = 0;

char port_eu_unused_string7[] = "Undefined Port Command %d\n";

#ifdef MIPS_TO_C
//generated by m2c commit eefca95b040d7ee0c617bc58f9ac6cd1cf7bce87 on Aug-14-2023
s32 func_800B70EC(s32, s32 *, s32, s16);            /* extern */
s32 func_800BA00C();                                /* extern */
? func_800CBCB0(void *);                            /* extern */
extern u8 D_803B0500;
extern u8 D_803B0501;
extern s32 D_803B70B8;
extern s32 D_803B70C0;
extern s32 D_803B70C4;
extern ? D_803B70C8;
extern s32 D_803B70D0;
extern void *D_803B70D4;
extern ? D_803B70D8;
extern ? D_803B7180;
extern ? D_803B718C;
extern ? aspMainDataEnd;
extern ? aspMainDataStart;
extern ? aspMainTextStart;
extern OSMesgQueue gCurrAudioFrameDmaQueue;

void *create_next_audio_frame_task(void) {
    u32 sp74;
    s32 sp70;
    s32 sp60;
    void *sp58;
    void *sp54;
    s32 *sp40;
    s16 *temp_s1_2;
    s16 temp_v1;
    s32 *temp_a3;
    s32 temp_hi;
    s32 temp_hi_2;
    s32 temp_s1;
    s32 temp_t3;
    s32 var_s0;
    s32 var_s0_2;
    s32 var_s0_3;
    s32 var_s1;

    D_803B70B8 += 1;
    if (((s32) D_803B70B8 % (s16) gAudioBufferParameters.presetUnk4) != 0) {
        return NULL;
    }
    osSendMesg(D_800EA3A8, (void *) D_803B70B8, 0);
    temp_t3 = D_803B70C4 + 1;
    temp_hi = temp_t3 % 3;
    temp_hi_2 = (s32) (temp_hi + 1) % 3;
    D_803B70C4 = temp_t3;
    D_803B70C0 ^= 1;
    D_803B70C4 = temp_hi;
    sp74 = osAiGetLength() >> 2;
    temp_v1 = *(&D_803B718C + (temp_hi_2 * 2));
    if (temp_v1 != 0) {
        osAiSetNextBuffer(*(&D_803B7180 + (temp_hi_2 * 4)), temp_v1 * 4);
    }
    var_s1 = gCurrAudioFrameDmaCount;
    var_s0 = 0;
    if (var_s1 > 0) {
        do {
            if (osRecvMesg(&gCurrAudioFrameDmaQueue, NULL, 0) == 0) {
                var_s1 -= 1;
            }
            var_s0 += 1;
        } while (var_s0 < gCurrAudioFrameDmaCount);
    }
    if (var_s1 != 0) {
        var_s0_2 = 0;
        if (var_s1 > 0) {
            do {
                osRecvMesg(&gCurrAudioFrameDmaQueue, NULL, 1);
                var_s0_2 += 1;
            } while (var_s0_2 != var_s1);
        }
    }
    temp_s1 = gCurrAudioFrameDmaQueue.validCount;
    if (temp_s1 != 0) {
        var_s0_3 = 0;
        if (temp_s1 > 0) {
            do {
                osRecvMesg(&gCurrAudioFrameDmaQueue, NULL, 0);
                var_s0_3 += 1;
            } while (var_s0_3 != temp_s1);
        }
    }
    gCurrAudioFrameDmaCount = 0;
    decrease_sample_dma_ttls();
    if (osRecvMesg(D_800EA3B0, &sp58, 0) != -1) {
        D_803B0501 = (u8) sp58;
        D_803B0500 = 5;
    }
    if ((D_803B0500 != 0) && (func_800BA00C() == 0)) {
        if (D_803B0500 == 0) {
            osSendMesg(D_800EA3B4, (void *) D_803B0501, 0);
        }
        return NULL;
    }
    D_803B70D4 = (D_803B70C0 * 0x50) + &D_803B70D8;
    temp_a3 = (D_803B70C4 * 4) + &D_803B7180;
    D_803B70D0 = *(&D_803B70C8 + (D_803B70C0 * 4));
    sp60 = *temp_a3;
    temp_s1_2 = (D_803B70C4 * 2) + &D_803B718C;
    *temp_s1_2 = (((gAudioBufferParameters.samplesPerFrameTarget - sp74) + 0x40) & 0xFFF0) + 0x10;
    if (*temp_s1_2 < gAudioBufferParameters.minAiBufferLength) {
        *temp_s1_2 = gAudioBufferParameters.minAiBufferLength;
    }
    if (gAudioBufferParameters.maxAiBufferLength < *temp_s1_2) {
        *temp_s1_2 = gAudioBufferParameters.maxAiBufferLength;
    }
    sp40 = temp_a3;
    if (osRecvMesg(D_800EA3AC, &sp54, 0) != -1) {
        func_800CBCB0(sp54);
    }
    D_803B70D0 = func_800B70EC(D_803B70D0, &sp70, sp60, *temp_s1_2);
    gAudioRandom = osGetCount() * (gAudioRandom + D_803B70B8);
    gAudioRandom += *(*sp40 + ((D_803B70B8 & 0xFF) * 2));
    D_803B70D4->unk40 = 0;
    D_803B70D4->unk44 = 0;
    D_803B70D4->unk0 = 2;
    D_803B70D4->unk4 = 0;
    D_803B70D4->unk8 = rspbootTextStart;
    D_803B70D4->unkC = (s32) (rspbootTextEnd - rspbootTextStart);
    D_803B70D4->unk10 = &aspMainTextStart;
    D_803B70D4->unk18 = &aspMainDataStart;
    D_803B70D4->unk14 = 0x00001000;
    D_803B70D4->unk1C = (s32) (((s32) (&aspMainDataEnd - &aspMainDataStart) >> 3) * 8);
    D_803B70D4->unk20 = 0;
    D_803B70D4->unk24 = 0;
    D_803B70D4->unk28 = 0;
    D_803B70D4->unk2C = 0;
    D_803B70D4->unk30 = (s32) *(&D_803B70C8 + (D_803B70C0 * 4));
    D_803B70D4->unk38 = 0;
    D_803B70D4->unk3C = 0;
    D_803B70D4->unk34 = (s32) (sp70 * 8);
    if (D_800EA484 < sp70) {
        D_800EA484 = sp70;
    }
    return D_803B70D4;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/port_eu/create_next_audio_frame_task.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit eefca95b040d7ee0c617bc58f9ac6cd1cf7bce87 on Aug-14-2023
? func_800BBDDC(u8, ?);                             /* extern */
extern u8 D_803B1658;
extern u8 D_803B17A0;
extern u8 D_803B18E8;

void func_800CB818(void *arg0) {
    s32 temp_a1;
    struct SequencePlayer *temp_a0;
    u8 temp_v0;
    u8 temp_v0_2;

    temp_v0 = arg0->unk0;
    switch (temp_v0) {                              /* irregular */
    case 0x81:
        func_800BBDDC(arg0->unk2, 3);
        return;
    case 0x82:
    case 0x88:
        func_800BBEF0((u32) arg0->unk1, (u32) arg0->unk2, (s32) arg0->unk3);
        func_800CBA64((s32) arg0->unk1, arg0->unk4);
        return;
    case 0x83:
        temp_v0_2 = arg0->unk1;
        temp_a0 = &gSequencePlayers[temp_v0_2];
        if (((u32) *temp_a0 >> 0x1F) != 0) {
            temp_a1 = arg0->unk4;
            if (temp_a1 == 0) {
                sequence_player_disable(temp_a0);
                return;
            }
            seq_player_fade_to_zero_volume((s32) temp_v0_2, temp_a1);
            return;
        }
        return;
    case 0xF0:
        gAudioLibSoundMode = (s8) arg0->unk4;
        return;
    case 0xF1:
        *gSequencePlayers |= 0x24;
        D_803B1658 |= 0x24;
        D_803B17A0 |= 0x24;
        D_803B18E8 |= 0x24;
        return;
    case 0xF2:
        *gSequencePlayers = (*gSequencePlayers & 0xFFDF) | 4;
        D_803B1658 = (D_803B1658 & 0xFFDF) | 4;
        D_803B17A0 = (D_803B17A0 & 0xFFDF) | 4;
        D_803B18E8 = (D_803B18E8 & 0xFFDF) | 4;
        return;
    case 0xF3:
        func_800BB388((s32) arg0->unk1, (s32) arg0->unk2, (s32) arg0->unk3);
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/port_eu/func_800CB818.s")
#endif

void seq_player_fade_to_zero_volume(s32 arg0, s32 fadeOutTime) {
    struct SequencePlayer *player;

    if (fadeOutTime == 0) {
        fadeOutTime = 1;
    }
    player = &gSequencePlayers[arg0];
    player->state = 2;
    player->fadeRemainingFrames = fadeOutTime;
    player->fadeVelocity = -(player->fadeVolume / fadeOutTime);
}

void func_800CBA64(s32 playerIndex, s32 fadeInTime) {
    struct SequencePlayer *player;

    if (fadeInTime != 0) {
        player = &gSequencePlayers[playerIndex];
        player->state = 1;
        player->fadeTimerUnkEu = fadeInTime;
        player->fadeRemainingFrames = fadeInTime;
        player->fadeVolume = 0.0f;
        player->fadeVelocity = 0.0f;
    }
}

void func_800CBAB4(void) {
    D_800EA3A0[0] = 0;
    D_800EA3A4[0] = 0;
    osCreateMesgQueue(D_800EA3A8, D_80194020, 1);
    osCreateMesgQueue(D_800EA3AC, D_80194028, 4);
    osCreateMesgQueue(D_800EA3B0, D_80194038, 1);
    osCreateMesgQueue(D_800EA3B4, D_8019403C, 1);
}

void func_800CBB48(s32 arg0, s32 *arg1) {
  struct EuAudioCmd *cmd = &D_80193820[D_800EA3A0[0] & 0xff];
  cmd->u.first = arg0;
  cmd->u2.as_u32 = *arg1;
  D_800EA3A0[0]++;
}

void func_800CBB88(u32 arg0, f32 arg1) {
    func_800CBB48(arg0, (s32*) &arg1);
}

void func_800CBBB8(u32 arg0, s32 arg1) {
    func_800CBB48(arg0, &arg1);
}

void func_800CBBE8(u32 arg0, s8 arg1) {
    s32 sp34 = arg1 << 24;
    func_800CBB48(arg0, &sp34);
}

extern OSMesgQueue* D_800EA3AC[];

extern static s32 D_800EA4A4;
void func_800CBC24(void) 
{
    OSMesg *tmp;

    if (D_800EA4A4 < (((D_800EA3A0 - D_800EA3A4) + 0x100) & 0xFF)) 
    {
        D_800EA4A4 = (((D_800EA3A0 - D_800EA3A4) + 0x100) & 0xFF);
    }
    tmp = ((D_800EA3A4 & 0xFF) << 8) | (D_800EA3A0 & 0xFF);
    
    osSendMesg(*D_800EA3AC, tmp, 0);
    
    D_800EA3A4 = D_800EA3A0;
}


#ifdef MIPS_TO_C
//generated by m2c commit eefca95b040d7ee0c617bc58f9ac6cd1cf7bce87 on Aug-14-2023
? func_800CB818(struct EuAudioCmd *);               /* extern */

void func_800CBCB0(u32 arg0) {
    s32 temp_t8;
    s32 var_s1;
    s32 var_v0;
    struct EuAudioCmd *temp_s0;
    struct SequenceChannel *temp_v0_2;
    struct SequencePlayer *temp_v1;
    u8 temp_a0;
    u8 temp_a1;
    u8 temp_v0;
    u8 temp_v1_2;

    temp_t8 = arg0 & 0xFF;
    var_s1 = (arg0 >> 8) & 0xFF;
    var_v0 = var_s1;
    if (temp_t8 != var_s1) {
        do {
            temp_s0 = &D_80193820[var_v0 & 0xFF];
            temp_a0 = temp_s0->u.s.arg3;
            var_s1 = (var_s1 + 1) & 0xFF;
            if ((temp_a0 & 0xF0) == 0xF0) {
                func_800CB818(temp_s0);
            } else {
                temp_v0 = temp_s0->u.s.arg2;
                if ((s32) temp_v0 < 4) {
                    temp_v1 = &gSequencePlayers[temp_v0];
                    if (temp_a0 & 0x80) {
                        func_800CB818(temp_s0);
                    } else if (temp_a0 & 0x40) {
                        switch (temp_a0) {          /* switch 1; irregular */
                        case 0x41:                  /* switch 1 */
                            temp_v1->unk0 = (u8) (temp_v1->unk0 | 4);
                            temp_v1->fadeVolumeScale = (bitwise f32) temp_s0->u2.as_s32;
                            break;
                        case 0x47:                  /* switch 1 */
                            temp_v1->tempo = temp_s0->u2.as_s32 * 0x30;
                            break;
                        case 0x48:                  /* switch 1 */
                            temp_v1->transposition = (s16) (s8) temp_s0->u2.pad0[0];
                            break;
                        case 0x46:                  /* switch 1 */
                            temp_v1->seqVariationEu[temp_s0->u.s.op] = (s8) temp_s0->u2.pad0[0];
                            break;
                        }
                    } else if (((u32) temp_v1->unk0 >> 0x1F) != 0) {
                        temp_a1 = temp_s0->u.s.arg1;
                        if ((s32) temp_a1 < 0x10) {
                            temp_v0_2 = temp_v1->channels[temp_a1];
                            if (temp_v0_2 != &gSequenceChannelNone) {
                                switch (temp_a0) {
                                case 1:
                                    temp_v0_2->changes.as_u8 |= 0x40;
                                    temp_v0_2->volumeScale = (bitwise f32) temp_s0->u2.as_s32;
                                    break;
                                case 2:
                                    temp_v0_2->changes.as_u8 |= 0x40;
                                    temp_v0_2->volume = (bitwise f32) temp_s0->u2.as_s32;
                                    break;
                                case 3:
                                    temp_v0_2->changes.as_u8 |= 0x20;
                                    temp_v0_2->newPan = (u8) (s8) temp_s0->u2.pad0[0];
                                    break;
                                case 4:
                                    temp_v0_2->changes.as_u8 |= 0x80;
                                    temp_v0_2->freqScale = (bitwise f32) temp_s0->u2.as_s32;
                                    break;
                                case 5:
                                    temp_v0_2->reverbVol = (u8) (s8) temp_s0->u2.pad0[0];
                                    break;
                                case 6:
                                    temp_v1_2 = temp_s0->u.s.op;
                                    if ((s32) temp_v1_2 < 8) {
                                        temp_v0_2->soundScriptIO[temp_v1_2] = (s8) temp_s0->u2.pad0[0];
                                    }
                                    break;
                                case 8:
                                    temp_v0_2->unk0 = (u8) ((((s8) temp_s0->u2.pad0[0] * 0x10) & 0x10) | (temp_v0_2->unk0 & 0xFFEF));
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            var_v0 = var_s1;
            temp_s0->u.s.arg3 = 0;
        } while (temp_t8 != var_s1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/port_eu/func_800CBCB0.s")
#endif

void func_800CBF48() {
    func_800CBAB4();
}
