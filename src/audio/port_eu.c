#include <ultra64.h>
#include <macros.h>

#include "audio/seqplayer.h"
#include "audio/port_eu.h"
#include "audio/load.h"

OSMesgQueue D_801937C0;
OSMesgQueue D_801937D8;
OSMesgQueue D_801937F0;
OSMesgQueue D_80193808;

struct EuAudioCmd sAudioCmd[0x100];

// Seems oversized by 1
OSMesg D_80194020[2];
OSMesg D_80194028[4];
OSMesg D_80194038[1];
OSMesg D_8019403C[1];

u8 D_800EA3A0[] = { 0, 0, 0, 0 };

u8 D_800EA3A4[] = { 0, 0, 0, 0 };

OSMesgQueue *D_800EA3A8 = &D_801937C0;
OSMesgQueue *D_800EA3AC = &D_801937D8;
OSMesgQueue *D_800EA3B0 = &D_801937F0;
OSMesgQueue *D_800EA3B4 = &D_80193808;

char port_eu_unused_string0[] = "DAC:Lost 1 Frame.\n";
char port_eu_unused_string1[] = "DMA: Request queue over.( %d )\n";
char port_eu_unused_string2[] = "DMA [ %d lines] TIMEOUT\n";
char port_eu_unused_string3[] = "Warning: WaveDmaQ contains %d msgs.\n";
char port_eu_unused_string4[] = "Audio:now-max tasklen is %d / %d\n";
char port_eu_unused_string5[] = "Audio:Warning:ABI Tasklist length over (%d)\n";

s32 D_800EA484 = 128;

char port_eu_unused_string6[] = "AudioSend: %d -> %d (%d)\n";

s32 D_800EA4A4 = 0;

char port_eu_unused_string7[] = "Undefined Port Command %d\n";

#ifdef MIPS_TO_C
//generated by m2c commit 08138748803d75e73e4a94bb0c619a273754ee9c on Sep-14-2023
u64 *func_800B70EC(u64 *, s32 *, s16 *, s16);       /* extern */
extern ? aspMainDataEnd;
extern u64 aspMainDataStart;
extern u64 aspMainTextStart;

struct SPTask *create_next_audio_frame_task(void) {
    u32 sp74;
    s32 sp70;
    s16 *sp60;
    void *sp58;
    void *sp54;
    s16 **sp40;
    s16 **temp_a3;
    s16 *temp_s1_2;
    s16 temp_v1;
    s32 temp_hi;
    s32 temp_hi_2;
    s32 temp_s1;
    s32 temp_t3;
    s32 var_s0;
    s32 var_s0_2;
    s32 var_s0_3;
    s32 var_s1;

    gAudioUpdatesPerFrame += 1;
    if (((s32) gAudioUpdatesPerFrame % (s16) gAudioBufferParameters.presetUnk4) != 0) {
        return NULL;
    }
    osSendMesg(D_800EA3A8, (void *) gAudioUpdatesPerFrame, 0);
    temp_t3 = gCurrAiBufferIndex + 1;
    temp_hi = temp_t3 % 3;
    temp_hi_2 = (s32) (temp_hi + 1) % 3;
    gCurrAiBufferIndex = temp_t3;
    gAudioTaskIndex ^= 1;
    gCurrAiBufferIndex = temp_hi;
    sp74 = osAiGetLength() >> 2;
    temp_v1 = gAiBufferLengths[temp_hi_2];
    if (temp_v1 != 0) {
        osAiSetNextBuffer(gAiBuffers[temp_hi_2], temp_v1 * 4);
    }
    var_s1 = gCurrAudioFrameDmaCount;
    var_s0 = 0;
    if (var_s1 > 0) {
        do {
            if (osRecvMesg(&gCurrAudioFrameDmaQueue, NULL, 0) == 0) {
                var_s1 -= 1;
            }
            var_s0 += 1;
        } while (var_s0 < gCurrAudioFrameDmaCount);
    }
    if (var_s1 != 0) {
        var_s0_2 = 0;
        if (var_s1 > 0) {
            do {
                osRecvMesg(&gCurrAudioFrameDmaQueue, NULL, 1);
                var_s0_2 += 1;
            } while (var_s0_2 != var_s1);
        }
    }
    temp_s1 = gCurrAudioFrameDmaQueue.validCount;
    if (temp_s1 != 0) {
        var_s0_3 = 0;
        if (temp_s1 > 0) {
            do {
                osRecvMesg(&gCurrAudioFrameDmaQueue, NULL, 0);
                var_s0_3 += 1;
            } while (var_s0_3 != temp_s1);
        }
    }
    gCurrAudioFrameDmaCount = 0;
    decrease_sample_dma_ttls();
    if (osRecvMesg(D_800EA3B0, &sp58, 0) != -1) {
        gAudioResetPresetIdToLoad = (u8) sp58;
        gAudioResetStatus = 5;
    }
    if ((gAudioResetStatus != 0) && (audio_shut_down_and_reset_step() == 0)) {
        if (gAudioResetStatus == 0) {
            osSendMesg(D_800EA3B4, (void *) gAudioResetPresetIdToLoad, 0);
        }
        return NULL;
    }
    gAudioTask = &gAudioTasks[gAudioTaskIndex];
    temp_a3 = &gAiBuffers[gCurrAiBufferIndex];
    gAudioCmd = gAudioCmdBuffers[gAudioTaskIndex];
    sp60 = *temp_a3;
    temp_s1_2 = &gAiBufferLengths[gCurrAiBufferIndex];
    *temp_s1_2 = (((gAudioBufferParameters.samplesPerFrameTarget - sp74) + 0x40) & 0xFFF0) + 0x10;
    if (*temp_s1_2 < gAudioBufferParameters.minAiBufferLength) {
        *temp_s1_2 = gAudioBufferParameters.minAiBufferLength;
    }
    if (gAudioBufferParameters.maxAiBufferLength < *temp_s1_2) {
        *temp_s1_2 = gAudioBufferParameters.maxAiBufferLength;
    }
    sp40 = temp_a3;
    if (osRecvMesg(D_800EA3AC, &sp54, 0) != -1) {
        func_800CBCB0((u32) sp54);
    }
    gAudioCmd = func_800B70EC(gAudioCmd, &sp70, sp60, *temp_s1_2);
    gAudioRandom = osGetCount() * (gAudioRandom + gAudioUpdatesPerFrame);
    gAudioRandom += (*sp40)[gAudioUpdatesPerFrame & 0xFF];
    gAudioTask->msgqueue = NULL;
    gAudioTask->msg = NULL;
    gAudioTask->task.t.type = 2;
    gAudioTask->task.t.flags = 0;
    gAudioTask->task.t.ucode_boot = rspbootTextStart;
    gAudioTask->task.t.ucode_boot_size = rspbootTextEnd - rspbootTextStart;
    gAudioTask->task.t.ucode = &aspMainTextStart;
    gAudioTask->task.t.ucode_data = &aspMainDataStart;
    gAudioTask->task.t.ucode_size = 0x00001000;
    gAudioTask->task.t.ucode_data_size = ((s32) (&aspMainDataEnd - &aspMainDataStart) >> 3) * 8;
    gAudioTask->task.t.dram_stack = NULL;
    gAudioTask->task.t.dram_stack_size = 0;
    gAudioTask->task.t.output_buff = NULL;
    gAudioTask->task.t.output_buff_size = NULL;
    gAudioTask->task.t.data_ptr = gAudioCmdBuffers[gAudioTaskIndex];
    gAudioTask->task.t.yield_data_ptr = NULL;
    gAudioTask->task.t.yield_data_size = 0;
    gAudioTask->task.t.data_size = sp70 * 8;
    if (D_800EA484 < sp70) {
        D_800EA484 = sp70;
    }
    return gAudioTask;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/port_eu/create_next_audio_frame_task.s")
#endif

void eu_process_audio_cmd(struct EuAudioCmd *cmd) {
    s32 i;

    switch (cmd->u.s.op) {
        case 0x81:
            preload_sequence(cmd->u.s.arg2, 3);
            break;

        case 0x82:
        case 0x88:
            load_sequence(cmd->u.s.arg1, cmd->u.s.arg2, cmd->u.s.arg3);
            func_800CBA64(cmd->u.s.arg1, cmd->u2.as_s32);
            break;

        case 0x83:
            if (gSequencePlayers[cmd->u.s.arg1].enabled != FALSE) {
                if (cmd->u2.as_s32 == 0) {
                    sequence_player_disable(&gSequencePlayers[cmd->u.s.arg1]);
                }
                else {
                    seq_player_fade_to_zero_volume(cmd->u.s.arg1, cmd->u2.as_s32);
                }
            }
            break;

        case 0xf0:
            gAudioLibSoundMode = cmd->u2.as_s32;
            break;

        case 0xf1:
            for (i = 0; i < 4; i++) {
                gSequencePlayers[i].muted = TRUE;
                gSequencePlayers[i].recalculateVolume = TRUE;
            }
            break;

        case 0xf2:
            for (i = 0; i < 4; i++) {
                gSequencePlayers[i].muted = FALSE;
                gSequencePlayers[i].recalculateVolume = TRUE;
            }
            break;
    case 0xF3:
        func_800BB388(cmd->u.s.arg1, cmd->u.s.arg2, cmd->u.s.arg3);
        break;
    }
}

void seq_player_fade_to_zero_volume(s32 arg0, s32 fadeOutTime) {
    struct SequencePlayer *player;

    if (fadeOutTime == 0) {
        fadeOutTime = 1;
    }
    player = &gSequencePlayers[arg0];
    player->state = 2;
    player->fadeRemainingFrames = fadeOutTime;
    player->fadeVelocity = -(player->fadeVolume / fadeOutTime);
}

void func_800CBA64(s32 playerIndex, s32 fadeInTime) {
    struct SequencePlayer *player;

    if (fadeInTime != 0) {
        player = &gSequencePlayers[playerIndex];
        player->state = 1;
        player->fadeTimerUnkEu = fadeInTime;
        player->fadeRemainingFrames = fadeInTime;
        player->fadeVolume = 0.0f;
        player->fadeVelocity = 0.0f;
    }
}

void func_800CBAB4(void) {
    D_800EA3A0[0] = 0;
    D_800EA3A4[0] = 0;
    osCreateMesgQueue(D_800EA3A8, D_80194020, 1);
    osCreateMesgQueue(D_800EA3AC, D_80194028, 4);
    osCreateMesgQueue(D_800EA3B0, D_80194038, 1);
    osCreateMesgQueue(D_800EA3B4, D_8019403C, 1);
}

void func_800CBB48(s32 arg0, s32 *arg1) {
  struct EuAudioCmd *cmd = &sAudioCmd[D_800EA3A0[0] & 0xff];
  cmd->u.first = arg0;
  cmd->u2.as_u32 = *arg1;
  D_800EA3A0[0]++;
}

void func_800CBB88(u32 arg0, f32 arg1) {
    func_800CBB48(arg0, (s32*) &arg1);
}

void func_800CBBB8(u32 arg0, u32 arg1) {
    func_800CBB48(arg0, &arg1);
}

void func_800CBBE8(u32 arg0, s8 arg1) {
    s32 sp34 = arg1 << 24;
    func_800CBB48(arg0, &sp34);
}

// TODO: clenanup, something's weird with the variables. D_800EA4A4 is probably EuAudioCmd bc of the + 0x100
void func_800CBC24(void)
{
  s32 temp_t6;
  s32 test;
  OSMesg thing;
  temp_t6 = D_800EA3A0[0] - D_800EA3A4[0];
  test = (u8) temp_t6;
  test = (test + 0x100) & 0xFF;
  do
  {
  }
  while (0);
  if (D_800EA4A4 < test)
  {
    D_800EA4A4 = test;
  }
  thing = (OSMesg) ((D_800EA3A0[0] & 0xFF) | ((D_800EA3A4[0] & 0xFF) << 8));
  osSendMesg(D_800EA3AC, thing, 0);
  D_800EA3A4[0] = D_800EA3A0[0];
}

void func_800CBCB0(u32 arg0) {
    struct EuAudioCmd *cmd;
    struct SequencePlayer *seqPlayer;
    struct SequenceChannel *chan;
    u8 end = arg0 & 0xff;
    u8 i = (arg0 >> 8) & 0xff;

    for (;;) {
        if (i == end) break;
        cmd = &sAudioCmd[i++ & 0xff];

        if ((cmd->u.s.op & 0xf0) == 0xf0) {
            eu_process_audio_cmd(cmd);
            goto why;
        }

        if (cmd->u.s.arg1 < SEQUENCE_PLAYERS) {
            seqPlayer = &gSequencePlayers[cmd->u.s.arg1];
            if ((cmd->u.s.op & 0x80) != 0) {
                eu_process_audio_cmd(cmd);
            }
            else if ((cmd->u.s.op & 0x40) != 0) {
                switch (cmd->u.s.op) {
                    case 0x41:
                        seqPlayer->fadeVolumeScale = cmd->u2.as_f32;
                        seqPlayer->recalculateVolume = TRUE;
                        break;

                    case 0x47:
                        seqPlayer->tempo = cmd->u2.as_s32 * TATUMS_PER_BEAT;
                        break;

                    case 0x48:
                        seqPlayer->transposition = cmd->u2.as_s8;
                        break;

                    case 0x46:
                        seqPlayer->seqVariationEu[cmd->u.s.arg3] = cmd->u2.as_s8;
                        break;
                }
            }
            else if (seqPlayer->enabled != FALSE && cmd->u.s.arg2 < 0x10) {
                chan = seqPlayer->channels[cmd->u.s.arg2];
                if (IS_SEQUENCE_CHANNEL_VALID(chan)) {
                    switch (cmd->u.s.op) {
                        case 1:
                            chan->volumeScale = cmd->u2.as_f32;
                            chan->changes.as_bitfields.volume = TRUE;
                            break;
                        case 2:
                            chan->volume = cmd->u2.as_f32;
                            chan->changes.as_bitfields.volume = TRUE;
                            break;
                        case 3:
                            chan->newPan = cmd->u2.as_s8;
                            chan->changes.as_bitfields.pan = TRUE;
                            break;
                        case 4:
                            chan->freqScale = cmd->u2.as_f32;
                            chan->changes.as_bitfields.freqScale = TRUE;
                            break;
                        case 5:
                            chan->reverbVol = cmd->u2.as_s8;
                            break;
                        case 6:
                            if (cmd->u.s.arg3 < 8) {
                                chan->soundScriptIO[cmd->u.s.arg3] = cmd->u2.as_s8;
                            }
                            break;
                        case 8:
                            chan->stopSomething2 = cmd->u2.as_s8;
                    }
                }
            }
        }

        why:
        cmd->u.s.op = 0;
    }
}

void func_800CBF48() {
    func_800CBAB4();
}
