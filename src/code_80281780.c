#include <ultra64.h>
#include <macros.h>
#include "types.h"

extern void func_802A4D18();
extern void func_802A74BC();
extern void load_course();
extern void set_segment_base_addr();
extern int func_802AA88C();
extern void func_802AF5AC();
extern void func_80295C6C();
extern void func_80281780();
extern void func_802818BC();
extern void func_8003D080();
extern void func_8006E9C0();
extern void func_8001C05C();
extern void func_80280FB0();
extern void func_802816B8();
extern void func_80093E60();
extern void *gHeapEndPtr;

extern s16 gCurrentCourseId;
extern u16 D_800DC5B4;

extern s32 D_800DC604;
extern s32 D_800DC530;
extern s32 D_800DC52C;
extern s32 gModeSelection;
extern u16 D_800DC5BC;
extern u16 D_800DC5C8;
extern struct UnkStruct_800DC5EC *D_800DC5EC;

extern s32 D_80287550;
extern s32 D_80287554;
extern f32 D_801647A4;
extern f32 D_80150130;

extern s32 D_8015F728;
extern s32 D_8015F734;

extern s32 D_8015F730;

extern f32 D_8015F8E4;
extern s16 D_8015F6EA;
extern s16 D_8015F6EE;
extern s16 D_8015F6F2;
extern u16 D_8015F6E8;
extern u16 D_8015F6EC;
extern u16 D_8015F6F0;
extern s32 D_8015F59C;
extern s32 D_8015F5A0;
extern s32 D_8015F58C;
extern u16 D_8015F588;

extern s32 D_8015F580;

extern s32 _data_821D10SegmentRomStart;
extern s32 _data_825800SegmentRomStart;
extern s32 _course_banshee_boardwalk_dl_mio0SegmentRomStart;
extern s32 _course_yoshi_valley_dl_mio0SegmentRomStart;

extern s32 D_801625F8;
extern f32 D_801625FC;


// unk4 is buttonDown?
#ifdef MIPS_TO_C
//generated by mips_to_c commit 09d006c9da5d6bbcd31ac6ca5c9165c1a8533a83
void func_80281780(void) {
    if (gEnableDebugMode != 0) {
        if ((D_800DC4BC->unk4 & 0xF0F) != 0) {
            if ((D_800DC4BC->unk4 & 8) != 0) {
                D_800E86A8 = (u8)1;
            } else {
                if ((D_800DC4BC->unk4 & 2) != 0) {
                    D_800E86A8 = (u8)2;
                } else {
                    if ((D_800DC4BC->unk4 & 1) != 0) {
                        D_800E86A8 = (u8)3;
                    } else {
                        if ((D_800DC4BC->unk4 & 4) != 0) {
                            D_800E86A8 = (u8)4;
                        } else {
                            if ((D_800DC4BC->unk4 & 0x800) != 0) {
                                D_800E86A8 = (u8)5;
                            } else {
                                if ((D_800DC4BC->unk4 & 0x200) != 0) {
                                    D_800E86A8 = (u8)6;
                                } else {
                                    if ((D_800DC4BC->unk4 & 0x100) != 0) {
                                        D_800E86A8 = (u8)7;
                                    } else {
                                        *(void *)0x800F0000 = (u8)0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            bcopy(&D_80284ED0, &D_8018D9D0, 8);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80281780/func_80281780.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 09d006c9da5d6bbcd31ac6ca5c9165c1a8533a83
s32 func_80281880(s32 arg0) {
    s32 temp_v1;
    void *phi_v0;
    s32 phi_v1;
    s32 phi_v1_2;

    phi_v0 = &D_8018D9D0;
    phi_v1 = 0;
loop_1:
    phi_v1_2 = phi_v1;
    if (*phi_v0 != (arg0 + 0x800F0000)->unk-7958) {
        temp_v1 = phi_v1 + 1;
        phi_v0 = phi_v0 + 1;
        phi_v1 = temp_v1;
        phi_v1_2 = temp_v1;
        if (temp_v1 != 8) {
            goto loop_1;
        }
    }
    return phi_v1_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80281780/func_80281880.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 09d006c9da5d6bbcd31ac6ca5c9165c1a8533a83
void func_802818BC(void) {
    s32 sp24;
    s32 sp1C;
    s32 temp_ret;
    s32 temp_ret_2;

    if (D_8018EDF3 != 2) {
        D_802874D8.unk1D = func_80281880(0);
        D_802874D8.unk1E = (s8) D_800E86A8;
        return;
    }
    temp_ret = func_80281880(0);
    sp1C = temp_ret;
    sp24 = temp_ret;
    temp_ret_2 = func_80281880(1);
    if (sp1C < temp_ret_2) {
        D_802874D8.unk1E = (s8) D_800E86A8;
        D_802874D8.unk1D = (s8) sp24;
        return;
    }
    D_802874D8.unk1E = (s8) D_800E86A9;
    D_802874F5 = (s8) temp_ret_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80281780/func_802818BC.s")
#endif

#ifdef NON_MATCHING
void *load_ending_sequence_royalraceway(void) {
    s32 temp_t3;
    f32 temp_f;

    gCurrentCourseId = 7;
    D_800DC5B4 = (u16)1;
    D_800DC604 = 0;
    D_80287550 = 0xFFFF;
    D_80287554 = 0;
    func_802A4D18();
    func_802A74BC();
    D_801647A4 = 60.0f;
    D_80150130 = 60.0f;
    D_800DC5EC->unk2C = (u16)0x140;
    D_800DC5EC->unk2E = (u16)0xF0;
    D_800DC5EC->unk30 = (u16)0xA0;
    D_800DC5EC->unk32 = (u16)0x78;
    D_800DC530 = 0;
    D_8015F728 = (s32) D_8015F734;
    D_800DC52C = 0;
    gModeSelection = 0;
    load_course(gCurrentCourseId);
    D_8015F730 = (s32) D_8015F728;
    set_segment_base_addr(0xB, func_802AA88C(&_data_821D10SegmentRomStart, &_data_825800SegmentRomStart));
    set_segment_base_addr(6, func_802AA88C(&_course_banshee_boardwalk_dl_mio0SegmentRomStart, &_course_yoshi_valley_dl_mio0SegmentRomStart));
    D_8015F8E4 = -2000.0f;
    D_8015F6EA = -0x15A1;
    D_8015F6EE = -0x15A1;
    D_8015F6F2 = -0x15A1;
    D_8015F6E8 = 0x15A1;
    D_8015F6EC = 0x15A1;
    D_8015F6F0 = 0x15A1;
    D_8015F59C = 0;
    D_8015F5A0 = 0;
    D_8015F58C = 0;
    D_8015F588 = (u16)0;
    D_800DC5BC = (u16)0;
    D_800DC5C8 = (u16)0;
    D_8015F580 = (s32) D_8015F728;
    func_802AF5AC(0x70067E8, -1);
    func_802AF5AC(0x700AEF8, -1);
    func_802AF5AC(0x700A970, 8);
    func_802AF5AC(0x700AC30, 8);
    func_802AF5AC(0x7000CE0, 0x10);
    func_802AF5AC(0x7000E88, 0x10);
    func_802AF5AC(0x700A618, -1);
    func_802AF5AC(0x700A618, -1);
    func_802AF5AC(0x70023F8, 1);
    func_802AF5AC(0x7002478, 1);
    func_80295C6C();
    func_80281780();
    func_802818BC();
    func_8003D080();
    func_8006E9C0();
    func_8001C05C();
    func_80280FB0();
    func_802816B8();
    func_80093E60();
    D_801625F8 = (s32) gHeapEndPtr - D_8015F728;
    D_801625FC = ((f32) D_801625F8 / 1000.0f);
    return &D_801625F8;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80281780/load_ending_sequence_royalraceway.s")
#endif
