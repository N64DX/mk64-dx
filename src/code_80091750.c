#include <ultra64.h>
#include <macros.h>
#include <defines.h>
#include "code_80091750.h"
#include "code_800AF9B0.h"
#include "variables.h"
// TODO: Move gGfxPool out of main.h
// Unfortunately that's not a small effort due to weird import structure in this project
#include "main.h"

f64 exponent_by_squaring(f64 base, s32 exponent) {
    s32 positive_exponent;
    f64 result;

    if (exponent < 0) {
        positive_exponent = -exponent;
    } else {
        positive_exponent = exponent;
    }

    result = 1.0;
    if (positive_exponent != 0) {
        do {
            if ((positive_exponent & 1) != 0) {
                result *= base;
            }
            positive_exponent >>= 1;
            base *= base;
        } while (positive_exponent != 0);
    }
    if (exponent >= 0) {
        return result;
    }
    return 1.0 / result;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 exponent_by_squaring(s32); // extern
f64 func_8009186C(f64); // extern
f64 func_8009195C(f64, f64); // extern
extern f64 D_800F0CB0;
extern f64 D_800F0CB8;

f64 func_800917B0(f64 arg0, f64 arg1, f64 arg2) {
    s32 temp_f8;
    f64 phi_a2;

    phi_a2 = arg2;
    if ((arg1 <= D_800F0CB0) && (D_800F0CB8 <= arg1) && (temp_f8 = arg1, phi_a2 = (bitwise f64) temp_f8, (arg1 == temp_f8))) {
        return exponent_by_squaring(temp_f8);
    }
    if (arg0 > 0.0) {
        arg2 = arg1;
        return func_8009195C(func_8009186C(phi_a2) * arg2, arg2);
    }
    return 0.0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800917B0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091A6C(?, s32); // extern
? func_80091AC0(f64, f64, s32 *); // extern
extern f64 D_800F0CC0;
extern f64 D_800F0CC8;

f64 func_8009186C(f64 arg0) {
    s32 sp38;
    f64 temp_f14;
    f64 temp_f14_2;
    f64 temp_f14_3;
    f64 temp_f14_4;
    f64 temp_f2;
    s32 temp_v0;
    f64 phi_f2;
    f64 phi_f14;
    s32 phi_v0;

    temp_f14 = arg0;
    if (arg0 <= 0.0) {
        return 0.0;
    }
    arg0 = temp_f14;
    func_80091AC0(temp_f14 / D_800F0CC0, temp_f14, &sp38);
    temp_f14_2 = arg0 / func_80091A6C(0, sp38);
    temp_f14_3 = (temp_f14_2 - 1.0) / (temp_f14_2 + 1.0);
    phi_f2 = temp_f14_3;
    phi_f14 = temp_f14_3;
    phi_v0 = 1;
    do {
        temp_v0 = phi_v0 + 2;
        temp_f14_4 = phi_f14 * (temp_f14_3 * temp_f14_3);
        temp_f2 = phi_f2 + (temp_f14_4 / temp_v0);
        phi_f2 = temp_f2;
        phi_f14 = temp_f14_4;
        phi_v0 = temp_v0;
    } while (phi_f2 != temp_f2);
    return (sp38 * D_800F0CC8) + (2.0 * temp_f2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009186C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80091A6C(f64, f64, s32); // extern
extern f64 D_800F0CD0;

void func_8009195C(f64 arg0) {
    f64 temp_f14;
    f64 temp_f18;
    f64 temp_f2;
    f64 temp_f2_2;
    s32 temp_f10;

    if (arg0 >= 0.0) {

    }
    temp_f18 = D_800F0CD0;
    temp_f10 = 0.0 + (arg0 / temp_f18);
    temp_f14 = arg0 - (temp_f10 * temp_f18);
    temp_f2 = temp_f14 * temp_f14;
    temp_f2_2 = 2.0 + (temp_f2 / (6 + (temp_f2 / (0xA + (temp_f2 / (0xE + (temp_f2 / (0x12 + (temp_f2 / 22.0)))))))));
    func_80091A6C((temp_f2_2 + temp_f14) / (temp_f2_2 - temp_f14), temp_f14, temp_f10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009195C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091A6C(f64 arg0, s32 arg2) {
    s32 temp_t7;
    s32 phi_a2;
    s32 phi_a2_2;
    f64 phi_f12;
    f64 phi_f12_2;
    f64 phi_f12_3;
    f64 phi_f0;

    phi_a2 = arg2;
    phi_f12 = arg0;
    phi_f12_3 = arg0;
    if (arg2 >= 0) {

    } else {
        phi_a2 = -arg2;
    }
    phi_a2_2 = phi_a2;
    phi_f0 = 0.0;
    if (phi_a2 != 0) {
        do {
            temp_t7 = phi_a2_2 >> 1;
            phi_f12_2 = phi_f12_3;
            if ((phi_a2_2 & 1) != 0) {
                phi_f12_2 = phi_f12_3 * phi_f0;
            }
            phi_a2_2 = temp_t7;
            phi_f12 = phi_f12_2;
            phi_f12_3 = phi_f12_2;
            phi_f0 *= phi_f0;
        } while (temp_t7 != 0);
    }
    return phi_f12;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091A6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091AC0(f64 arg0, s32 *arg2) {
    f64 phi_f12;
    f64 phi_f12_2;
    s32 phi_v0;
    f64 phi_f12_3;
    s32 phi_v0_2;
    s32 phi_v0_3;

    phi_f12 = arg0;
    phi_v0 = 0;
    phi_f12_3 = arg0;
    phi_v0_3 = 0;
    if ((arg0 < 0.5) || (arg0 >= 1.0)) {
        do {
loop_2:
            if (phi_f12 < 0.5) {
                phi_f12_2 = phi_f12 * 2.0;
                phi_v0_2 = phi_v0_3 - 1;
            } else {
                phi_f12_2 = phi_f12 / 2.0;
                phi_v0_2 = phi_v0_3 + 1;
            }
            phi_f12 = phi_f12_2;
            phi_v0 = phi_v0_2;
            phi_f12_3 = phi_f12_2;
            phi_v0_3 = phi_v0_2;
            if (phi_f12_2 < 0.5) {
                goto loop_2;
            }
        } while (phi_f12_2 >= 1.0);
    }
    *arg2 = phi_v0;
    return phi_f12_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091AC0.s")
#endif

void swap_values(s32 *arg0, s32 *arg1) {
    s32 temp;

    temp = *arg0;
    *arg0 = *arg1;
    *arg1 = temp;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80091D74(); // extern
? func_80094C60(); // extern
? func_800AF9B0(); // extern
? func_800B44BC(); // extern
? load_save_data(); // extern
? func_800C97C4(s32); // extern
? func_800C9D0C(s32); // extern
extern s8 D_800E852C;
extern s32 gMenuSelection;
extern s32 D_800E86A4;
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern s32 D_8018D9B8;
extern s32 D_8018D9C0;
extern ? D_8018E7AC;
extern ? D_8018E7B1;
extern ? D_8018E838;
extern ? D_8018E83C;
extern s8 D_8018EDF4;
extern s8 D_8018EDF5;
extern s8 D_8018EDF6;
extern s8 D_8018EE0C;
extern ? _course_mario_raceway_dl_mio0SegmentRomStart;
extern s32 gPrevLoadedAddress;
extern OSMesgQueue gSIEventMesgQueue;

void func_80091B78(void) {
    s32 temp_s0;
    s32 temp_s0_2;
    u32 temp_v0;
    u32 temp_v0_2;
    ? *phi_v0;
    ? *phi_v0_2;
    s32 phi_s0;
    s32 phi_s0_2;

    if (D_800E852C != 0) {
        D_800E852C = 0;
        D_8018EDF4 = 0xA;
        D_8018EDF5 = 5;
        D_8018EDF6 = 0xA;
        if (osEepromProbe(&gSIEventMesgQueue) != 0) {
            load_save_data();
        }
        if (func_80091D74() != 0) {
            gMenuSelection = CONTROLLER_PAK_MENU;
        }
    }
    if (gMenuSelection == LOGO_INTRO_MENU) {
        gPrevLoadedAddress = D_8015F734;
        set_segment_base_addr(6, func_802AA88C(&_data_825800SegmentRomStart, &_course_mario_raceway_dl_mio0SegmentRomStart));
    }
    gPrevLoadedAddress = D_8015F734;
    D_8018D9B0 = func_802A7B70(0x900B0);
    D_8018D9B4 = func_802A7B70(0xCE00);
    D_8018D9B8 = func_802A7B70(0x12C00);
    D_8018D9C0 = func_802A7B70(0x1000);
    func_800AF9B0();
    D_8018EE0C = 0;
    phi_v0 = &D_8018E7AC;
    do {
        temp_v0 = phi_v0 + 1;
        temp_v0->unk-1 = 0;
        phi_v0 = temp_v0;
    } while (temp_v0 < &D_8018E7B1);
    phi_v0_2 = &D_8018E838;
    do {
        temp_v0_2 = phi_v0_2 + 1;
        temp_v0_2->unk-1 = 0;
        phi_v0_2 = temp_v0_2;
    } while (temp_v0_2 < &D_8018E83C);
    D_800DC5EC->unk30 = 0xA0;
    D_800DC5EC->unk32 = 0x78;
    D_800DC5EC->unk2C = 0x140;
    D_800DC5EC->unk2E = 0xF0;
    D_800E86A4 = 1;
    func_80094C60();
    phi_s0 = 0;
    do {
        func_800C97C4(phi_s0 & 0xFF);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 < 4);
    phi_s0_2 = 1;
    do {
        func_800C9D0C(phi_s0_2 & 0xFF);
        temp_s0_2 = phi_s0_2 + 1;
        phi_s0_2 = temp_s0_2;
    } while (temp_s0_2 != 8);
    func_800B44BC();
    osViSetSpecialFeatures(0x40);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091B78.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800CE720(OSMesgQueue *, OSPfs *, ?); // extern
extern OSPfs D_8018E868;
extern ? D_8018E938;
extern ? D_8018EB38;
extern s32 D_8018EB78;
extern s32 D_8018EB7C;
extern s32 gControllerPakNumPagesFree;
extern u8 gControllerBits;
extern ? gControllerStatuses;
extern OSMesgQueue gSIEventMesgQueue;

? func_80091D74(void) {
    u8 sp67;
    ? *temp_s1;
    s32 temp_s0;
    s32 phi_s0;
    ? *phi_s1;

    if (gControllerBits == 0) {
        return 0;
    }
    if (((*(&gControllerStatuses + 2) == 0) & 1) != 0) {
        return 0;
    }
    if ((gControllerOne->button & 0x1000) == 0) {
        return 0;
    }
    osPfsIsPlug(&gSIEventMesgQueue, &sp67);
    if ((sp67 & 1) != 0) {
        if (func_800CE720(&gSIEventMesgQueue, &D_8018E868, 0) != 0) {
            return 0;
        }
        phi_s0 = 0;
        if (osPfsNumFiles(&D_8018E868, &D_8018EB78, &D_8018EB7C) != 0) {
            return 0;
        }
        phi_s1 = &D_8018EB38;
        do {
            temp_s0 = phi_s0 + 1;
            temp_s1 = phi_s1 + 4;
            temp_s1->unk-4 = osPfsFileState(&D_8018E868, phi_s0, &D_8018E938 + (phi_s0 << 5));
            phi_s0 = temp_s0;
            phi_s1 = temp_s1;
        } while (temp_s0 != 0x10);
        if (osPfsFreeBlocks(&D_8018E868, &gControllerPakNumPagesFree) != 0) {
            return 0;
        }
        gControllerPakNumPagesFree = gControllerPakNumPagesFree >> 8;
        return 1;
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091D74.s")
#endif

void func_80091EE4(void) {
    s32 temp_s0;
    s32 temp_s2;
    s32 tmp;

    D_800E86F8 = 0;
    tmp = func_800B5F30();

    if ((D_8018EDFB != 0) && (tmp == 0)) {
        temp_s2 = (gCupSelection * 4) + gCupCourseSelection;
        func_800B6708();
        
        for (temp_s0 = 0; temp_s0 < 2; ++temp_s0) {
            if ((D_8018EE10[temp_s0].ghostDataSaved != 0) && (temp_s2 == D_8018EE10[temp_s0].courseIndex)) {
                func_800B64EC(temp_s0);
                temp_s0 = 2;
                D_8018EDFB = 0;
            }
        }
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80092258(); // extern
? func_80099110(); // extern
? func_8009A344(); // extern
? func_8009E620(); // extern
? add_8018D9E0_entry(?, ?, ?, ?); // extern
? func_800B5F30(); // extern
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern s32 D_8018D9B8;
extern s32 D_8018D9BC;
extern ? D_8018E7AC;
extern ? D_8018E7B1;
extern s8 D_8018E838;
extern s8 D_8018EE08;
extern u8 gControllerBits;

void func_80091FA4(void) {
    u32 temp_v1;
    ? *phi_v1;

    D_8018D9B4 = func_802A7B70(0x2800);
    D_8018D9B0 = func_802A7B70(0x124F8);
    D_8018D9B8 = func_802A7B70(0x1000);
    D_8018D9BC = func_802A7B70(4);
    phi_v1 = &D_8018E7AC;
    do {
        temp_v1 = phi_v1 + 1;
        temp_v1->unk-1 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 < &D_8018E7B1);
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    func_80099110();
    func_8009A344();
    func_8009E620();
    func_80092258();
    add_8018D9E0_entry(0x96, 0x64, 0x24, 1);
    add_8018D9E0_entry(0x97, 0x64, 0xDD, 1);
    add_8018D9E0_entry(0x98, 0, 0, 0);
    add_8018D9E0_entry(0xC7, 0, 0, 0);
    if (gModeSelection == TIME_TRIALS) {
        add_8018D9E0_entry(0xBE, 0, 0, 0);
        add_8018D9E0_entry(0x10E, 0, 0, 0);
    }
    if ((D_8015F890 != 0) && (gModeSelection == TIME_TRIALS)) {
        add_8018D9E0_entry(0xBD, 0, 0, 0);
    }
    if (((gControllerBits & 1) == 0) && (D_8018EE08 != 0)) {
        add_8018D9E0_entry(4, 0, 0, 2);
    }
    func_800B5F30();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091FA4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern void *gControllerFive;
extern s8 D_8018D9D8;
extern s8 D_8018D9D9;

void func_80092148(void) {
    void *temp_v0;
    s32 phi_v1;

    temp_v0 = gControllerFive;
    phi_v1 = 0;
    if (temp_v0->unk4 != 0) {
        phi_v1 = 1;
    }
    if (temp_v0->unk6 != 0) {
        D_8018D9D9 = 1;
    }
    if ((phi_v1 != 0) && (D_8018D9D9 != 0)) {
        D_8018D9D8 = 1;
        return;
    }
    D_8018D9D8 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092148.s")
#endif

void func_800921B4(void) {
    D_8018D9D9 = 0;
}

void func_800921C0(s32 test, s32 target, s32 alternative_color) {
    if (test == target) {
        if (func_800B4520() != 0) {
            set_text_color(gGlobalTimer % 3);
        } else {
            set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        }
    } else {
        set_text_color(alternative_color);
    }
}

void func_80092224(s32 test, s32 target, s32 alternative_color) {
    if (test == target) {
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
    } else {
        set_text_color(alternative_color);
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018E850;
extern ? D_8018E858;

void func_80092258(void) {
    ? *temp_a0;
    s32 temp_v0;
    s32 phi_v0;
    s32 *phi_v1;
    ? *phi_a0;

    phi_v0 = 0;
    phi_v1 = &D_8018E850;
    phi_a0 = &D_8018E858;
    do {
        *phi_v1 = phi_v0;
        temp_v0 = phi_v0 + 1;
        temp_a0 = phi_a0 + 4;
        temp_a0->unk-4 = 0;
        phi_v0 = temp_v0;
        phi_v1 += 4;
        phi_a0 = temp_a0;
    } while (temp_v0 != 2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092258.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
extern ? D_02007BB8;
extern ? D_02007CD8;
extern ? D_02007DF8;
static u32 D_800E84C0[3] = { (u32) &D_02007BB8, (u32) &D_02007CD8, (u32) &D_02007DF8 }; /* const */
static ? D_800E84CC;                                /* unable to generate initializer; const */

void func_80092290(s32 arg0, s32 *arg1, s32 *arg2) {
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_s4;
    s32 temp_t0;
    s32 temp_t6;
    s32 temp_t7;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_t9;
    u32 *temp_s0;
    void *temp_a2;
    void *temp_v0;
    void *temp_v1;
    void *temp_v1_2;
    u32 *phi_s0;

    if ((arg0 >= 4) && (arg0 < 6)) {
        temp_t8 = *arg2 + 0x10;
        *arg2 = temp_t8;
        if (temp_t8 >= 0x100) {
            *arg2 = 0;
            *arg1 = (s32) (*arg1 + 1) % 3;
        }
        temp_s4 = (((arg0 * 4) + (((s32) gGlobalTimer % 2) * 2)) - 6) * 0x10;
        phi_s0 = D_800E84C0;
        do {
            temp_v0 = segmented_to_virtual_dupe(*phi_s0);
            temp_a0 = *arg2;
            temp_a2 = temp_v0 + temp_s4;
            temp_a1 = 0x100 - temp_a0;
            temp_s0 = phi_s0 + 4;
            temp_t0 = (*arg1 * 2) + 2;
            temp_v1 = temp_v0 + (temp_t0 * 0x10);
            temp_v1_2 = temp_v0 + (((temp_t0 % 6) + 2) * 0x10);
            temp_t6 = (s32) ((temp_a1 * temp_v1->unkC) + (temp_a0 * temp_v1_2->unkC)) / 256;
            temp_a2->unkC = (s8) temp_t6;
            temp_t9 = (s32) ((temp_a1 * temp_v1->unkD) + (temp_a0 * temp_v1_2->unkD)) / 256;
            temp_a2->unkD = (s8) temp_t9;
            temp_t7 = (s32) ((temp_a1 * temp_v1->unkE) + (temp_a0 * temp_v1_2->unkE)) / 256;
            temp_a2->unkE = (s8) temp_t7;
            temp_t8_2 = (s32) ((temp_a1 * temp_v1->unkF) + (temp_a0 * temp_v1_2->unkF)) / 256;
            temp_a2->unkF = (s8) temp_t8_2;
            temp_a2->unk1C = (s8) temp_t6;
            temp_a2->unk1D = (s8) temp_t9;
            temp_a2->unk1E = (s8) temp_t7;
            temp_a2->unk1F = (s8) temp_t8_2;
            phi_s0 = temp_s0;
        } while (temp_s0 != &D_800E84CC);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092290.s")
#endif

void func_80092500(void) {

    switch(gModeSelection) {
        case GRAND_PRIX:
            add_8018D9E0_entry(0xAA, 0, 0, 0);
            break;
        case TIME_TRIALS:
            add_8018D9E0_entry(0xB9, 0, 0, 0);
            break;
    }
}

void func_80092564(void) {
    add_8018D9E0_entry(0xAC, 0, 0, 0);
    func_8005D18C();
    func_8001968C();
}

void func_800925A0(void) {
    add_8018D9E0_entry(0xAF, 0, 0, 0);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern void *func_800AAEF4(s32); // extern
// removed a temp from this func temp = func_800AAEF4.
void func_800925CC(void) {
    if (func_800AAEF4(0xAF)->unk4 == 2) {
        func_800AAEF4(0xAF)->unk4 = 3;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800925CC.s")
#endif

void func_80092604(void) {
    add_8018D9E0_entry(0xB0, 0, 0, 0);
}

void func_80092630(void) {
    add_8018D9E0_entry(0xBC, 0, 0, 0);
}


void func_8009265C(void) {
    add_8018D9E0_entry(0x12B, 0, 0, 2);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? add_8018D9E0_entry(?, ?, ?, ?);                        /* extern */

void func_80092688(void) {
    u16 temp_t6;

    temp_t6 = D_800DC5E4;
    switch (temp_t6) {
    case 0:
        add_8018D9E0_entry(0x1CE, 0, 0, 2);
        return;
    default:
        add_8018D9E0_entry(0x190, 0, 0, 2);
        add_8018D9E0_entry(0x191, 0, 0, 2);
        return;
    case 2:
        add_8018D9E0_entry(0x192, 0, 0, 2);
        add_8018D9E0_entry(0x193, 0, 0, 2);
        return;
    case 3:
        add_8018D9E0_entry(0x194, 0, 0, 2);
        add_8018D9E0_entry(0x195, 0, 0, 2);
        return;
    case 4:
        add_8018D9E0_entry(0x196, 0, 0, 2);
        add_8018D9E0_entry(0x197, 0, 0, 2);
        return;
    case 5:
        add_8018D9E0_entry(0x198, 0, 0, 2);
        add_8018D9E0_entry(0x199, 0, 0, 2);
        add_8018D9E0_entry(0x19A, 0, 0, 2);
        add_8018D9E0_entry(0x19B, 0, 0, 2);
        return;
    case 6:
        add_8018D9E0_entry(0x198, 0, 0, 2);
        add_8018D9E0_entry(0x19C, 0, 0, 2);
        add_8018D9E0_entry(0x19D, 0, 0, 2);
        add_8018D9E0_entry(0x19E, 0, 0, 2);
        return;
    case 7:
        add_8018D9E0_entry(0x19F, 0, 0, 2);
        add_8018D9E0_entry(0x1A0, 0, 0, 2);
        add_8018D9E0_entry(0x1A1, 0, 0, 2);
        add_8018D9E0_entry(0x1A2, 0, 0, 2);
        return;
    case 8:
        add_8018D9E0_entry(0x1A3, 0, 0, 2);
        add_8018D9E0_entry(0x1A4, 0, 0, 2);
        return;
    case 9:
        add_8018D9E0_entry(0x1A5, 0, 0, 2);
        add_8018D9E0_entry(0x1A6, 0, 0, 2);
        add_8018D9E0_entry(0x1A7, 0, 0, 2);
        add_8018D9E0_entry(0x1A8, 0, 0, 2);
        add_8018D9E0_entry(0x1A9, 0, 0, 2);
        return;
    case 10:
        add_8018D9E0_entry(0x1A5, 0, 0, 2);
        add_8018D9E0_entry(0x1A6, 0, 0, 2);
        add_8018D9E0_entry(0x1AA, 0, 0, 2);
        add_8018D9E0_entry(0x1AB, 0, 0, 2);
        add_8018D9E0_entry(0x1AC, 0, 0, 2);
        return;
    case 11:
        add_8018D9E0_entry(0x1AD, 0, 0, 2);
        add_8018D9E0_entry(0x1AE, 0, 0, 2);
        add_8018D9E0_entry(0x1AF, 0, 0, 2);
        add_8018D9E0_entry(0x1B0, 0, 0, 2);
        return;
    case 12:
        add_8018D9E0_entry(0x1B1, 0, 0, 2);
        add_8018D9E0_entry(0x1B2, 0, 0, 2);
        return;
    case 13:
        add_8018D9E0_entry(0x1B3, 0, 0, 2);
        add_8018D9E0_entry(0x1B4, 0, 0, 2);
        add_8018D9E0_entry(0x1B5, 0, 0, 2);
        return;
    case 14:
        add_8018D9E0_entry(0x1B6, 0, 0, 2);
        add_8018D9E0_entry(0x1B7, 0, 0, 2);
        add_8018D9E0_entry(0x1B8, 0, 0, 2);
        add_8018D9E0_entry(0x1B9, 0, 0, 2);
        add_8018D9E0_entry(0x1BA, 0, 0, 2);
        add_8018D9E0_entry(0x1BB, 0, 0, 2);
        add_8018D9E0_entry(0x1BC, 0, 0, 2);
        return;
    case 15:
        add_8018D9E0_entry(0x1BD, 0, 0, 2);
        add_8018D9E0_entry(0x1BE, 0, 0, 2);
        add_8018D9E0_entry(0x1BF, 0, 0, 2);
        add_8018D9E0_entry(0x1C0, 0, 0, 2);
        return;
    case 16:
        add_8018D9E0_entry(0x1C1, 0, 0, 2);
        add_8018D9E0_entry(0x1C2, 0, 0, 2);
        add_8018D9E0_entry(0x1C3, 0, 0, 2);
        return;
    case 17:
        add_8018D9E0_entry(0x1C4, 0, 0, 2);
        add_8018D9E0_entry(0x1C5, 0, 0, 2);
        add_8018D9E0_entry(0x1C6, 0, 0, 2);
        add_8018D9E0_entry(0x1C7, 0, 0, 2);
        add_8018D9E0_entry(0x1C8, 0, 0, 2);
        add_8018D9E0_entry(0x1C9, 0, 0, 2);
        add_8018D9E0_entry(0x1CA, 0, 0, 2);
        add_8018D9E0_entry(0x1CB, 0, 0, 2);
        add_8018D9E0_entry(0x1CC, 0, 0, 2);
        return;
    case 18:
        add_8018D9E0_entry(0x1CD, 0, 0, 2);
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092688.s")
#endif

void func_80092C80(void) {
    D_8018ED91 = 1;
}

#ifdef NON_MATCHING
// Originally func_80092C90
// Some kind of lookup function, seems to return an index to be used
// to get a character's width in pixels
// This technically matches, but due to linker alignment shenanigans actually
// matching will have to wait
s32 char_to_glyph_index(char *character) {
    s32 index = 1;

    // Uppercase Letters
    if ((*character >= 0x61) && (*character < 0x7B)) {
        index = *character - 0x61;
    // Lowercase Letters
    } else if ((*character >= 0x41) && (*character < 0x5B)) {
        index = *character - 0x41;
    // Numbers
    } else if ((*character >= 0x30) && (*character < 0x3A)) {
        index = *character - 0x10;
    // Space
    } else if (*character == 0x20) {
        index = -1;
    // Interpreting characters as signed numbers, so check if the character is "negative"
    } else if (*character < 0) {
        switch (*character) {                          /* switch 1 */
        case -92:                                   /* switch 1 */
            // WARNING: Not sure about the arguments to the following 3 functions, its not clear
            // what they exepct
            index = func_80092E1C(character + 1);
            break;
        case -91:                                   /* switch 1 */
            index = func_80092DF8(character + 1);
            break;
        case -85:                                   /* switch 1 */
        case -93:                                   /* switch 1 */
        case -95:                                   /* switch 1 */
            index = func_80092EE4(character);
            break;
        }
    } else {
        switch (*character) {                          /* switch 2 */
        // !
        case 0x21:                                  /* switch 2 */
            index = 0x1A;
            break;
        // -
        case 0x2D:                                  /* switch 2 */
            index = 0x1B;
            break;
        // ?
        case 0x3F:                                  /* switch 2 */
            index = 0x1C;
            break;
        // '
        case 0x27:                                  /* switch 2 */
            index = 0x1D;
            break;
        // $
        // Doesn't appear to have a texture?
        case 0x24:                                  /* switch 2 */
            index = 0x1E;
            break;
        // .
        case 0x2E:                                  /* switch 2 */
            index = 0x1F;
            break;
        // "
        case 0x22:                                  /* switch 2 */
            index = 0x2A;
            break;
        // *
        case 0x2A:                                  /* switch 2 */
            index = 0x2B;
            break;
        // +
        case 0x2B:                                  /* switch 2 */
            index = 0x2C;
            break;
        // (
        // Displayed as "cc"
        case 0x28:                                  /* switch 2 */
            index = 0x2D;
            break;
        // ,
        case 0x2C:                                  /* switch 2 */
            index = 0x2E;
            break;
        default:                                    /* switch 2 */
            index = -2;
            break;
        }
    }
    return index;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/char_to_glyph_index.s")
#endif

s32 func_80092DF8(void) {
    return func_80092E1C() + 0x50;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80092E1C(s8 *arg0) {
    s32 temp_t6;

    temp_t6 = (*arg0 + 0x80) & 0xFF;
    if ((temp_t6 >= 0x21) && (temp_t6 < 0x2B)) {
        if ((temp_t6 % 2) != 0) {
            return ((temp_t6 - 0x21) / 2) + 0x7B;
        }
        return ((temp_t6 - 0x21) / 2) + 0x30;
    }
    if ((temp_t6 >= 0x2B) && (temp_t6 < 0x6E)) {
        return temp_t6 + 0xA;
    }
    if (temp_t6 != 0x6F) {
        if ((temp_t6 != 0x72) && (temp_t6 != 0x73)) {
            return -2;
        }
        return temp_t6 + 7;
    }
    return 0x78;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092E1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_80092EE4(void *arg0) {
    s32 temp_t6;
    s8 temp_a1;
    s32 phi_v1;

    temp_a1 = arg0->unk0;
    temp_t6 = (arg0->unk1 + 0x80) & 0xFF;
    phi_v1 = 2;
    if (temp_a1 != -0x5F) {
        if (temp_a1 != -0x5D) {
            if (temp_a1 != -0x55) {
                return 2;
            }
            if (temp_t6 == 0x2E) {
                phi_v1 = 0xE0;
            }
            /* Duplicate return node #31. Try simplifying control flow for better match */
            return phi_v1;
        }
        if ((temp_t6 >= 0x30) && (temp_t6 < 0x3A)) {
            return temp_t6 + 0xA5;
        }
        switch (temp_t6) {                          /* switch 2 */
        case 0x44:                                  /* switch 2 */
            return 0xDF;
        case 0x43:                                  /* switch 2 */
        case 0x63:                                  /* switch 2 */
            return 0xE0;
        case 0x4E:                                  /* switch 2 */
        case 0x6E:                                  /* switch 2 */
            return 0xE1;
        case 0x50:                                  /* switch 2 */
        case 0x70:                                  /* switch 2 */
            return 0xE2;
        case 0x52:                                  /* switch 2 */
        case 0x72:                                  /* switch 2 */
            return 0xE3;
        case 0x73:                                  /* switch 2 */
            return 0xE4;
        case 0x54:                                  /* switch 2 */
        case 0x74:                                  /* switch 2 */
            return 0xE5;
        case 0x53:                                  /* switch 2 */
            return 0xE6;
        case 0x56:                                  /* switch 2 */
        case 0x76:                                  /* switch 2 */
            return 0xE7;
        }
    } else {
        switch (temp_t6) {                          /* switch 1 */
        case 0x22:                                  /* switch 1 */
        case 0x24:                                  /* switch 1 */
            return 0xEA;
        case 0x23:                                  /* switch 1 */
            return 0xE9;
        case 0x25:                                  /* switch 1 */
            return 0xD0;
        case 0x2A:                                  /* switch 1 */
            return 0xE8;
        case 0x30:                                  /* switch 1 */
            return 0xEB;
        case 0x47:                                  /* switch 1 */
            return 0xD1;
        case 0x49:                                  /* switch 1 */
            return 0xD2;
        case 0x5C:                                  /* switch 1 */
            return 0xD3;
        case 0x3C:                                  /* switch 1 */
        case 0x3D:                                  /* switch 1 */
        case 0x5D:                                  /* switch 1 */
            return 0xD4;
        default:                                    /* switch 1 */
        default:                                    /* switch 2 */
            return phi_v1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092EE4.s")
#endif

//Originally func_80093034
s32 get_string_width(char *buffer) {
    s32 glyphIndex;
    s32 stringWidth = 0;

    if (*buffer != 0) {
        do {
            glyphIndex = char_to_glyph_index(buffer);
            if (glyphIndex >= 0) {
                stringWidth += gGlyphDisplayWidth[glyphIndex];
            } else if (glyphIndex == -1) {
                stringWidth += 7;
            }
            if (glyphIndex >= 0x30) {
                buffer += 2;
            } else {
                buffer += 1;
            }
        } while (*buffer != 0);
    }
    return stringWidth;
}

void set_text_color(s32 arg0) {
    gTextColor = arg0;
}

UNUSED void func_800930E4(s32 arg0, s32 arg1, s32 *arg2) {
    set_text_color(TEXT_BLUE);
    func_80093324(arg0, arg1, arg2, 0, 1.0, 1.0);
}

// "tracking" is a uniform spacing between all characters in a given word
void print_text0(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale, s32 arg6) {
    s32 stringWidth = 0;
    s32 glyphIndex;

    gSPDisplayList(gDisplayListHead++, D_020077A8);
    if (*text != 0) {
        do{
            glyphIndex = char_to_glyph_index(text);
            if (glyphIndex >= 0) {
                func_80099184(segmented_to_virtual(gGlyphTextureLUT[glyphIndex]));
                gDisplayListHead = func_8009BEF0(gDisplayListHead, segmented_to_virtual(gGlyphTextureLUT[glyphIndex]), column + (stringWidth * x_scale), row, arg6, x_scale, y_scale);
                stringWidth += gGlyphDisplayWidth[glyphIndex] + tracking;
            }
            else if ((glyphIndex != -2) && (glyphIndex == -1)) {
                stringWidth += tracking + 7;
            }
            else{
                gSPDisplayList(gDisplayListHead++, D_020077D8);
                return;
            }
            if (glyphIndex >= 0x30) {
                text += 2;
            } else {
                text += 1;
            }
        } while(*text != 0);
    }
    gSPDisplayList(gDisplayListHead++, D_020077D8);
}

void func_80093324(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text0(column, row, text, tracking, x_scale, y_scale, 1);
}

void func_80093358(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text0(column, row, text, tracking, x_scale, y_scale, 2);
}

#ifdef NON_MATCHING
// "tracking" is a uniform spacing between all characters in a given word
void print_text1(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale, s32 arg6) {
    char *temp_string = text;
    s32 stringWidth = 0;
    s32 glyphIndex;

    if (*temp_string != 0) {
        do{
            glyphIndex = char_to_glyph_index(temp_string);
            if (glyphIndex >= 0) {
                stringWidth += ((gGlyphDisplayWidth[glyphIndex] + tracking) * x_scale);
            }
            else if ((glyphIndex != -2) && (glyphIndex == -1)) {
                stringWidth += ((tracking + 7) * x_scale);
            }
            else{
                return;
            }
            if (glyphIndex >= 0x30) {
                temp_string += 2;
            } else {
                temp_string += 1;
            }
        } while(*temp_string != 0);
    }

    switch(arg6) {
        case 1:
        case 3:
            column -= stringWidth;
            break;
        case 2:
        case 4:
            column -= stringWidth / 2;
            break;
        default:
            break;
    }

    if (arg6 < 3){
        arg6 = 1;
    }
    else{
        arg6 = 2;
    }


    gSPDisplayList(gDisplayListHead++, D_020077A8);
    if (*text != 0) {
        do{
            glyphIndex = char_to_glyph_index(text);
            if (glyphIndex >= 0) {
                func_80099184(segmented_to_virtual(gGlyphTextureLUT[glyphIndex]));
                gDisplayListHead = func_8009BEF0(gDisplayListHead, segmented_to_virtual(gGlyphTextureLUT[glyphIndex]), column, row, arg6, x_scale, y_scale);
                column += (gGlyphDisplayWidth[glyphIndex] + tracking);
                column *= x_scale;
            }
            else if ((glyphIndex != -2) && (glyphIndex == -1)) {
                column += (tracking + 7);
                column *= x_scale;
            }
            else{
                gSPDisplayList(gDisplayListHead++, D_020077D8);
                return;
            }
            if (glyphIndex >= 0x30) {
                text += 2;
            } else {
                text += 1;
            }
        } while(*text != 0);
    }
    gSPDisplayList(gDisplayListHead++, D_020077D8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/print_text1.s")
#endif

void func_800936B8(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 1);
}

void draw_text(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 2);
}

void func_80093720(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 3);
}

void func_80093754(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 4);
}

void print_text2(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale, s32 arg6) {
    s32 temp_v0_3;
    s32 characterWidth;
    s32 glyphIndex;

    gSPDisplayList(gDisplayListHead++, D_020077A8);
    if (*text != 0) {
        do {
            glyphIndex = char_to_glyph_index(text);
            if (glyphIndex >= 0) {
                temp_v0_3 = segmented_to_virtual(gGlyphTextureLUT[glyphIndex]);
                func_80099184(temp_v0_3);
                gDisplayListHead = func_8009BEF0(gDisplayListHead, temp_v0_3, column - (gGlyphDisplayWidth[glyphIndex] / 2), row, arg6, x_scale, y_scale);
                if ((glyphIndex >= 0xD5) && (glyphIndex < 0xE0)) {
                    characterWidth = 0x20;
                } else {
                    characterWidth = 0xC;
                }
                column = column + (s32)((characterWidth + tracking) * x_scale);
            }
            else if ((glyphIndex != -2) && (glyphIndex == -1)) {
                column = column + (s32)((tracking + 7) * x_scale);
            }
            else{
                gSPDisplayList(gDisplayListHead++, D_020077D8);
                return;
            }
            if (glyphIndex >= 0x30) {
                text += 2;
            } else {
                text += 1;
            }
        } while(*text != 0);
    }

    gSPDisplayList(gDisplayListHead++, D_020077D8);
}

void func_800939C8(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text2(column, row, text, tracking, x_scale, y_scale, 1);
}

void text_draw(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text2(column, row, text, tracking, x_scale, y_scale, 2);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E2A8(s8, s32); // extern
extern ? D_800F0B1C;

void func_80093A30(s32 arg0) {
    func_8009E2A8(*(&D_800F0B1C + arg0), arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093A30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80093C1C(s8, u32);                           /* extern */
? func_800940EC(s8, u32);                           /* extern */
? func_8009C918(u32);                               /* extern */
static ? D_800F0B1C;                                /* unable to generate initializer; const */

void func_80093A5C(u32 arg0) {
    Gfx *temp_v1;

    if (D_8015F788 == 0) {
        func_8009C918(arg0);
    }
    switch (arg0) {
    case 0:
        func_800940EC(*(&D_800F0B1C + arg0), arg0);
        break;
    case 1:
    case 2:
    case 3:
    case 4:
        if (D_8015F788 == 0) {
            func_80093C1C(*(&D_800F0B1C + arg0), arg0);
        } else {
            func_800940EC(*(&D_800F0B1C + arg0), arg0);
        }
        break;
    case 8:
    case 9:
    case 10:
    case 11:
        if (D_8015F788 == 3) {
            func_800940EC(*(&D_800F0B1C + arg0), arg0);
        } else {
            func_80093C1C(*(&D_800F0B1C + arg0), arg0);
        }
        break;
    }
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->words.w0 = 0xB900031D;
    temp_v1->words.w1 = 0xF0A4000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093A5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
//? func_8009CA6C(void **); // extern
extern u8 D_02007F18;
extern u8 D_02007F48;
extern Gfx *gDisplayListHead;

void func_80093C1C(void) {
    gSPDisplayList(gDisplayListHead++, &D_02007F18);
    func_8009CA6C(&gDisplayListHead);
    gSPDisplayList(gDisplayListHead++, &D_02007F48);
}

#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093C1C.s")
#endif

void func_80093C98(s32 arg0) {
    gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
    guOrtho(&gGfxPool->mtxPool[D_80164AF0 + 0x3EB], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
    gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPool[D_80164AF0 + 0x3EB]), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    D_80164AF0++;
    gSPDisplayList(gDisplayListHead++, D_02007F18);
    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, 320, 240);
    func_800A8250();
    if (arg0 == 0) {
        func_800A54EC();
        func_8009CA6C(4);
        D_80165754 = D_80164AF0;
        D_80164AF0 = 0;
    }
}

void func_80093E20(void) {
    func_80093C98(0);
}

void func_80093E40(void) {
    func_80093C98(1);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80092258(); // extern
? func_80099110(); // extern
? func_8009A344(); // extern
? func_8009E620(); // extern
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern s32 D_8018D9B8;
extern s32 D_8018D9BC;
extern ? D_8018E7AC;
extern ? D_8018E7B1;
extern s8 D_8018E838;
extern s8 D_8018ED91;

void func_80093E60(void) {
    u32 temp_v1;
    ? *phi_v1;

    D_8018D9B4 = func_802A7B70(0x2800);
    D_8018D9B0 = func_802A7B70(0x124F8);
    D_8018D9B8 = func_802A7B70(0x1000);
    D_8018D9BC = func_802A7B70(4);
    phi_v1 = &D_8018E7AC;
    do {
        temp_v1 = phi_v1 + 1;
        temp_v1->unk-1 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 < &D_8018E7B1);
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    func_80099110();
    func_8009A344();
    func_8009E620();
    func_80092258();
    D_8018ED91 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093E60.s")
#endif

void func_80093F10(void) {
    gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
    guOrtho(&gGfxPool->mtxPool[D_80164AF0 + 0x3EB], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
    gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPool[D_80164AF0 + 0x3EB]), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    D_80164AF0++;
    gSPDisplayList(gDisplayListHead++, D_02007F18);
    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, 320, 240);
    func_80092290(4, &D_8018E850, &D_8018E858);
    func_80092290(5, &D_8018E854, &D_8018E85C);
    func_8009C918();
    func_80099A70();
    func_80099E54();
    func_800A8230();
    func_80099AEC();
    func_80099EC4();
    func_8009CA2C();
    gSPDisplayList(gDisplayListHead++, D_02007F48);
    D_80164AF0 = 0;
}

void func_800940EC(s32 arg0) {
    gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, 320, 240);
    guOrtho(&gGfxPool->mtxPool[D_80164AF0 + 0x3EB], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
    gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPool[D_80164AF0 + 0x3EB]), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    D_80164AF0++;
    gSPDisplayList(gDisplayListHead++, D_02007F18);
    func_80092290(4, &D_8018E850, &D_8018E858);
    func_80092290(5, &D_8018E854, &D_8018E85C);
    func_80092148();
    func_80099A70();
    func_80099E54();
    func_800A8230();
    func_80099AEC();
    func_80099EC4();
    func_8009CA6C(arg0);
    gSPDisplayList(gDisplayListHead++, D_02007F48);
    func_80057CE4();
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
extern ? D_06009410;

void func_800942D0(void) {
    ? *sp6C;
    Gfx *temp_v0;
    Gfx *temp_v0_10;
    Gfx *temp_v0_11;
    Gfx *temp_v0_12;
    Gfx *temp_v0_13;
    Gfx *temp_v0_14;
    Gfx *temp_v0_15;
    Gfx *temp_v0_16;
    Gfx *temp_v0_2;
    Gfx *temp_v0_3;
    Gfx *temp_v0_4;
    Gfx *temp_v0_5;
    Gfx *temp_v0_6;
    Gfx *temp_v0_7;
    Gfx *temp_v0_8;
    Gfx *temp_v0_9;
    Mtx *temp_s1;
    Mtx *temp_s1_2;
    Mtx *temp_s1_3;
    Mtx *temp_s4;
    Mtx *temp_s4_2;
    s32 temp_s3;
    Mtx *phi_s1;
    s32 phi_s2;
    f32 phi_f26;
    s32 phi_s5;

    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->words.w0 = 0x01030040;
    temp_v0->words.w1 = (u32) gGfxPool;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->words.w0 = 0x01020040;
    temp_s1 = &gGfxPool->mtxPool[0x32B];
    temp_v0_2->words.w1 = (u32) &gGfxPool->mtxPool[7];
    guRotate(temp_s1, D_8018EDC8, 1.0f, 0.0f, 0.0f);
    temp_s4 = temp_s1 + 0x40;
    guRotate(temp_s4, D_8018EDCC, 0.0f, 1.0f, 0.0f);
    guScale(temp_s1 + 0x80, 1.0f, 1.0f, (bitwise s32) D_8018EDC4);
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->words.w1 = (u32) temp_s1;
    temp_v0_3->words.w0 = 0x01000040;
    temp_v0_4 = gDisplayListHead;
    temp_s1_2 = temp_s4 + 0x40;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->words.w1 = (u32) temp_s4;
    temp_v0_4->words.w0 = 0x01000040;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->words.w1 = (u32) temp_s1_2;
    temp_v0_5->words.w0 = 0x01040040;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->words.w0 = 0xB900031D;
    temp_v0_6->words.w1 = 0x552078;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->words.w1 = 0;
    temp_v0_7->words.w0 = 0xFB000000;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->words.w1 = (u32) D_02007F60;
    temp_v0_8->words.w0 = 0x06000000;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->words.w1 = 0;
    temp_v0_9->words.w0 = 0xBD000000;
    phi_s1 = temp_s1_2 + 0x40;
    phi_s2 = 0;
    phi_s5 = 0xC0;
    if (0.0f < 0.0f) {
        phi_f26 = 3.0f;
        if (10.0f < 3.0f) {
            phi_f26 = 10.0f;
        }
        sp6C = &D_06009410;
        do {
            guRotate(phi_s1, 0.0f, 1.0f, 0.0f, 0.0f);
            temp_s3 = phi_s2 + 1;
            temp_s4_2 = phi_s1 + 0x40;
            guRotate(temp_s4_2, (f32) temp_s3 * 0.0f * phi_f26, 0.0f, 1.0f, 0.0f);
            guScale(phi_s1 + 0x80, 1.0f, 1.0f, 0x40000000);
            temp_v0_10 = gDisplayListHead;
            gDisplayListHead = temp_v0_10 + 8;
            temp_v0_10->words.w1 = (u32) phi_s1;
            temp_v0_10->words.w0 = 0x01040040;
            temp_v0_11 = gDisplayListHead;
            temp_s1_3 = temp_s4_2 + 0x40;
            gDisplayListHead = temp_v0_11 + 8;
            temp_v0_11->words.w1 = (u32) temp_s4_2;
            temp_v0_11->words.w0 = 0x01000040;
            temp_v0_12 = gDisplayListHead;
            gDisplayListHead = temp_v0_12 + 8;
            temp_v0_12->words.w1 = (u32) temp_s1_3;
            temp_v0_12->words.w0 = 0x01000040;
            temp_v0_13 = gDisplayListHead;
            gDisplayListHead = temp_v0_13 + 8;
            temp_v0_13->words.w1 = 0x5049D8;
            temp_v0_13->words.w0 = 0xB900031D;
            temp_v0_14 = gDisplayListHead;
            gDisplayListHead = temp_v0_14 + 8;
            temp_v0_14->words.w1 = phi_s5 & 0xFF;
            temp_v0_14->words.w0 = 0xFB000000;
            temp_v0_15 = gDisplayListHead;
            gDisplayListHead = temp_v0_15 + 8;
            temp_v0_15->words.w0 = 0x06000000;
            temp_v0_15->words.w1 = (u32) sp6C;
            temp_v0_16 = gDisplayListHead;
            gDisplayListHead = temp_v0_16 + 8;
            temp_v0_16->words.w1 = 0;
            temp_v0_16->words.w0 = 0xBD000000;
            phi_s1 = temp_s1_3 + 0x40;
            phi_s2 = temp_s3;
            phi_s5 += -0x10;
        } while (temp_s3 != 0xC);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800942D0.s")
#endif

void func_80094660(struct GfxPool *arg0, s32 unused) {
    u16 perspNorm;
    move_segment_table_to_dmem();
    gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
    guPerspective(&arg0->mtxPool[0], &perspNorm, 45.0f, 1.3333334f, 100.0f, 12800.0f, 1.0f);
    gDPHalf1(gDisplayListHead++, perspNorm);
    guLookAt(&arg0->mtxPool[7], 0.0f, 0.0f, (f32) D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
    func_800942D0();
    gDPPipeSync(gDisplayListHead++);
    gDPSetTexturePersp(gDisplayListHead++, G_TP_NONE);
    gDPSetTextureFilter(gDisplayListHead++, G_TF_BILERP);
}

void func_800947B4(struct GfxPool *arg0, s32 unused) {
    u16 perspNorm;
    move_segment_table_to_dmem();
    guPerspective(&arg0->mtxPool[1], &perspNorm, 45.0f, 1.3333334f, 100.0f, 12800.0f, 1.0f);
    gDPHalf1(gDisplayListHead++, perspNorm);
    guLookAt(&arg0->mtxPool[8], 0.0f, 0.0f, (f32) D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
    guRotate(&arg0->mtxPool[0x32B], D_8018EDC8, 1.0f, 0, 0);
    guRotate(&arg0->mtxPool[0x32C], D_8018EDCC, 0, 1.0f, 0);
    guRotate(&arg0->mtxPool[0x32D], D_8018EDD0, 0, 0, 1.0f);
    guScale(&arg0->mtxPool[0x32E], D_8018EDC4, D_8018EDC4, D_8018EDC4);
    guTranslate(&arg0->mtxPool[0x32F], D_8018EDD4, D_8018EDD8, D_8018EDDC);
    gSPMatrix(gDisplayListHead++, &arg0->mtxPool[1],     G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    gSPMatrix(gDisplayListHead++, &arg0->mtxPool[8],     G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
    gSPMatrix(gDisplayListHead++, &arg0->mtxPool[0x32B], G_MTX_NOPUSH | G_MTX_MUL  | G_MTX_MODELVIEW);
    gSPMatrix(gDisplayListHead++, &arg0->mtxPool[0x32C], G_MTX_NOPUSH | G_MTX_MUL  | G_MTX_MODELVIEW);
    gSPMatrix(gDisplayListHead++, &arg0->mtxPool[0x32D], G_MTX_NOPUSH | G_MTX_MUL  | G_MTX_MODELVIEW);
    gSPMatrix(gDisplayListHead++, &arg0->mtxPool[0x32E], G_MTX_NOPUSH | G_MTX_MUL  | G_MTX_MODELVIEW);
    gSPMatrix(gDisplayListHead++, &arg0->mtxPool[0x32F], G_MTX_NOPUSH | G_MTX_MUL  | G_MTX_MODELVIEW);
    gSPDisplayList(gDisplayListHead++, D_02007FC8);
    func_800B0004();
    gSPDisplayList(gDisplayListHead++, D_02007650);
}

#ifdef NON_MATCHING
// Non-matching due to .rodata diffs resulting from the switch/case
// jump table
void func_80094A64(Mtx *arg0) {
    D_8018D120 = 0;
    D_80164AF0 = 0;
    gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&D_802B8880));
    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, 320, 240);
    guOrtho(arg0, 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
    gSPMatrix(gDisplayListHead++, arg0, G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    gSPDisplayList(gDisplayListHead++, D_02007650);
    func_80094C60();
    func_80092290(4, &D_8018E850, &D_8018E858);
    func_80092290(5, &D_8018E854, &D_8018E85C);
    func_80099A70();
    func_8009C918();
    switch (gMenuSelection) {
    case START_MENU:
        func_80095574();
        func_80093E40();
        break;
    case OPTIONS_MENU:
    case DATA_MENU:
    case COURSE_DATA_MENU:
    case LOGO_INTRO_MENU:
    case CONTROLLER_PAK_MENU:
    case MAIN_MENU:
    case PLAYER_SELECT_MENU:
    case COURSE_SELECT_MENU:
        func_800A8230();
        func_80099AEC();
        break;
    }
    func_8009CA2C();
    D_8018E7A8 += 1;
    gDPPipeSync(gDisplayListHead++);
    gSPDisplayList(gDisplayListHead++, D_020076B0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80094A64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80092258();                                  /* extern */
? func_80099110();                                  /* extern */
? func_8009A344();                                  /* extern */
? func_8009B938();                                  /* extern */
? func_8009DF4C(?);                                 /* extern */
? func_8009DF6C(?);                                 /* extern */
? func_8009E620();                                  /* extern */
? add_8018D9E0_entry(?, ?, ?, ?);                        /* extern */
? func_800B3F74(u32);                               /* extern */
? func_800B5F30();                                  /* extern */
? func_800B6014();                                  /* extern */

void func_80094C60(void) {
    s32 temp_v0;
    u32 temp_t7;
    s32 phi_v0;

    if (D_800E86A4 != 0) {
        func_80099110();
        func_8009A344();
        func_8009E620();
        func_8009B938();
        func_80092258();
        func_800B5F30();
        func_800B6014();
        func_800B3F74(gMenuSelection);
        temp_t7 = gMenuSelection;
        switch (temp_t7) {
        case OPTIONS_MENU:
            add_8018D9E0_entry(0x23, 0, 0, 2);
            add_8018D9E0_entry(0xF1, 0, 0, 4);
            add_8018D9E0_entry(0xF0, 0, 0, 2);
            break;
        case DATA_MENU:
            add_8018D9E0_entry(0x23, 0, 0, 2);
            add_8018D9E0_entry(0x8C, 0, 0, 6);
            add_8018D9E0_entry(0x7C, 0, 0, 6);
            add_8018D9E0_entry(0x7D, 0, 0, 6);
            add_8018D9E0_entry(0x7E, 0, 0, 6);
            add_8018D9E0_entry(0x7F, 0, 0, 6);
            add_8018D9E0_entry(0x80, 0, 0, 6);
            add_8018D9E0_entry(0x81, 0, 0, 6);
            add_8018D9E0_entry(0x82, 0, 0, 6);
            add_8018D9E0_entry(0x83, 0, 0, 6);
            add_8018D9E0_entry(0x84, 0, 0, 6);
            add_8018D9E0_entry(0x85, 0, 0, 6);
            add_8018D9E0_entry(0x86, 0, 0, 6);
            add_8018D9E0_entry(0x87, 0, 0, 6);
            add_8018D9E0_entry(0x88, 0, 0, 6);
            add_8018D9E0_entry(0x89, 0, 0, 6);
            add_8018D9E0_entry(0x8A, 0, 0, 6);
            add_8018D9E0_entry(0x8B, 0, 0, 6);
            add_8018D9E0_entry(0x8D, 0, 0, 8);
            break;
        case COURSE_DATA_MENU:
            add_8018D9E0_entry(0xE6, 0, 0, 8);
            add_8018D9E0_entry(0xE7, 0, 0, 8);
            add_8018D9E0_entry(0xE8, 0, 0, 8);
            add_8018D9E0_entry(0xE9, 0, 0, 8);
            add_8018D9E0_entry(0xEA, 0, 0, 8);
            break;
        case LOGO_INTRO_MENU:
            add_8018D9E0_entry(0xFA, 0, 0, 0);
            break;
        case CONTROLLER_PAK_MENU:
            add_8018D9E0_entry(0xDA, 0, 0, 0);
            add_8018D9E0_entry(0xD2, 0, 0, 4);
            add_8018D9E0_entry(0xD4, 0, 0, 6);
            add_8018D9E0_entry(0xD3, 0, 0, 8);
            add_8018D9E0_entry(0xD5, 0, 0, 0xA);
            add_8018D9E0_entry(0xD6, 0, 0, 0xA);
            add_8018D9E0_entry(0xD7, 0, 0, 0xA);
            add_8018D9E0_entry(0xD8, 0, 0, 0xA);
            add_8018D9E0_entry(0xD9, 0, 0, 0xA);
            break;
        case START_MENU:
            add_8018D9E0_entry(2, 0, 0, 4);
            add_8018D9E0_entry(1, 0, 0, 0);
            add_8018D9E0_entry(0xFB, 0, 0, 0);
            if ((gControllerBits & 1) != 0) {
                add_8018D9E0_entry(3, 0, 0, 2);
            } else {
                add_8018D9E0_entry(4, 0, 0, 2);
            }
            add_8018D9E0_entry(5, 0, 0, 6);
            D_800DC51C = 0;
            D_8018EE08 = 0;
            break;
        case MAIN_MENU:
            add_8018D9E0_entry(0x23, 0, 0, 2);
            add_8018D9E0_entry(0xA, 0x15E, 0x11, 6);
            add_8018D9E0_entry(0xE, 0x15E, 0x3E, 6);
            add_8018D9E0_entry(0xD, 0x15E, 0x3E, 6);
            add_8018D9E0_entry(0xC, 0x15E, 0x3E, 6);
            add_8018D9E0_entry(0xB, 0x15E, 0x3E, 6);
            add_8018D9E0_entry(0xF, 0x15E, 0xC8, 6);
            add_8018D9E0_entry(0x11, 0x15E, 0xC8, 6);
            add_8018D9E0_entry(0x10, 0x15E, 0xC8, 6);
            if (func_800B555C() != 0) {
                add_8018D9E0_entry(0x15, 0, 0, 6);
            }
            add_8018D9E0_entry(0x14, 0, 0, 6);
            add_8018D9E0_entry(0x13, 0, 0, 6);
            add_8018D9E0_entry(0x12, 0, 0, 6);
            add_8018D9E0_entry(0x19, 0, 0, 6);
            add_8018D9E0_entry(0x18, 0, 0, 6);
            add_8018D9E0_entry(0x1B, 0, 0, 0xC);
            break;
        case PLAYER_SELECT_MENU:
            add_8018D9E0_entry(0x24, 0, 0, 2);
            add_8018D9E0_entry(0x2A, 0, 0, 6);
            add_8018D9E0_entry(0x33, 0, 0, 6);
            add_8018D9E0_entry(0x2B, 0, 0, 8);
            add_8018D9E0_entry(0x2C, 0, 0, 8);
            add_8018D9E0_entry(0x2D, 0, 0, 6);
            add_8018D9E0_entry(0x2E, 0, 0, 6);
            add_8018D9E0_entry(0x2F, 0, 0, 6);
            add_8018D9E0_entry(0x30, 0, 0, 6);
            add_8018D9E0_entry(0x31, 0, 0, 6);
            add_8018D9E0_entry(0x32, 0, 0, 8);
            add_8018D9E0_entry(0x34, 0, 0, 0xC);
            add_8018D9E0_entry(0x35, 0, 0, 0xC);
            add_8018D9E0_entry(0x36, 0, 0, 0xC);
            add_8018D9E0_entry(0x37, 0, 0, 0xC);
            break;
        case COURSE_SELECT_MENU:
            add_8018D9E0_entry(0x25, 0, 0, 2);
            add_8018D9E0_entry(0x52, 0, 0, 6);
            if (gModeSelection != BATTLE) {
                add_8018D9E0_entry(0x53, 0, 0, 4);
                add_8018D9E0_entry(0x54, 0, 0, 4);
                add_8018D9E0_entry(0x55, 0, 0, 4);
                add_8018D9E0_entry(0x56, 0, 0, 4);
                add_8018D9E0_entry(0x58, 0, 0, 6);
                add_8018D9E0_entry(0x59, 0, 0, 6);
                add_8018D9E0_entry(0x5A, 0, 0, 6);
                add_8018D9E0_entry(0x5B, 0, 0, 6);
            } else {
                add_8018D9E0_entry(0x5C, 0, 0, 6);
                add_8018D9E0_entry(0x6E, 0, 0, 6);
            }
            add_8018D9E0_entry(0x64, 0, 0, 6);
            add_8018D9E0_entry(0x5F, 0, 0, 6);
            add_8018D9E0_entry(0x60, 0, 0, 6);
            add_8018D9E0_entry(0x61, 0, 0, 6);
            add_8018D9E0_entry(0x62, 0, 0, 6);
            add_8018D9E0_entry(0x5D, 0, 0, 6);
            add_8018D9E0_entry(0x5E, 0, 0, 8);
            temp_v0 = gModeSelection;
            phi_v0 = temp_v0;
            if (temp_v0 == TIME_TRIALS) {
                add_8018D9E0_entry(0x65, 0, 0, 8);
                add_8018D9E0_entry(0x66, 0, 0, 8);
                add_8018D9E0_entry(0x69, 0, 0, 8);
                phi_v0 = gModeSelection;
            }
            if (phi_v0 == GRAND_PRIX) {
                add_8018D9E0_entry(0x68, 0, 0, 8);
                add_8018D9E0_entry(0x67, 0, 0, 5);
            }
            break;
        }
        if (D_800E86A4 != 2) {
            func_8009DF4C(0x14);
        } else {
            func_8009DF6C(0x14);
        }
        D_800E86A4 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80094C60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? debug_print_str2(s32, ?, ? *, s16);               /* extern */
? func_80057778();                                  /* extern */
? func_8009E230();                                  /* extern */
? func_800A8230();                                  /* extern */
? func_800CA0A0();                                  /* extern */
? load_debug_font();                                /* extern */
? play_sound2(?);                                   /* extern */
? print_str_num(?, ?, ? *, s16);                    /* extern */
static ? D_020076E0;                                /* unable to generate initializer */
static ? gDebugCourseNames;                                /* unable to generate initializer; const */
static ? gDebugCharacterNames;                                /* unable to generate initializer; const */
static ? gDebugScreenModeNames;                                /* unable to generate initializer; const */
static ? gDebugSoundModeNames;                                /* unable to generate initializer; const */
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_80095574(void) {
    Gfx *temp_v1;
    s16 temp_a3;
    s16 temp_a3_2;
    s32 temp_v0_2;
    s8 temp_t8;
    s8 temp_v0;
    s32 phi_v0;
    s8 phi_v0_2;
    s32 phi_v0_3;

    if ((D_8018EE0C < 3) || (D_8018E7B0 != 0)) {
        func_800A8230();
    }
    temp_v0 = gDebugMenuSelection;
    phi_v0_2 = temp_v0;
    if (temp_v0 >= DEBUG_MENU_DEBUG_MODE) {
        load_debug_font();
        debug_print_str2(0x50, 0x64, "debug_mode");
        temp_t8 = gDebugMenuSelection;
        // Draw asterisk next to selected debug menu option
        switch (temp_t8) {
        case DEBUG_MENU_DEBUG_MODE:
            debug_print_str2(0x46, 0x64, "*");
            break;
        case DEBUG_MENU_COURSE:
            debug_print_str2(0x46, 0x6E, "*");
            break;
        case DEBUG_MENU_SCREEN_MODE:
            debug_print_str2(0x46, 0x78, "*");
            break;
        case DEBUG_MENU_PLAYER:
            debug_print_str2(0x46, 0x82, "*");
            break;
        case DEBUG_MENU_SOUND_MODE:
            debug_print_str2(0x46, 0x8C, "*");
            break;
        case DEBUG_MENU_GIVE_ALL_GOLD_CUP:
            debug_print_str2(0x46, 0x96, "*");
            break;
        }
        if (gEnableDebugMode != 0) {
            debug_print_str2(0xAA, 0x64, "on");
        } else {
            debug_print_str2(0xAA, 0x64, "off");
        }
        temp_a3 = gCurrentCourseId;
        if ((temp_a3 >= 0x14) || (temp_a3 < 0)) {
            gCurrentCourseId = 0;
        }
        print_str_num(0x50, 0x6E, "map_number", gCurrentCourseId);
        temp_a3_2 = gCurrentCourseId;
        if (temp_a3_2 < 0xA) {
            phi_v0 = 0;
        } else {
            phi_v0 = 8;
        }
        debug_print_str2(phi_v0 + 0xB9, 0x6E, gDebugCourseNames[temp_a3_2], temp_a3_2);
        debug_print_str2(0x50, 0x78, "screen_mode");
        debug_print_str2(0xAA, 0x78, *(&gDebugScreenModeNames + (D_8018EDF1 * 4)));
        debug_print_str2(0x50, 0x82, "player");
        debug_print_str2(0xAA, 0x82, *(&gDebugCharacterNames + (gCharacterSelections * 4)));
        debug_print_str2(0x50, 0x8C, "sound mode");
        debug_print_str2(0xAA, 0x8C, gDebugSoundModeNames[gSoundMode]);
        if (gDebugMenuSelection == DEBUG_MENU_GIVE_ALL_GOLD_CUP) {
            debug_print_str2(0x50, 0x96, "push b to get all goldcup");
        }
        func_80057778();
        phi_v0_2 = gDebugMenuSelection;
    }
    if (phi_v0_2 == DEBUG_MENU_DISABLED) {
        gMenuTimingCounter += 1;
    } else {
        gMenuTimingCounter = 3;
    }
    temp_v0_2 = gMenuTimingCounter;
    phi_v0_3 = temp_v0_2;
    if (temp_v0_2 == 2) {
        play_sound2(0x49009009);
        phi_v0_3 = gMenuTimingCounter;
    }
    if (phi_v0_3 >= 0x12D) {
        func_8009E230();
        func_800CA0A0();
    }
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->words.w0 = 0x6000000;
    temp_v1->words.w1 = &D_020076E0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095574.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80098C18(s32, s32, s32, s32, s32, s32); // extern
extern s32 D_8018E7A8;
extern s32 gDisplayListHead;

void func_800958D4(s32 arg0, s32 arg4, s32 arg5) {
    s32 temp_lo;
    s32 phi_v0;
    s32 phi_v0_2;

    temp_lo = ((D_8018E7A8 % arg5) << 9) / arg5;
    phi_v0 = temp_lo;
    if (temp_lo >= 0x101) {
        phi_v0 = 0x200 - temp_lo;
    }
    phi_v0_2 = phi_v0;
    if (phi_v0 >= 0x100) {
        phi_v0_2 = 0xFF;
    }
    gDisplayListHead = func_80098C18(gDisplayListHead, arg4, phi_v0_2, phi_v0_2, phi_v0_2, 0xFF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800958D4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800958D4(s32, s32); // extern

void func_800959A0(s32 arg4) {
    func_800958D4(arg4, 0x40);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800959A0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800958D4(s32, s32); // extern

void func_800959CC(s32 arg4) {
    func_800958D4(arg4, 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800959CC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_02007BB8;
extern ? D_800E84CC;
extern ? D_800E84EC;
extern ? D_800E850C;
extern s8 gTextColor;
extern s32 gGlobalTimer;

void *func_800959F8(void *arg0, s32 arg1) {
    s8 phi_v1;

    if (gTextColor < 4) {
        phi_v1 = gTextColor;
    } else {
        phi_v1 = ((gTextColor * 2) + (gGlobalTimer % 2)) - 4;
    }
    if (arg1 == &D_02007BB8) {
        arg0->unk0 = 0x6000000;
        arg0->unk4 = D_800E84CC[phi_v1];
        return arg0 + 8;
    }
    if (arg1 == 0x2007CD8) {
        arg0->unk0 = 0x6000000;
        arg0->unk4 = D_800E84EC[phi_v1];
        return arg0 + 8;
    }
    if (arg1 == 0x2007DF8) {
        arg0->unk0 = 0x6000000;
        arg0->unk4 = D_800E850C[phi_v1];
        arg0 += 8;
    }
    return arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800959F8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80095AE0(void *arg0, f32 arg1, f32 arg2, f32 arg3, f32 arg4) {
    s32 sp14;
    s32 sp10;
    s32 spC;
    s32 sp8;
    s32 *temp_a2;
    s32 *temp_a3;
    s32 *temp_v0_2;
    s32 *temp_v1;
    s32 temp_v0;
    void *phi_v1;
    s32 phi_v0;

    phi_v1 = arg0;
    phi_v0 = 0;
    do {
        temp_v0 = phi_v0 + 4;
        phi_v1->unk0 = 0;
        phi_v1->unk4 = 0;
        phi_v1->unk8 = 0;
        phi_v1->unkC = 0;
        phi_v1 += 0x10;
        phi_v0 = temp_v0;
    } while (temp_v0 != 0x10);
    temp_v0_2 = &sp14;
    temp_v1 = &sp10;
    temp_a2 = &spC;
    temp_a3 = &sp8;
    sp14 = arg3 * 65536.0f;
    sp10 = arg4 * 65536.0f;
    spC = arg1 * 65536.0f;
    sp8 = arg2 * 65536.0f;
    arg0->unk0 = temp_v0_2->unk0;
    arg0->unk14 = 1;
    arg0->unkA = temp_v1->unk0;
    arg0->unk18 = temp_a2->unk0;
    arg0->unk1E = 1;
    arg0->unk1A = temp_a3->unk0;
    arg0->unk20 = temp_v0_2->unk2;
    arg0->unk2A = temp_v1->unk2;
    arg0->unk38 = temp_a2->unk2;
    arg0->unk3A = temp_a3->unk2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095AE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959F8(void *, ? *, void *, s32); // extern
? func_80095AE0(void *, s32, s32, s32, f32); // extern
? func_800CF774(? *); // extern
extern ? D_02007BB8;
extern ? D_02007CD8;
extern ? D_02007DF8;
extern ? D_800F0BCC;
extern ? D_800F0BEC;
extern s16 D_80164AF0;

void *func_80095BD0(void *arg0, s32 arg1, s32 arg2, s32 arg3, u32 arg4, s32 arg5, s32 arg6, f32 arg7) {
    void *sp28;
    s16 temp_v0;
    s32 temp_a3;
    s32 temp_v0_2;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    ? *phi_a1;

    temp_v0 = D_80164AF0;
    if (temp_v0 < 0x2F7) {
        sp28 = gGfxPool + (temp_v0 << 6) + 0xFAC0;
        if (temp_v0 < 0) {
            func_800CF774(&D_800F0BCC);
        }
        func_80095AE0(sp28, arg2, arg3, arg6, arg7);
        arg0->unk0 = 0x1020040;
        arg0->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
        temp_s0_2 = arg0 + 8;
        D_80164AF0 = D_80164AF0 + 1;
        temp_s0_2->unk0 = (((arg4 >> 1) - 1) & 0xFFF) | 0xFD880000;
        temp_s0_3 = temp_s0_2 + 8;
        temp_s0_2->unk4 = arg1;
        temp_a3 = (((((arg4 + 1) >> 1) + 7) >> 3) & 0x1FF) << 9;
        temp_s0_4 = temp_s0_3 + 8;
        temp_s0_3->unk0 = temp_a3 | 0xF5880000;
        temp_s0_3->unk4 = 0x7000000;
        temp_s0_5 = temp_s0_4 + 8;
        temp_s0_4->unk0 = 0xE6000000;
        temp_s0_4->unk4 = 0;
        temp_s0_5->unk0 = 0xF4000000;
        temp_v0_2 = (arg5 * 4) & 0xFFF;
        temp_s0_6 = temp_s0_5 + 8;
        temp_s0_5->unk4 = (((arg4 * 2) & 0xFFF) << 0xC) | 0x7000000 | temp_v0_2;
        temp_s0_7 = temp_s0_6 + 8;
        temp_s0_6->unk0 = 0xE7000000;
        temp_s0 = temp_s0_7 + 8;
        temp_s0_6->unk4 = 0;
        temp_s0_7->unk4 = 0;
        temp_s0_7->unk0 = temp_a3 | 0xF5800000;
        temp_s0->unk0 = 0xF2000000;
        temp_s0->unk4 = (((arg4 * 4) & 0xFFF) << 0xC) | temp_v0_2;
        if (arg4 != 0x10) {
            if (arg4 != 0x1A) {
                if (arg4 != 0x1E) {
                    phi_a1 = &D_02007CD8;
                } else {
                    phi_a1 = &D_02007DF8;
                }
            } else {
                phi_a1 = &D_02007BB8;
            }
        } else {
            phi_a1 = &D_02007CD8;
        }
        return func_800959F8(temp_s0 + 8, phi_a1, temp_s0, temp_a3);
    }
    func_800CF774(&D_800F0BEC);
    return arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095BD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80095E10(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA, u32 argB, u32 argC) {
    s32 sp7C;
    s32 sp70;
    s32 sp6C;
    s32 sp68;
    s32 sp64;
    u32 sp34;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_lo;
    s32 temp_s2;
    s32 temp_s4;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_t6;
    s32 temp_t7_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_s5;
    u32 temp_t6_2;
    u32 temp_t7;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    u32 phi_t0;
    s32 phi_t0_2;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_a2;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_a1;
    s32 phi_a2_2;
    s32 phi_s3;
    u32 phi_v1;
    s32 phi_t0_3;
    s32 phi_a1_2;
    s32 phi_t1;
    void *phi_a0;
    s32 phi_t2;
    s32 phi_s2;
    s32 phi_t4;
    s32 phi_a3;
    s32 phi_t0_4;
    s32 phi_v1_2;
    s32 phi_a2_3;
    s32 phi_s1;
    s32 phi_s6;
    s32 phi_s7;
    s32 phi_fp;
    void *phi_a0_2;
    s32 phi_a2_4;
    void *phi_a0_3;
    s32 phi_s4;
    s32 phi_ra;
    void *phi_a0_4;

    sp68 = 0;
    sp64 = 0;
    phi_t0 = 1;
    phi_t0_2 = 1;
    phi_a0_2 = arg0;
    phi_a0_3 = arg0;
    if (argB >= 2) {
        do {
            temp_t7 = phi_t0 * 2;
            phi_t0 = temp_t7;
            phi_t0_2 = temp_t7;
        } while (temp_t7 < argB);
    }
    temp_lo = 0x400 / phi_t0_2;
    phi_a2 = temp_lo;
    phi_t0_3 = phi_t0_2;
    if (argC < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (argC < temp_v0);
        sp6C = phi_v0;
        phi_a2 = phi_v0;
    }
    phi_v0_2 = phi_t0_2;
    phi_a2_2 = phi_a2;
    if (phi_t0_2 >= 2) {
        do {
            temp_t7_2 = phi_v0_2 / 2;
            sp68 += 1;
            phi_v0_2 = temp_t7_2;
        } while (temp_t7_2 >= 2);
    }
    phi_v0_3 = phi_a2;
    if (phi_a2 >= 2) {
        do {
            temp_t6 = phi_v0_3 / 2;
            sp64 += 1;
            phi_v0_3 = temp_t6;
        } while (temp_t6 >= 2);
    }
    phi_a1 = arg8;
    if (arg8 < 0) {
        arg4 -= arg8;
        phi_a1 = 0;
    } else if (((arg6 - arg4) + arg8) >= 0x141) {
        arg6 = (arg4 - arg8) + 0x140;
    }
    phi_v0_4 = arg5;
    phi_v1 = arg6;
    phi_ra = arg9;
    if (arg9 < 0) {
        phi_v0_4 = arg5 - arg9;
        phi_ra = 0;
    } else if (((arg7 - arg5) + arg9) >= 0xF1) {
        arg7 = (arg5 - arg9) + 0xF0;
    }
    if (arg6 < arg4) {

    } else if (arg7 < phi_v0_4) {

    } else {
        sp7C = phi_a1;
        phi_s3 = phi_v0_4;
        if (phi_v0_4 < arg7) {
            arg8 = phi_a1;
loop_24:
            temp_t6_2 = phi_a2_2 + phi_s3;
            sp34 = temp_t6_2;
            phi_a0 = phi_a0_3;
            phi_a0_2 = phi_a0_3;
            phi_a2_4 = phi_a2_2;
            phi_a0_4 = phi_a0_3;
            if (arg7 < temp_t6_2) {
                temp_s4 = arg7 - phi_s3;
                phi_s4 = temp_s4;
                if (temp_s4 != 0) {
                    goto block_28;
                }
            } else {
                phi_s4 = phi_a2_2;
block_28:
                phi_a1_2 = arg4;
                if (arg4 < phi_v1) {
                    arg6 = phi_v1;
                    sp6C = phi_a2_2;
                    sp70 = phi_t0_3;
loop_30:
                    temp_s5 = sp70 + phi_a1_2;
                    phi_s2 = sp70;
                    phi_v1 = arg6;
                    phi_a0_4 = phi_a0;
                    if (arg6 < temp_s5) {
                        temp_s2 = arg6 - phi_a1_2;
                        phi_s2 = temp_s2;
                        if (temp_s2 == 0) {
                            phi_a2_4 = sp6C;
                            phi_t0_3 = sp70;
                        } else {
                            arg6 = arg6;
                            temp_v0_2 = (arg1 & 7) << 0x15;
                            temp_a2 = (sp68 & 0xF) * 0x10;
                            temp_v1 = (sp64 & 0xF) << 0xE;
                            phi_t1 = temp_v0_2 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                            phi_t2 = temp_v0_2 | 0xF5000000 | 0x100000;
                            phi_t4 = temp_v1 | 0x7000000 | temp_a2;
                            phi_a3 = (phi_s3 * 4) & 0xFFF;
                            phi_t0_4 = ((phi_s3 + phi_s4) * 4) & 0xFFF;
                            phi_v1_2 = temp_v1;
                            phi_a2_3 = temp_a2;
                            phi_s1 = ((phi_ra + phi_s4) * 4) & 0xFFF;
                            phi_s6 = (phi_ra * 4) & 0xFFF;
                            phi_s7 = (phi_s3 << 5) & 0xFFFF;
                            phi_fp = (arg2 << 0x10) | (arg3 & 0xFFFF);
                            goto block_35;
                        }
                    } else {
                        temp_v0_3 = (arg1 & 7) << 0x15;
                        temp_a2_2 = (sp68 & 0xF) * 0x10;
                        temp_v1_2 = (sp64 & 0xF) << 0xE;
                        phi_t1 = temp_v0_3 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                        phi_t2 = temp_v0_3 | 0xF5000000 | 0x100000;
                        phi_t4 = temp_v1_2 | 0x7000000 | temp_a2_2;
                        phi_a3 = (phi_s3 * 4) & 0xFFF;
                        phi_t0_4 = ((phi_s3 + phi_s4) * 4) & 0xFFF;
                        phi_v1_2 = temp_v1_2;
                        phi_a2_3 = temp_a2_2;
                        phi_s1 = ((phi_ra + phi_s4) * 4) & 0xFFF;
                        phi_s6 = (phi_ra * 4) & 0xFFF;
                        phi_s7 = (phi_s3 << 5) & 0xFFFF;
                        phi_fp = (arg2 << 0x10) | (arg3 & 0xFFFF);
block_35:
                        phi_a0->unk0 = phi_t1;
                        temp_a2_3 = phi_a1_2 + phi_s2;
                        phi_a0->unk4 = argA;
                        temp_a0 = phi_a0 + 8;
                        temp_t3 = phi_t2 | ((((((temp_a2_3 - phi_a1_2) * 2) + 9) >> 3) & 0x1FF) << 9);
                        temp_a0_2 = temp_a0 + 8;
                        temp_t1 = ((phi_a1_2 * 4) & 0xFFF) << 0xC;
                        temp_a0->unk0 = temp_t3;
                        temp_a0->unk4 = phi_t4;
                        temp_a0_2->unk0 = 0xE6000000;
                        temp_a0_3 = temp_a0_2 + 8;
                        temp_t2 = ((temp_a2_3 * 4) & 0xFFF) << 0xC;
                        temp_a0_2->unk4 = 0;
                        temp_a0_3->unk0 = temp_t1 | 0xF4000000 | phi_a3;
                        temp_a0_4 = temp_a0_3 + 8;
                        temp_a0_3->unk4 = temp_t2 | 0x7000000 | phi_t0_4;
                        temp_a0_5 = temp_a0_4 + 8;
                        temp_a0_4->unk0 = 0xE7000000;
                        temp_a0_4->unk4 = 0;
                        temp_a0_6 = temp_a0_5 + 8;
                        temp_a0_5->unk4 = phi_v1_2 | phi_a2_3;
                        temp_a0_5->unk0 = temp_t3;
                        temp_a0_6->unk4 = temp_t2 | phi_t0_4;
                        temp_a0_6->unk0 = temp_t1 | 0xF2000000 | phi_a3;
                        temp_a0_7 = temp_a0_6 + 8;
                        temp_a0_7->unk0 = ((((arg8 + phi_s2) * 4) & 0xFFF) << 0xC) | 0xE4000000 | phi_s1;
                        temp_a0_8 = temp_a0_7 + 8;
                        temp_a0_7->unk4 = (((arg8 * 4) & 0xFFF) << 0xC) | phi_s6;
                        temp_a0_8->unk0 = 0xB3000000;
                        temp_a0_9 = temp_a0_8 + 8;
                        temp_a0_8->unk4 = (phi_a1_2 << 0x15) | phi_s7;
                        temp_a0_9->unk0 = 0xB2000000;
                        temp_a0_9->unk4 = phi_fp;
                        arg8 += sp70;
                        temp_a0_10 = temp_a0_9 + 8;
                        phi_a1_2 = temp_s5;
                        phi_a0 = temp_a0_10;
                        phi_a0_4 = temp_a0_10;
                        if (temp_s5 >= arg6) {
                            phi_a2_4 = sp6C;
                            phi_v1 = arg6;
                            phi_t0_3 = sp70;
                        } else {
                            goto loop_30;
                        }
                    }
                }
                arg8 = sp7C;
                phi_a2_2 = phi_a2_4;
                phi_s3 = sp34;
                phi_a0_2 = phi_a0_4;
                phi_a0_3 = phi_a0_4;
                phi_ra += phi_a2_4;
                if (sp34 < arg7) {
                    goto loop_24;
                }
            }
        }
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095E10.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800963F0(void *arg0, s8 arg1, s32 arg2, s32 arg3, f32 arg4, f32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA, s32 argB, s32 argC, u32 argD, u32 argE) {
    s32 sp8C;
    s32 sp78;
    s32 sp74;
    s32 sp70;
    s32 sp6C;
    u32 sp34;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f10;
    f32 temp_f8;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_fp;
    s32 temp_lo;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_t6;
    s32 temp_t7_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_s2;
    u32 temp_s4;
    u32 temp_t7;
    u32 temp_t8;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    u32 phi_t0;
    s32 phi_t0_2;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_a3;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_ra;
    s32 phi_a1;
    s32 phi_a3_2;
    s32 phi_s3;
    u32 phi_a2;
    u32 phi_v1;
    s32 phi_t0_3;
    u32 phi_a1_2;
    s32 phi_fp;
    s32 phi_t1;
    void *phi_a0;
    s32 phi_t2;
    u32 phi_s2;
    s32 phi_t4;
    s32 phi_a3_3;
    s32 phi_t0_4;
    s32 phi_s0;
    s32 phi_ra_2;
    s32 phi_s1;
    s32 phi_s5;
    s32 phi_s6;
    s32 phi_s7;
    f32 phi_f12;
    f32 phi_f18;
    u32 phi_a2_2;
    void *phi_a0_2;
    void *phi_a0_3;
    f32 phi_f0;
    f32 phi_f16;
    f32 phi_f10;
    f32 phi_f8;
    void *phi_a0_4;

    sp70 = 0;
    sp6C = 0;
    phi_t0 = 1;
    phi_t0_2 = 1;
    phi_a0_2 = arg0;
    phi_a0_3 = arg0;
    if (argD >= 2) {
        do {
            temp_t7 = phi_t0 * 2;
            phi_t0 = temp_t7;
            phi_t0_2 = temp_t7;
        } while (temp_t7 < argD);
    }
    temp_lo = 0x400 / phi_t0_2;
    phi_a3 = temp_lo;
    phi_t0_3 = phi_t0_2;
    if (argE < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (argE < temp_v0);
        sp74 = phi_v0;
        phi_a3 = phi_v0;
    }
    phi_v0_2 = phi_t0_2;
    phi_a3_2 = phi_a3;
    if (phi_t0_2 >= 2) {
        do {
            temp_t7_2 = phi_v0_2 / 2;
            sp70 += 1;
            phi_v0_2 = temp_t7_2;
        } while (temp_t7_2 >= 2);
    }
    phi_v0_3 = phi_a3;
    if (phi_a3 >= 2) {
        do {
            temp_t6 = phi_v0_3 / 2;
            sp6C += 1;
            phi_v0_3 = temp_t6;
        } while (temp_t6 >= 2);
    }
    phi_ra = argA;
    if (argA < 0) {
        arg6 -= argA;
        phi_ra = 0;
    } else {
        temp_f0 = argA + ((arg8 - arg6) * arg4);
        if (temp_f0 > 320.0f) {
            arg8 = arg8 - (temp_f0 - 320.0f);
        }
    }
    phi_v0_4 = arg7;
    phi_a1 = argB;
    phi_ra_2 = phi_ra;
    if (argB < 0) {
        phi_v0_4 = arg7 - argB;
        phi_a1 = 0;
    } else {
        temp_f0_2 = argB + ((arg9 - arg7) * arg5);
        if (temp_f0_2 > 240.0f) {
            arg9 = arg9 - (temp_f0_2 - 240.0f);
        }
    }
    phi_a2 = arg9;
    phi_v1 = arg8;
    if (arg8 < arg6) {

    } else if (arg9 < phi_v0_4) {

    } else {
        sp8C = phi_ra;
        arg2 = arg2 / arg4;
        arg3 = arg3 / arg5;
        phi_s3 = phi_v0_4;
        if (phi_v0_4 < arg9) {
            argB = phi_a1;
loop_24:
            temp_t8 = phi_a3_2 + phi_s3;
            sp34 = temp_t8;
            phi_a0 = phi_a0_3;
            phi_a2_2 = phi_a2;
            phi_a0_2 = phi_a0_3;
            phi_a0_4 = phi_a0_3;
            if (phi_a2 < temp_t8) {
                temp_fp = phi_a2 - phi_s3;
                phi_fp = temp_fp;
                if (temp_fp != 0) {
                    phi_f12 = argB;
                    phi_f18 = phi_a3_2 * arg5;
                    goto block_28;
                }
            } else {
                phi_fp = phi_a3_2;
                phi_f12 = argB;
                phi_f18 = phi_a3_2 * arg5;
block_28:
                phi_a1_2 = arg6;
                if (arg6 < phi_v1) {
                    sp74 = phi_a3_2;
                    sp78 = phi_t0_3;
loop_30:
                    temp_s4 = sp78 + phi_a1_2;
                    phi_a2_2 = arg9;
                    phi_v1 = arg8;
                    phi_a0_4 = phi_a0;
                    if (arg8 < temp_s4) {
                        temp_s2 = arg8 - phi_a1_2;
                        phi_s2 = temp_s2;
                        if (temp_s2 == 0) {
                            phi_a3_2 = sp74;
                            phi_t0_3 = sp78;
                        } else {
                            temp_v0_2 = (arg1 & 7) << 0x15;
                            temp_v1 = (sp6C & 0xF) << 0xE;
                            temp_a2 = (sp70 & 0xF) * 0x10;
                            temp_f10 = phi_fp;
                            phi_t1 = temp_v0_2 | 0xFD000000 | 0x100000 | ((argD - 1) & 0xFFF);
                            phi_t2 = temp_v0_2 | 0xF5000000 | 0x100000;
                            phi_t4 = temp_v1 | 0x7000000 | temp_a2;
                            phi_a3_3 = (phi_s3 * 4) & 0xFFF;
                            phi_t0_4 = ((phi_s3 + phi_fp) * 4) & 0xFFF;
                            phi_s0 = temp_v1 | temp_a2;
                            phi_s5 = (argB * 4) & 0xFFF;
                            phi_s6 = (phi_s3 << 5) & 0xFFFF;
                            phi_s7 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                            phi_f0 = phi_ra_2;
                            phi_f16 = sp78 * arg4;
                            phi_f10 = temp_f10;
                            if (phi_fp < 0) {
                                phi_f10 = temp_f10 + 4294967296.0f;
                            }
                            phi_s1 = ((argB + (phi_f10 * arg5)) * 4) & 0xFFF;
                            goto block_39;
                        }
                    } else {
                        temp_v0_3 = (arg1 & 7) << 0x15;
                        temp_v1_2 = (sp6C & 0xF) << 0xE;
                        temp_a2_2 = (sp70 & 0xF) * 0x10;
                        temp_f8 = phi_fp;
                        phi_t1 = temp_v0_3 | 0xFD000000 | 0x100000 | ((argD - 1) & 0xFFF);
                        phi_t2 = temp_v0_3 | 0xF5000000 | 0x100000;
                        phi_s2 = sp78;
                        phi_t4 = temp_v1_2 | 0x7000000 | temp_a2_2;
                        phi_a3_3 = (phi_s3 * 4) & 0xFFF;
                        phi_t0_4 = ((phi_s3 + phi_fp) * 4) & 0xFFF;
                        phi_s0 = temp_v1_2 | temp_a2_2;
                        phi_s5 = (argB * 4) & 0xFFF;
                        phi_s6 = (phi_s3 << 5) & 0xFFFF;
                        phi_s7 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                        phi_f0 = phi_ra_2;
                        phi_f16 = sp78 * arg4;
                        phi_f8 = temp_f8;
                        if (phi_fp < 0) {
                            phi_f8 = temp_f8 + 4294967296.0f;
                        }
                        phi_s1 = ((argB + (phi_f8 * arg5)) * 4) & 0xFFF;
block_39:
                        phi_a0->unk0 = phi_t1;
                        temp_a2_3 = phi_a1_2 + phi_s2;
                        phi_a0->unk4 = argC;
                        temp_a0 = phi_a0 + 8;
                        temp_t3 = phi_t2 | ((((((temp_a2_3 - phi_a1_2) * 2) + 9) >> 3) & 0x1FF) << 9);
                        temp_a0_2 = temp_a0 + 8;
                        temp_t1 = ((phi_a1_2 * 4) & 0xFFF) << 0xC;
                        temp_a0->unk0 = temp_t3;
                        temp_a0->unk4 = phi_t4;
                        temp_a0_2->unk0 = 0xE6000000;
                        temp_a0_3 = temp_a0_2 + 8;
                        temp_t2 = ((temp_a2_3 * 4) & 0xFFF) << 0xC;
                        temp_a0_2->unk4 = 0;
                        temp_a0_3->unk0 = temp_t1 | 0xF4000000 | phi_a3_3;
                        temp_a0_4 = temp_a0_3 + 8;
                        temp_a0_3->unk4 = temp_t2 | 0x7000000 | phi_t0_4;
                        temp_a0_5 = temp_a0_4 + 8;
                        temp_a0_6 = temp_a0_5 + 8;
                        temp_a0_4->unk0 = 0xE7000000;
                        temp_a0_4->unk4 = 0;
                        temp_a0_7 = temp_a0_6 + 8;
                        temp_a0_5->unk4 = phi_s0;
                        temp_a0_5->unk0 = temp_t3;
                        temp_a0_6->unk4 = temp_t2 | phi_t0_4;
                        temp_a0_6->unk0 = temp_t1 | 0xF2000000 | phi_a3_3;
                        temp_a0_8 = temp_a0_7 + 8;
                        temp_a0_9 = temp_a0_8 + 8;
                        temp_a0_7->unk0 = ((((phi_ra_2 + (phi_s2 * arg4)) * 4) & 0xFFF) << 0xC) | 0xE4000000 | phi_s1;
                        temp_a0_7->unk4 = (((phi_ra_2 * 4) & 0xFFF) << 0xC) | phi_s5;
                        temp_a0_8->unk0 = 0xB3000000;
                        temp_a0_8->unk4 = (phi_a1_2 << 0x15) | phi_s6;
                        temp_a0_9->unk0 = 0xB2000000;
                        temp_a0_9->unk4 = phi_s7;
                        temp_a0_10 = temp_a0_9 + 8;
                        phi_a1_2 = temp_s4;
                        phi_a0 = temp_a0_10;
                        phi_ra_2 = phi_f0 + phi_f16;
                        phi_a0_4 = temp_a0_10;
                        if (temp_s4 >= arg8) {
                            phi_a2_2 = arg9;
                            phi_a3_2 = sp74;
                            phi_v1 = arg8;
                            phi_t0_3 = sp78;
                        } else {
                            goto loop_30;
                        }
                    }
                }
                argB = phi_f12 + phi_f18;
                phi_s3 = sp34;
                phi_a2 = phi_a2_2;
                phi_a0_2 = phi_a0_4;
                phi_a0_3 = phi_a0_4;
                phi_ra_2 = sp8C;
                if (sp34 < phi_a2_2) {
                    goto loop_24;
                }
            }
        }
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800963F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 *draw_box(void *, s32, u32, u32, u32, s32, s32, s32, s32); // extern
extern ? D_0B002A00;

void *func_80096CD8(void *arg0, s32 arg1, s32 arg2, u32 arg3, u32 arg4) {
    s32 spD4;
    s32 spD0;
    s32 spCC;
    s32 spC8;
    s32 spC4;
    u32 sp84;
    u32 sp80;
    u32 sp7C;
    u32 sp78;
    s32 sp58;
    s32 *temp_v0_3;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_a2;
    s32 temp_a3;
    s32 temp_lo;
    s32 temp_s1;
    s32 temp_s4;
    s32 temp_t5;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    u32 temp_s3;
    u32 temp_t2;
    u32 temp_t4;
    u32 temp_t6;
    u32 temp_t7;
    void *temp_s0;
    void *temp_s0_10;
    void *temp_s0_11;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    void *temp_s0_8;
    void *temp_s0_9;
    u32 phi_ra;
    s32 phi_ra_2;
    s32 phi_v0;
    s32 phi_s1;
    s32 phi_s1_2;
    u32 phi_a1;
    s32 phi_s4;
    u32 phi_s2;
    u32 phi_fp;
    u32 phi_s3;
    u32 phi_s4_2;
    u32 phi_t4;
    u32 phi_t4_2;
    s32 phi_ra_3;
    u32 phi_s1_3;
    s32 phi_a1_2;
    void *phi_s0;
    s32 phi_t5;
    s32 phi_t3;
    s32 phi_s4_3;
    s32 phi_s6;
    s32 phi_s2_2;
    s32 phi_s3_2;
    s32 phi_s7;
    u32 phi_s3_3;
    void *phi_s0_2;
    s32 phi_ra_4;
    void *phi_s0_3;
    void *phi_s0_4;

    spC8 = 0;
    spC4 = 0;
    phi_ra = 1;
    phi_ra_2 = 1;
    phi_s4 = arg1;
    phi_s2 = arg2;
    phi_s0_2 = arg0;
    if (arg3 >= 2) {
        do {
            temp_t7 = phi_ra * 2;
            phi_ra = temp_t7;
            phi_ra_2 = temp_t7;
        } while (temp_t7 < arg3);
    }
    temp_lo = 0x400 / phi_ra_2;
    spCC = temp_lo;
    phi_a1 = arg4;
    if (arg4 < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (arg4 < temp_v0);
        spCC = phi_v0;
    }
    phi_s1 = phi_ra_2;
    if (phi_ra_2 >= 2) {
        do {
            temp_t8 = phi_s1 / 2;
            spC8 += 1;
            phi_s1 = temp_t8;
        } while (temp_t8 >= 2);
    }
    phi_s1_2 = spCC;
    if (spCC >= 2) {
        do {
            temp_t8_2 = phi_s1_2 / 2;
            spC4 += 1;
            phi_s1_2 = temp_t8_2;
        } while (temp_t8_2 >= 2);
    }
    if (arg1 < 0) {
        arg3 -= arg1;
        phi_s4 = 0;
    } else if ((arg1 + arg3) >= 0x141) {
        arg3 = 0x140 - arg1;
    }
    phi_s4_2 = phi_s4;
    if (arg2 < 0) {
        phi_a1 = arg4 - arg2;
        phi_s2 = 0;
    } else if ((arg2 + arg4) >= 0xF1) {
        phi_a1 = 0xF0 - arg2;
    }
    if (arg3 == 0) {

    } else if (phi_a1 == 0) {

    } else {
        spD0 = phi_ra_2;
        temp_s3 = phi_s2 + phi_a1;
        temp_t4 = phi_s4 + arg3;
        sp84 = temp_t4;
        temp_v0_2 = random_int(0x64);
        temp_s1 = temp_v0_2;
        temp_v0_3 = draw_box(arg0, phi_s4, phi_s2, sp84, temp_s3, 0, 0, 0, temp_v0_2);
        temp_v1 = (temp_s1 + 0x96) & 0xFF;
        temp_v0_3->unk0 = 0xE7000000;
        temp_v0_3->unk8 = 0xB900031D;
        temp_v0_3->unkC = 0x504240;
        temp_v0_3->unk10 = 0xFA000000;
        temp_v0_3->unk4 = 0;
        temp_v0_3->unk14 = (temp_v1 << 0x18) | (temp_v1 << 0x10) | (temp_v1 << 8) | temp_v1;
        temp_v0_3->unk1C = 0xFF2FFFFF;
        temp_v0_3->unk18 = 0xFC119623;
        temp_s0 = temp_v0_3 + 0x20;
        phi_fp = phi_s2;
        phi_s3 = temp_s3;
        phi_t4 = temp_t4;
        phi_s0_2 = temp_s0;
        phi_ra_4 = phi_ra_2;
        phi_s0_3 = temp_s0;
        if (phi_s2 < temp_s3) {
loop_23:
            temp_t6 = spCC + phi_fp;
            sp7C = temp_t6;
            phi_t4_2 = phi_t4;
            phi_ra_3 = phi_ra_4;
            phi_s0 = phi_s0_3;
            phi_s3_3 = phi_s3;
            phi_s0_2 = phi_s0_3;
            phi_t5 = spCC;
            phi_s0_4 = phi_s0_3;
            if (phi_s3 < temp_t6) {
                temp_t5 = phi_s3 - phi_fp;
                phi_t5 = temp_t5;
                if (temp_t5 != 0) {
                    goto block_26;
                }
            } else {
block_26:
                phi_s1_3 = phi_s4_2;
                if (phi_s4_2 < phi_t4) {
                    sp80 = phi_s3;
                    arg1 = phi_s4_2;
loop_28:
                    temp_t2 = phi_ra_3 + phi_s1_3;
                    phi_t4 = phi_t4_2;
                    phi_s0_4 = phi_s0;
                    phi_ra_4 = phi_ra_3;
                    if (phi_t4_2 < temp_t2) {
                        temp_s4 = phi_t4_2 - phi_s1_3;
                        phi_s4_3 = temp_s4;
                        if (temp_s4 == 0) {
                            phi_s3_3 = sp80;
                            phi_s4_2 = arg1;
                        } else {
                            temp_v0_4 = (spC4 & 0xF) << 0xE;
                            temp_v1_2 = (spC8 & 0xF) * 0x10;
                            phi_a1_2 = ((arg3 - 1) & 0xFFF) | 0xFD700000;
                            phi_t3 = (phi_fp << 5) & 0xFFFF;
                            phi_s6 = temp_v0_4 | 0x7000000 | temp_v1_2;
                            phi_s2_2 = (phi_fp * 4) & 0xFFF;
                            phi_s3_2 = ((phi_fp + phi_t5) * 4) & 0xFFF;
                            phi_s7 = temp_v0_4 | temp_v1_2;
                            goto block_33;
                        }
                    } else {
                        temp_v0_5 = (spC4 & 0xF) << 0xE;
                        temp_v1_3 = (spC8 & 0xF) * 0x10;
                        phi_a1_2 = ((arg3 - 1) & 0xFFF) | 0xFD700000;
                        phi_t3 = (phi_fp << 5) & 0xFFFF;
                        phi_s4_3 = phi_ra_3;
                        phi_s6 = temp_v0_5 | 0x7000000 | temp_v1_3;
                        phi_s2_2 = (phi_fp * 4) & 0xFFF;
                        phi_s3_2 = ((phi_fp + phi_t5) * 4) & 0xFFF;
                        phi_s7 = temp_v0_5 | temp_v1_3;
block_33:
                        phi_s0->unk0 = phi_a1_2;
                        spD0 = phi_ra_3;
                        spD4 = phi_t5;
                        sp84 = phi_t4_2;
                        sp58 = phi_t3;
                        sp78 = temp_t2;
                        temp_s0_2 = phi_s0 + 8;
                        temp_a2 = phi_s1_3 + phi_s4_3;
                        phi_s0->unk4 = (random_int(0x80) * 2) + &D_0B002A00;
                        temp_s0_3 = temp_s0_2 + 8;
                        temp_a3 = ((((((temp_a2 - phi_s1_3) * 2) + 9) >> 3) & 0x1FF) << 9) | 0xF5700000;
                        temp_s0_2->unk0 = temp_a3;
                        temp_s0_2->unk4 = phi_s6;
                        temp_s0_3->unk0 = 0xE6000000;
                        temp_a1 = ((phi_s1_3 * 4) & 0xFFF) << 0xC;
                        temp_s0_3->unk4 = 0;
                        temp_s0_4 = temp_s0_3 + 8;
                        temp_a0 = ((temp_a2 * 4) & 0xFFF) << 0xC;
                        temp_s0_4->unk0 = temp_a1 | 0xF4000000 | phi_s2_2;
                        temp_s0_5 = temp_s0_4 + 8;
                        temp_s0_4->unk4 = temp_a0 | 0x7000000 | phi_s3_2;
                        temp_s0_6 = temp_s0_5 + 8;
                        temp_s0_5->unk0 = 0xE7000000;
                        temp_s0_5->unk4 = 0;
                        temp_s0_7 = temp_s0_6 + 8;
                        temp_s0_6->unk4 = phi_s7;
                        temp_s0_6->unk0 = temp_a3;
                        temp_s0_8 = temp_s0_7 + 8;
                        temp_s0_7->unk4 = temp_a0 | phi_s3_2;
                        temp_s0_7->unk0 = temp_a1 | 0xF2000000 | phi_s2_2;
                        temp_s0_9 = temp_s0_8 + 8;
                        temp_s0_8->unk4 = temp_a1 | phi_s2_2;
                        temp_s0_8->unk0 = temp_a0 | 0xE4000000 | phi_s3_2;
                        temp_s0_9->unk0 = 0xB3000000;
                        temp_s0_10 = temp_s0_9 + 8;
                        temp_s0_9->unk4 = (phi_s1_3 << 0x15) | phi_t3;
                        temp_s0_10->unk0 = 0xB2000000;
                        temp_s0_10->unk4 = 0x4000400;
                        temp_s0_11 = temp_s0_10 + 8;
                        phi_s1_3 = temp_t2;
                        phi_s0 = temp_s0_11;
                        phi_t4 = phi_t4_2;
                        phi_s0_4 = temp_s0_11;
                        phi_ra_4 = phi_ra_3;
                        if (temp_t2 >= phi_t4_2) {
                            phi_s3_3 = sp80;
                            phi_s4_2 = arg1;
                        } else {
                            goto loop_28;
                        }
                    }
                }
                phi_fp = sp7C;
                phi_s3 = phi_s3_3;
                phi_s0_2 = phi_s0_4;
                phi_s0_3 = phi_s0_4;
                if (sp7C < phi_s3_3) {
                    goto loop_23;
                }
            }
        }
    }
    return phi_s0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80096CD8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_000FFF00;
extern ? D_0B002A00;
extern s32 gGlobalTimer;

void *func_80097274(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA, u32 argB, u32 argC) {
    s32 sp108;
    s32 sp104;
    s32 sp100;
    s32 spFC;
    s32 spF8;
    s32 spF4;
    s32 spF0;
    s32 spEC;
    u32 sp84;
    u32 sp80;
    s32 sp68;
    s32 sp50;
    s32 sp4C;
    s32 sp48;
    s32 sp44;
    s32 sp40;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a0_4;
    s32 temp_a1;
    s32 temp_a3;
    s32 temp_lo;
    s32 temp_s1;
    s32 temp_s2;
    s32 temp_s5;
    s32 temp_s6;
    s32 temp_s7;
    s32 temp_t3;
    s32 temp_t3_2;
    s32 temp_t4;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t7;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_t6_3;
    u32 temp_t9;
    u32 temp_t9_2;
    void *temp_a0;
    void *temp_s0;
    void *temp_s0_10;
    void *temp_s0_11;
    void *temp_s0_12;
    void *temp_s0_13;
    void *temp_s0_14;
    void *temp_s0_15;
    void *temp_s0_16;
    void *temp_s0_17;
    void *temp_s0_18;
    void *temp_s0_19;
    void *temp_s0_20;
    void *temp_s0_21;
    void *temp_s0_22;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    void *temp_s0_8;
    void *temp_s0_9;
    u32 phi_t0;
    s32 phi_t0_2;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_a0;
    s32 phi_t3;
    s32 phi_t4;
    s32 phi_t5;
    u32 phi_v1;
    s32 phi_s4;
    s32 phi_t5_2;
    s32 phi_a1;
    void *phi_s0;
    s32 phi_a3;
    s32 phi_t3_2;
    s32 phi_t4_2;
    s32 phi_a2;
    s32 phi_s3;
    s32 phi_t2;
    s32 phi_ra;
    void *phi_s0_2;
    s32 phi_t3_3;
    s32 phi_t4_3;
    void *phi_s0_3;
    void *phi_s0_4;

    temp_s0_2 = arg0 + 8;
    arg0->unk0 = 0xE7000000;
    arg0->unk4 = 0;
    temp_s0_3 = temp_s0_2 + 8;
    temp_s0_2->unk0 = 0xBA001402;
    temp_s0_2->unk4 = &D_000FFF00;
    temp_s0_4 = temp_s0_3 + 8;
    temp_s0_3->unk0 = 0xBA001001;
    temp_s0_3->unk4 = 0;
    temp_s0_4->unk0 = 0xFA000000;
    temp_t7 = gGlobalTimer;
    temp_s0_5 = temp_s0_4 + 8;
    phi_t0 = 1;
    phi_t0_2 = 1;
    phi_t3 = 0;
    phi_t4 = 0;
    phi_t3_3 = 0;
    phi_t4_3 = 0;
    if ((temp_t7 < 0) && ((temp_t7 & 0xFF) != 0)) {

    }
    temp_s0_4->unk4 = temp_t7 & 0xFF & 0xFF;
    temp_s0_5->unk4 = 0x1FFC9238;
    temp_s0_5->unk0 = 0xFC2527FF;
    temp_s0 = temp_s0_5 + 8;
    phi_s0_2 = temp_s0;
    phi_s0_3 = temp_s0;
    if (argB >= 2) {
        do {
            temp_t9 = phi_t0 * 2;
            phi_t0 = temp_t9;
            phi_t0_2 = temp_t9;
        } while (temp_t9 < argB);
    }
    temp_lo = 0x400 / phi_t0_2;
    spF4 = temp_lo;
    if (argC < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (argC < temp_v0);
        spF4 = phi_v0;
    }
    phi_v0_2 = phi_t0_2;
    if (phi_t0_2 >= 2) {
        do {
            temp_t6 = phi_v0_2 / 2;
            temp_t3 = phi_t3_3 + 1;
            phi_v0_2 = temp_t6;
            phi_t3 = temp_t3;
            phi_t3_3 = temp_t3;
        } while (temp_t6 >= 2);
    }
    phi_v0_3 = spF4;
    phi_a0 = arg8;
    if (spF4 >= 2) {
        do {
            temp_t8 = phi_v0_3 / 2;
            temp_t4 = phi_t4_3 + 1;
            phi_v0_3 = temp_t8;
            phi_t4 = temp_t4;
            phi_t4_3 = temp_t4;
        } while (temp_t8 >= 2);
    }
    if (arg8 < 0) {
        arg4 -= arg8;
        phi_a0 = 0;
    } else if (((arg6 - arg4) + arg8) >= 0x141) {
        arg6 = (arg4 - arg8) + 0x140;
    }
    temp_t6_2 = arg9;
    phi_v0_4 = arg5;
    phi_v1 = arg6;
    if (temp_t6_2 < 0) {
        arg9 = 0;
        phi_v0_4 = arg5 - temp_t6_2;
    } else if (((arg7 - arg5) + arg9) >= 0xF1) {
        arg7 = (arg5 - arg9) + 0xF0;
    }
    if (arg6 < arg4) {
        return temp_s0;
    }
    if (arg7 < phi_v0_4) {
        return temp_s0;
    }
    sp104 = phi_a0;
    phi_t5 = phi_v0_4;
    if (phi_v0_4 < arg7) {
        arg8 = phi_a0;
        spF8 = phi_t0_2;
        spF0 = phi_t3;
        spEC = phi_t4;
loop_27:
        temp_t6_3 = spF4 + phi_t5;
        sp84 = temp_t6_3;
        phi_t5_2 = phi_t5;
        phi_s0 = phi_s0_3;
        phi_s0_2 = phi_s0_3;
        phi_s0_4 = phi_s0_3;
        if (arg7 < temp_t6_3) {
            temp_v0_2 = arg7 - phi_t5;
            spFC = temp_v0_2;
            if (temp_v0_2 != 0) {
                goto block_31;
            }
        } else {
            spFC = spF4;
block_31:
            phi_s4 = arg4;
            if (arg4 < phi_v1) {
                arg6 = phi_v1;
loop_33:
                temp_t9_2 = spF8 + phi_s4;
                sp80 = temp_t9_2;
                phi_v1 = arg6;
                phi_s0_4 = phi_s0;
                if (arg6 < temp_t9_2) {
                    temp_t3_2 = arg6 - phi_s4;
                    phi_t3_2 = temp_t3_2;
                    if (temp_t3_2 != 0) {
                        arg6 = arg6;
                        temp_a0_2 = (arg1 & 7) << 0x15;
                        temp_v0_3 = (spEC & 0xF) << 0xE;
                        temp_v1 = (spF0 & 0xF) * 0x10;
                        sp4C = ((arg9 + spFC) * 4) & 0xFFF;
                        sp44 = (phi_t5_2 << 5) & 0xFFFF;
                        sp48 = (arg9 * 4) & 0xFFF;
                        sp40 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                        phi_a1 = temp_a0_2 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                        phi_a3 = temp_a0_2 | 0xF5000000 | 0x100000;
                        phi_t4_2 = temp_v0_3 | 0x7000000 | temp_v1;
                        phi_a2 = (phi_t5_2 * 4) & 0xFFF;
                        phi_s3 = ((phi_t5_2 + spFC) * 4) & 0xFFF;
                        phi_t2 = temp_v0_3 | temp_v1;
                        phi_ra = temp_v0_3 | 0x1000000 | temp_v1;
                        goto block_37;
                    }
                } else {
                    temp_a0_3 = (arg1 & 7) << 0x15;
                    temp_v0_4 = (spEC & 0xF) << 0xE;
                    temp_v1_2 = (spF0 & 0xF) * 0x10;
                    sp4C = ((arg9 + spFC) * 4) & 0xFFF;
                    sp44 = (phi_t5_2 << 5) & 0xFFFF;
                    sp48 = (arg9 * 4) & 0xFFF;
                    sp40 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                    phi_a1 = temp_a0_3 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                    phi_a3 = temp_a0_3 | 0xF5000000 | 0x100000;
                    phi_t3_2 = spF8;
                    phi_t4_2 = temp_v0_4 | 0x7000000 | temp_v1_2;
                    phi_a2 = (phi_t5_2 * 4) & 0xFFF;
                    phi_s3 = ((phi_t5_2 + spFC) * 4) & 0xFFF;
                    phi_t2 = temp_v0_4 | temp_v1_2;
                    phi_ra = temp_v0_4 | 0x1000000 | temp_v1_2;
block_37:
                    phi_s0->unk0 = phi_a1;
                    temp_a0_4 = phi_s4 + phi_t3_2;
                    phi_s0->unk4 = argA;
                    temp_s0_6 = phi_s0 + 8;
                    temp_s1 = phi_a3 | ((((((temp_a0_4 - phi_s4) * 2) + 9) >> 3) & 0x1FF) << 9);
                    temp_s0_7 = temp_s0_6 + 8;
                    temp_s0_6->unk0 = temp_s1;
                    temp_s0_6->unk4 = phi_t4_2;
                    temp_s0_7->unk0 = 0xE6000000;
                    temp_a3 = ((phi_s4 * 4) & 0xFFF) << 0xC;
                    temp_s0_8 = temp_s0_7 + 8;
                    temp_s2 = ((temp_a0_4 * 4) & 0xFFF) << 0xC;
                    temp_s0_7->unk4 = 0;
                    temp_s6 = temp_s2 | 0x7000000 | phi_s3;
                    temp_s0_9 = temp_s0_8 + 8;
                    temp_s5 = temp_a3 | 0xF4000000 | phi_a2;
                    temp_s0_8->unk0 = temp_s5;
                    temp_s0_8->unk4 = temp_s6;
                    temp_s0_10 = temp_s0_9 + 8;
                    temp_s0_9->unk0 = 0xE7000000;
                    temp_s0_11 = temp_s0_10 + 8;
                    temp_s0_9->unk4 = 0;
                    temp_s0_10->unk4 = phi_t2;
                    temp_s0_10->unk0 = temp_s1;
                    temp_s7 = temp_a3 | 0xF2000000 | phi_a2;
                    temp_s0_12 = temp_s0_11 + 8;
                    temp_s0_11->unk4 = temp_s2 | phi_s3;
                    temp_s0_11->unk0 = temp_s7;
                    temp_s0_12->unk0 = phi_a1;
                    sp50 = phi_ra;
                    sp108 = phi_t5_2;
                    sp68 = phi_t4_2;
                    sp100 = phi_t3_2;
                    temp_s0_13 = temp_s0_12 + 8;
                    temp_s0_12->unk4 = (random_int(0x80) * 2) + &D_0B002A00;
                    temp_s0_14 = temp_s0_13 + 8;
                    temp_a1 = temp_s1 | 0x100;
                    temp_s0_13->unk0 = temp_a1;
                    temp_s0_13->unk4 = phi_t4_2;
                    temp_s0_15 = temp_s0_14 + 8;
                    temp_s0_14->unk0 = 0xE6000000;
                    temp_s0_16 = temp_s0_15 + 8;
                    temp_s0_14->unk4 = 0;
                    temp_s0_15->unk4 = temp_s6;
                    temp_s0_15->unk0 = temp_s5;
                    temp_s0_17 = temp_s0_16 + 8;
                    temp_s0_16->unk0 = 0xE7000000;
                    temp_s0_16->unk4 = 0;
                    temp_s0_17->unk0 = temp_a1;
                    temp_s0_17->unk4 = phi_ra;
                    temp_s0_18 = temp_s0_17 + 8;
                    temp_s0_18->unk4 = temp_s2 | 0x1000000 | phi_s3;
                    temp_s0_18->unk0 = temp_s7;
                    temp_s0_19 = temp_s0_18 + 8;
                    temp_s0_19->unk0 = ((((arg8 + phi_t3_2) * 4) & 0xFFF) << 0xC) | 0xE4000000 | sp4C;
                    temp_s0_20 = temp_s0_19 + 8;
                    temp_s0_19->unk4 = (((arg8 * 4) & 0xFFF) << 0xC) | sp48;
                    temp_s0_20->unk0 = 0xB3000000;
                    temp_s0_21 = temp_s0_20 + 8;
                    temp_s0_20->unk4 = (phi_s4 << 0x15) | sp44;
                    temp_s0_21->unk0 = 0xB2000000;
                    temp_s0_22 = temp_s0_21 + 8;
                    temp_s0_21->unk4 = sp40;
                    arg8 += spF8;
                    phi_s4 = sp80;
                    phi_s0 = temp_s0_22;
                    phi_s0_4 = temp_s0_22;
                    if (sp80 >= arg6) {
                        phi_v1 = arg6;
                    } else {
                        goto loop_33;
                    }
                }
            }
            arg8 = sp104;
            arg9 += spF4;
            phi_t5 = sp84;
            phi_s0_2 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
            if (sp84 < arg7) {
                goto loop_27;
            }
        }
    }
    temp_a0 = phi_s0_2 + 8;
    phi_s0_2->unk0 = 0xE7000000;
    phi_s0_2->unk4 = 0;
    temp_a0->unk0 = 0xBA001402;
    temp_a0->unk4 = 0;
    return temp_a0 + 8;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097274.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 *func_80095E10(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern

void *func_80097A14(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA) {
    s32 *temp_v0;
    void *temp_a0;

    temp_a0 = arg0 + 8;
    arg0->unk0 = 0xE7000000;
    arg0->unk4 = 0;
    temp_a0->unk4 = 0x200000;
    temp_a0->unk0 = 0xBA001402;
    temp_v0 = func_80095E10(temp_a0 + 8, arg1, 0x1000, 0x400, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, argA);
    temp_v0->unk0 = 0xE7000000;
    temp_v0->unk4 = 0;
    temp_v0->unk8 = 0xBA001402;
    temp_v0->unkC = 0;
    return temp_v0 + 0x10;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097A14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097AE4(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s32 sp34;
    s32 temp_s1;
    s32 temp_s4;
    s32 temp_t1;
    s32 temp_t6;
    s32 temp_t7;
    s32 temp_t7_2;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_t8_3;
    s32 temp_t9;
    s32 temp_v1;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_11;
    void *temp_a0_12;
    void *temp_a0_13;
    void *temp_a0_14;
    void *temp_a0_15;
    void *temp_a0_16;
    void *temp_a0_17;
    void *temp_a0_18;
    void *temp_a0_19;
    void *temp_a0_20;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    void *phi_a0;
    s32 phi_a2;
    s32 phi_s0;
    s32 phi_s2;
    void *phi_a0_2;

    phi_a0 = arg0;
    phi_s0 = arg2;
    phi_s2 = arg3;
    phi_a0_2 = arg0;
    if (arg5 >= 0x20) {

    } else {
        temp_t8 = (arg1 & 7) << 0x15;
        temp_s4 = temp_t8 | 0xFD000000 | 0x100000 | 0x3F;
        temp_t8_2 = temp_t8 | 0xF5000000 | 0x100000 | 0x1200;
        sp34 = arg2;
        temp_t7 = (((0x8000 / (0x20 - arg5)) & 0xFFFF) << 0x10) | 0x400;
        phi_a2 = 0;
        do {
            temp_a0 = phi_a0 + 8;
            phi_a0->unk0 = temp_s4;
            phi_a0->unk4 = arg4;
            temp_a0_2 = temp_a0 + 8;
            temp_t6 = (phi_a2 * 4) & 0xFFF;
            temp_a0_3 = temp_a0_2 + 8;
            temp_a0->unk4 = 0x7014050;
            temp_a0->unk0 = temp_t8_2;
            temp_s1 = phi_a2 + 0x20;
            temp_t9 = (temp_s1 * 4) & 0xFFF;
            temp_a0_2->unk4 = 0;
            temp_a0_2->unk0 = 0xE6000000;
            temp_a0_4 = temp_a0_3 + 8;
            temp_a0_3->unk4 = temp_t9 | 0x7080000;
            temp_a0_3->unk0 = temp_t6 | 0xF4000000;
            temp_a0_5 = temp_a0_4 + 8;
            temp_a0_4->unk4 = 0;
            temp_a0_4->unk0 = 0xE7000000;
            temp_a0_5->unk4 = 0x14050;
            temp_a0_5->unk0 = temp_t8_2;
            temp_a0_6 = temp_a0_5 + 8;
            temp_v1 = phi_s0 + 0x20;
            temp_t1 = phi_s2 + 0x20;
            temp_a0_6->unk0 = temp_t6 | 0xF2000000;
            temp_a0_6->unk4 = temp_t9 | 0x80000;
            temp_t7_2 = (temp_t1 * 4) & 0xFFF;
            temp_a0_7 = temp_a0_6 + 8;
            temp_t8_3 = (phi_s2 * 4) & 0xFFF;
            temp_a0_7->unk0 = (((temp_v1 * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t7_2;
            temp_a0_8 = temp_a0_7 + 8;
            temp_a0_7->unk4 = ((((phi_s0 + arg5) * 4) & 0xFFF) << 0xC) | temp_t8_3;
            temp_a0_9 = temp_a0_8 + 8;
            temp_a0_8->unk0 = 0xB3000000;
            temp_a0_10 = temp_a0_9 + 8;
            temp_a0_8->unk4 = 0;
            temp_a0_9->unk0 = 0xB2000000;
            temp_a0_9->unk4 = temp_t7;
            temp_a0_11 = temp_a0_10 + 8;
            temp_a0_10->unk4 = arg4;
            temp_a0_10->unk0 = temp_s4;
            temp_a0_12 = temp_a0_11 + 8;
            temp_a0_11->unk4 = 0x7014050;
            temp_a0_11->unk0 = temp_t8_2;
            temp_a0_13 = temp_a0_12 + 8;
            temp_a0_12->unk4 = 0;
            temp_a0_12->unk0 = 0xE6000000;
            temp_a0_14 = temp_a0_13 + 8;
            temp_a0_13->unk4 = temp_t9 | 0x7100000;
            temp_a0_13->unk0 = temp_t6 | 0xF4080000;
            temp_a0_15 = temp_a0_14 + 8;
            temp_a0_14->unk4 = 0;
            temp_a0_14->unk0 = 0xE7000000;
            temp_a0_15->unk4 = 0x14050;
            temp_a0_16 = temp_a0_15 + 8;
            temp_a0_15->unk0 = temp_t8_2;
            temp_a0_16->unk0 = temp_t6 | 0xF2080000;
            temp_a0_16->unk4 = temp_t9 | 0x100000;
            temp_a0_17 = temp_a0_16 + 8;
            temp_a0_17->unk0 = (((((temp_v1 - arg5) + 0x20) * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t7_2;
            temp_a0_18 = temp_a0_17 + 8;
            temp_a0_17->unk4 = (((temp_v1 * 4) & 0xFFF) << 0xC) | temp_t8_3;
            temp_a0_19 = temp_a0_18 + 8;
            temp_a0_18->unk0 = 0xB3000000;
            temp_a0_18->unk4 = 0;
            temp_a0_19->unk0 = 0xB2000000;
            temp_a0_19->unk4 = temp_t7;
            temp_a0_20 = temp_a0_19 + 8;
            phi_a0 = temp_a0_20;
            phi_a2 = temp_s1;
            phi_s0 = sp34;
            phi_s2 = temp_t1;
            phi_a0_2 = temp_a0_20;
        } while (temp_s1 != 0x40);
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097AE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097E58(void *arg0, s8 arg1, ? arg2, u32 arg3, u32 arg5, s32 arg6, s32 arg7, s32 arg8, u32 arg9, s32 argB) {
    s32 spEC;
    s32 spDC;
    s32 sp80;
    s32 sp60;
    s32 sp5C;
    s32 sp40;
    s32 sp3C;
    s32 sp30;
    s32 temp_a1;
    s32 temp_a3;
    s32 temp_s0;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t6_3;
    s32 temp_t7;
    s32 temp_t7_2;
    s32 temp_t7_3;
    s32 temp_t7_4;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_t9_2;
    s32 temp_v0;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_t0;
    u32 temp_t4;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_11;
    void *temp_a0_12;
    void *temp_a0_13;
    void *temp_a0_14;
    void *temp_a0_15;
    void *temp_a0_16;
    void *temp_a0_17;
    void *temp_a0_18;
    void *temp_a0_19;
    void *temp_a0_20;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    u32 phi_t4;
    s32 phi_s3;
    void *phi_a0;
    s32 phi_t2;
    s32 phi_s0;
    s32 phi_s2;
    s32 phi_v0;
    s32 phi_s4;
    s32 phi_s1;
    s32 phi_ra;
    s32 phi_s7;
    s32 phi_fp;
    s32 phi_s6;
    s32 phi_t3;
    s32 phi_s5;
    void *phi_a0_2;

    phi_a0 = arg0;
    phi_a0_2 = arg0;
    if (argB >= 0x20) {

    } else {
        temp_t0 = arg9 >> 1;
        temp_t7 = arg9 - temp_t0;
        sp80 = temp_t7;
        spDC = temp_t7;
        spEC = arg6;
        phi_t4 = arg3;
        phi_s4 = arg6;
        if (arg3 < arg5) {
loop_3:
            phi_a0_2 = phi_a0;
            if (arg5 < (phi_t4 + 0x20)) {
                temp_v0 = arg5 - phi_t4;
                phi_s2 = temp_v0;
                if (temp_v0 != 0) {
                    temp_t9 = (arg1 & 7) << 0x15;
                    temp_v1 = 0x20 - argB;
                    sp30 = argB;
                    temp_t6 = temp_t9 | 0xF5000000 | 0x100000;
                    sp60 = temp_t0 << 0x15;
                    temp_t6_2 = ((temp_t0 * 4) & 0xFFF) << 0xC;
                    sp5C = ((((sp80 << 5) << 0xA) / (sp80 * temp_v1)) << 0x10) | 0x400;
                    temp_t7_2 = ((arg9 * 4) & 0xFFF) << 0xC;
                    sp40 = temp_t6_2 | 0xF4000000;
                    sp3C = ((((temp_t0 << 5) << 0xA) / (temp_t0 * temp_v1)) << 0x10) | 0x400;
                    phi_s3 = temp_t9 | 0xFD000000 | 0x100000 | ((arg9 - 1) & 0xFFF);
                    phi_t2 = temp_t6 | (((((temp_t0 * 2) + 9) >> 3) & 0x1FF) << 9);
                    phi_s0 = temp_t6_2 | 0x7000000;
                    phi_v0 = temp_t6_2;
                    phi_s1 = (temp_t0 * argB) / 0x20;
                    phi_ra = temp_t6 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                    phi_s7 = temp_t7_2 | 0x7000000;
                    phi_fp = temp_t6 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                    phi_s6 = temp_t6_2 | 0xF2000000;
                    phi_t3 = temp_t7_2;
                    phi_s5 = (spDC * temp_v1) / 0x20;
                    goto block_7;
                }
            } else {
                temp_v1_2 = 0x20 - argB;
                temp_t8 = (arg1 & 7) << 0x15;
                sp30 = argB;
                temp_t7_3 = temp_t8 | 0xF5000000 | 0x100000;
                sp60 = temp_t0 << 0x15;
                temp_t7_4 = ((temp_t0 * 4) & 0xFFF) << 0xC;
                sp5C = ((((sp80 << 5) << 0xA) / (sp80 * temp_v1_2)) << 0x10) | 0x400;
                temp_t6_3 = ((arg9 * 4) & 0xFFF) << 0xC;
                sp40 = temp_t7_4 | 0xF4000000;
                sp3C = ((((temp_t0 << 5) << 0xA) / (temp_t0 * temp_v1_2)) << 0x10) | 0x400;
                phi_s3 = temp_t8 | 0xFD000000 | 0x100000 | ((arg9 - 1) & 0xFFF);
                phi_t2 = temp_t7_3 | (((((temp_t0 * 2) + 9) >> 3) & 0x1FF) << 9);
                phi_s0 = temp_t7_4 | 0x7000000;
                phi_s2 = 0x20;
                phi_v0 = temp_t7_4;
                phi_s1 = (temp_t0 * argB) / 0x20;
                phi_ra = temp_t7_3 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                phi_s7 = temp_t6_3 | 0x7000000;
                phi_fp = temp_t7_3 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                phi_s6 = temp_t7_4 | 0xF2000000;
                phi_t3 = temp_t6_3;
                phi_s5 = (spDC * temp_v1_2) / 0x20;
block_7:
                phi_a0->unk0 = phi_s3;
                temp_a0 = phi_a0 + 8;
                phi_a0->unk4 = arg8;
                temp_a0->unk4 = 0x7014050;
                temp_a0_2 = temp_a0 + 8;
                temp_a0->unk0 = phi_t2;
                temp_t9_2 = (phi_t4 * 4) & 0xFFF;
                temp_a0_3 = temp_a0_2 + 8;
                temp_a0_2->unk0 = 0xE6000000;
                temp_a3 = ((phi_t4 + phi_s2) * 4) & 0xFFF;
                temp_a0_2->unk4 = 0;
                temp_a0_3->unk0 = temp_t9_2 | 0xF4000000;
                temp_a0_4 = temp_a0_3 + 8;
                temp_a0_3->unk4 = phi_s0 | temp_a3;
                temp_a0_5 = temp_a0_4 + 8;
                temp_a0_4->unk0 = 0xE7000000;
                temp_a0_4->unk4 = 0;
                temp_a0_6 = temp_a0_5 + 8;
                temp_a0_5->unk4 = 0x14050;
                temp_a0_5->unk0 = phi_t2;
                temp_a0_6->unk4 = phi_v0 | temp_a3;
                temp_a0_6->unk0 = temp_t9_2 | 0xF2000000;
                temp_s0 = phi_s4 + temp_t0;
                temp_t1 = ((arg7 + phi_s2) * 4) & 0xFFF;
                temp_a0_7 = temp_a0_6 + 8;
                temp_a0_7->unk0 = (((temp_s0 * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t1;
                temp_t2 = (arg7 * 4) & 0xFFF;
                temp_a0_7->unk4 = ((((phi_s1 + phi_s4) * 4) & 0xFFF) << 0xC) | temp_t2;
                temp_a0_8 = temp_a0_7 + 8;
                temp_a1 = (phi_t4 << 5) & 0xFFFF;
                temp_a0_9 = temp_a0_8 + 8;
                temp_a0_8->unk0 = 0xB3000000;
                temp_a0_8->unk4 = temp_a1;
                temp_a0_9->unk0 = 0xB2000000;
                temp_a0_10 = temp_a0_9 + 8;
                temp_a0_9->unk4 = sp3C;
                temp_a0_10->unk0 = phi_s3;
                temp_a0_11 = temp_a0_10 + 8;
                temp_a0_10->unk4 = arg8;
                temp_a0_12 = temp_a0_11 + 8;
                temp_a0_11->unk4 = 0x7014050;
                temp_a0_11->unk0 = phi_ra;
                temp_a0_12->unk0 = 0xE6000000;
                temp_a0_12->unk4 = 0;
                temp_a0_13 = temp_a0_12 + 8;
                temp_a0_14 = temp_a0_13 + 8;
                temp_a0_13->unk0 = sp40 | temp_t9_2;
                temp_a0_13->unk4 = phi_s7 | temp_a3;
                temp_a0_15 = temp_a0_14 + 8;
                temp_a0_14->unk0 = 0xE7000000;
                temp_a0_14->unk4 = 0;
                temp_a0_15->unk4 = 0x14050;
                temp_a0_16 = temp_a0_15 + 8;
                temp_a0_15->unk0 = phi_fp;
                temp_a0_16->unk0 = phi_s6 | temp_t9_2;
                temp_a0_16->unk4 = phi_t3 | temp_a3;
                temp_a0_17 = temp_a0_16 + 8;
                temp_a0_17->unk0 = ((((phi_s5 + temp_s0) * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t1;
                temp_a0_17->unk4 = (((temp_s0 * 4) & 0xFFF) << 0xC) | temp_t2;
                temp_a0_18 = temp_a0_17 + 8;
                temp_a0_18->unk0 = 0xB3000000;
                temp_a0_19 = temp_a0_18 + 8;
                temp_a0_18->unk4 = sp60 | temp_a1;
                temp_a0_19->unk0 = 0xB2000000;
                temp_t4 = phi_t4 + 0x20;
                temp_a0_20 = temp_a0_19 + 8;
                temp_a0_19->unk4 = sp5C;
                arg7 += 0x20;
                phi_t4 = temp_t4;
                phi_a0 = temp_a0_20;
                phi_s4 = spEC;
                phi_a0_2 = temp_a0_20;
                if (temp_t4 < arg5) {
                    goto loop_3;
                }
            }
        }
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097E58.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 sins(s32); // extern
f32 coss(s32); // extern
extern s32 D_8018D9B0;
extern u32 D_8018E7B8;
extern s32 D_8018E7D0;

void *func_800987D0(void *arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4, s32 arg5, s32 arg6, s32 arg8) {
    u32 sp60;
    s32 sp5C;
    f32 temp_f0;
    f32 temp_f18;
    f32 temp_f24;
    f32 temp_f2;
    f32 temp_f6;
    f64 temp_f10;
    s32 temp_a3;
    s32 temp_f4;
    s32 temp_f6_2;
    s32 temp_t1;
    s32 temp_t4;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_v0_2;
    s32 temp_v0_3;
    u32 temp_t2;
    u32 temp_t9;
    u32 temp_v0;
    u32 temp_v0_4;
    void *temp_s0;
    void *temp_s0_10;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    void *temp_s0_8;
    void *temp_s0_9;
    u32 phi_v0;
    u32 phi_v0_2;
    void *phi_s0;
    u32 phi_a2;
    s32 phi_t5;
    f32 phi_f6;
    f64 phi_f10;
    u32 phi_v0_3;
    void *phi_s0_2;
    void *phi_s0_3;
    void *phi_s0_4;

    temp_v0 = D_8018E7B8;
    phi_v0 = temp_v0;
    phi_s0_2 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0 == 0) {
        D_8018E7B8 = 1;
        phi_v0 = 1;
    }
    temp_f24 = sins((((D_8018E7D0 * 0x4E20) / phi_v0) % 0x4E20) & 0xFFFF);
    temp_f0 = coss((((D_8018E7D0 * 0x4E20) / D_8018E7B8) % 0x4E20) & 0xFFFF);
    temp_t8 = D_8018E7D0;
    temp_f6 = temp_t8;
    phi_f6 = temp_f6;
    phi_t5 = arg5;
    if (temp_t8 < 0) {
        phi_f6 = temp_f6 + 4294967296.0f;
    }
    temp_t9 = D_8018E7B8;
    temp_f10 = temp_t9;
    phi_f10 = temp_f10;
    if (temp_t9 < 0) {
        phi_f10 = temp_f10 + 4294967296.0;
    }
    sp5C = arg5;
    temp_f18 = ((phi_f6 * 0.5) / phi_f10) + 1.0;
    phi_v0_2 = arg2;
    if (arg2 < arg4) {
        do {
            phi_s0 = phi_s0_3;
            phi_a2 = arg1;
            phi_v0_3 = phi_v0_2;
            phi_s0_4 = phi_s0_3;
            if (arg1 < arg3) {
                sp60 = phi_v0_2;
                temp_v0_2 = arg6 - 0x78;
                temp_t8_2 = (phi_v0_2 * 4) & 0xFFF;
                temp_t4 = ((phi_v0_2 + 0x20) * 4) & 0xFFF;
                do {
                    phi_s0->unk0 = ((arg8 - 1) & 0xFFF) | 0xFD100000;
                    temp_s0 = phi_s0 + 8;
                    phi_s0->unk4 = D_8018D9B0;
                    temp_s0_2 = temp_s0 + 8;
                    temp_a3 = (((((arg1 * 0 * 2) + 0x49) >> 3) & 0x1FF) << 9) | 0xF5100000;
                    temp_t1 = ((phi_a2 * 4) & 0xFFF) << 0xC;
                    temp_t2 = phi_a2 + 0x20;
                    temp_s0_3 = temp_s0_2 + 8;
                    temp_s0->unk0 = temp_a3;
                    temp_s0->unk4 = 0x7014050;
                    temp_v0_3 = ((temp_t2 * 4) & 0xFFF) << 0xC;
                    temp_s0_2->unk4 = 0;
                    temp_s0_2->unk0 = 0xE6000000;
                    temp_s0_3->unk0 = temp_t1 | 0xF4000000 | temp_t8_2;
                    temp_s0_4 = temp_s0_3 + 8;
                    temp_s0_3->unk4 = temp_v0_3 | 0x7000000 | temp_t4;
                    temp_s0_5 = temp_s0_4 + 8;
                    temp_s0_4->unk4 = 0;
                    temp_s0_4->unk0 = 0xE7000000;
                    temp_s0_5->unk4 = 0x14050;
                    temp_s0_5->unk0 = temp_a3;
                    temp_s0_6 = temp_s0_5 + 8;
                    temp_f2 = phi_t5 - 0xA0;
                    temp_s0_6->unk4 = temp_v0_3 | temp_t4;
                    temp_s0_6->unk0 = temp_t1 | 0xF2000000 | temp_t8_2;
                    temp_s0_7 = temp_s0_6 + 8;
                    temp_s0_8 = temp_s0_7 + 8;
                    temp_s0_9 = temp_s0_8 + 8;
                    temp_s0_10 = temp_s0_9 + 8;
                    temp_f6_2 = (((temp_f2 * temp_f0) + (temp_f24 * temp_v0_2)) * temp_f18) + 160.0f;
                    temp_f4 = (((-temp_f24 * temp_f2) + (temp_f0 * temp_v0_2)) * temp_f18) + 120.0f;
                    temp_s0_7->unk0 = ((((temp_f6_2 + 0x20) * 4) & 0xFFF) << 0xC) | 0xE4000000 | (((temp_f4 + 0x20) * 4) & 0xFFF);
                    temp_s0_7->unk4 = (((temp_f6_2 * 4) & 0xFFF) << 0xC) | ((temp_f4 * 4) & 0xFFF);
                    temp_s0_8->unk0 = 0xB3000000;
                    temp_s0_8->unk4 = 0;
                    temp_s0_9->unk0 = 0xB2000000;
                    temp_s0_9->unk4 = 0x4000400;
                    phi_s0 = temp_s0_10;
                    phi_a2 = temp_t2;
                    phi_t5 += 0x20;
                    phi_s0_4 = temp_s0_10;
                } while (temp_t2 < arg3);
                phi_v0_3 = sp60;
            }
            temp_v0_4 = phi_v0_3 + 0x20;
            arg6 += 0x20;
            phi_v0_2 = temp_v0_4;
            phi_s0_2 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
            phi_t5 = sp5C;
        } while (temp_v0_4 < arg4);
    }
    return phi_s0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800987D0.s")
#endif

Gfx *func_80098C18(Gfx *displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 red, s32 green, s32 blue, s32 alpha) {
    red &= 0xFF;
    green &= 0xFF;
    blue &= 0xFF;
    alpha &= 0xFF;
    if (lrx < ulx) {
        swap_values(&ulx, &lrx);
    }
    if (lry < uly) {
        swap_values(&uly, &lry);
    }
    if ((ulx >= 0x140) || (uly >= 0xF0)) {
        return displayListHead;
    }
    if (ulx < 0) {
        ulx = 0;
    }
    if (uly < 0) {
        uly = 0;
    }
    if ((lrx < 0) || (lry < 0)) {
        return displayListHead;
    }
    if (lrx >= 0x140) {
        lrx = 0x13F;
    }
    if (lry >= 0xF0) {
        lry = 0xEF;
    }
    gSPDisplayList(displayListHead++, D_02008030);
    gDPSetFillColor(displayListHead++, (GPACK_RGBA5551(red, green, (u32)blue, alpha) << 0x10 | GPACK_RGBA5551(red, green, (u32)blue, alpha)));
    gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
    gSPDisplayList(displayListHead++, D_02008058);
    return displayListHead;
}

Gfx *draw_box(Gfx *displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 red, s32 green, s32 blue, s32 alpha) {
    Gfx *temp_a0;
    Gfx *temp_v1;

    red &= 0xFF;
    green &= 0xFF;
    blue &= 0xFF;
    alpha &= 0xFF;
    if (lrx < ulx) {
        swap_values(&ulx, &lrx);
    }
    if (lry < uly) {
        swap_values(&uly, &lry);
    }
    if ((ulx >= 0x140) || (uly >= 0xF0)) {
        return displayListHead;
    }
    if (ulx < 0) {
        ulx = 0;
    }
    if (uly < 0) {
        uly = 0;
    }
    if ((lrx < 0) || (lry < 0)) {
        return displayListHead;
    }
    if (lrx >= 0x141) {
        lrx = 0x140;
    }
    if (lry >= 0xF1) {
        lry = 0xF0;
    }
    gSPDisplayList(displayListHead++, D_02008008);
    gDPSetPrimColor(displayListHead++, 0, 0, red, green, blue, alpha);
    gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
    gDPPipeSync(displayListHead++);
    return displayListHead;
}

Gfx *func_80098FC8(Gfx *displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry) {
    return func_80098C18(displayListHead, ulx, uly, lrx, lry, 0, 0, 0, 0xFF);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern OSMesgQueue gDmaMesgQueue;
extern ? _textures_0aSegmentRomStart;

void dma_copy_base_729a30(s32 arg0, u32 arg1, void *arg2) {
    ? sp30;
    void *sp2C;

    osInvalDCache(arg2, arg1);
    osPiStartDma(&sp30, 0, 0, (arg0 & 0xFFFFFF) + &_textures_0aSegmentRomStart, arg2, arg1, &gDmaMesgQueue);
    osRecvMesg(&gDmaMesgQueue, &sp2C, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/dma_copy_base_729a30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern OSMesgQueue gDmaMesgQueue;
extern ? _textures_0bSegmentRomStart;

void dma_copy_base_7fa3c0(s32 arg0, u32 arg1, void *arg2) {
    ? sp30;
    void *sp2C;

    osInvalDCache(arg2, arg1);
    osPiStartDma(&sp30, 0, 0, (arg0 & 0xFFFFFF) + &_textures_0bSegmentRomStart, arg2, arg1, &gDmaMesgQueue);
    osRecvMesg(&gDmaMesgQueue, &sp2C, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/dma_copy_base_7fa3c0.s")
#endif

void func_80099110(void) {
    gD_8018E118TotalSize = 0;
    gNumD_8018E118Entries = 0;
}

void *segmented_to_virtual(segment_address_t arg0) {
    return gSegmentTable[arg0 >> 0x18] + (arg0 & 0xFFFFFF) + 0x80000000;
}

void *segmented_to_virtual_dupe(segment_address_t arg0) {
    return gSegmentTable[arg0 >> 0x18] + (arg0 & 0xFFFFFF) + 0x80000000;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
? dma_copy_base_729a30(u32, s32, s32);              /* extern */
? mio0decode(s32, s32);                             /* extern */

void func_80099184(u32 arg0) {
    Mk64_Texture *temp_v0;
    s32 temp_t3;
    s32 temp_t6;
    s32 temp_v0_2;
    s32 temp_v1;
    u16 temp_v0_3;
    u32 temp_a0;
    s32 phi_v0;
    Mk64_Texture *phi_s1;
    s32 phi_a1;
    s32 phi_a1_2;
    s32 phi_a1_3;

    temp_v0 = segmented_to_virtual(arg0);
    phi_s1 = temp_v0;
    if (temp_v0->segmentAddress != 0) {
        do {
            temp_v1 = gNumD_8018E118Entries;
            phi_v0 = 0;
            phi_a1 = 0;
            if (temp_v1 > 0) {
loop_4:
                temp_v0_2 = phi_v0 + 1;
                phi_v0 = temp_v0_2;
                if (D_8018E118[phi_v0].textureData == phi_s1->segmentAddress) {
                    phi_a1 = 1;
                } else if (temp_v0_2 < temp_v1) {
                    goto loop_4;
                }
            }
            if (phi_a1 == 0) {
                temp_a0 = phi_s1->segmentAddress;
                if (phi_s1->type == 3) {
                    temp_v0_3 = phi_s1->size;
                    phi_a1_2 = 0x1000;
                    if (temp_v0_3 != 0) {
                        phi_a1_2 = temp_v0_3 & 0xFFFF;
                    }
                    phi_a1_3 = phi_a1_2;
                    if ((phi_a1_2 % 8) != 0) {
                        phi_a1_3 = (((phi_a1_2 / 8) * 8) + 8) & 0xFFFF;
                    }
                    dma_copy_base_729a30(temp_a0, phi_a1_3, D_8018D9B4);
                    mio0decode(D_8018D9B4, (gD_8018E118TotalSize * 2) + D_8018D9B0);
                } else {
                    dma_copy_base_729a30(temp_a0, phi_s1->height * phi_s1->width * 2, (gD_8018E118TotalSize * 2) + D_8018D9B0);
                }
                D_8018E118[gNumD_8018E118Entries].textureData = phi_s1->segmentAddress;
                D_8018E118[gNumD_8018E118Entries].offset = gD_8018E118TotalSize;
                gNumD_8018E118Entries += 1;
                temp_t3 = gD_8018E118TotalSize + (phi_s1->height * phi_s1->width);
                temp_t6 = temp_t3;
                gD_8018E118TotalSize = temp_t3;
                gD_8018E118TotalSize = ((temp_t6 / 8) * 8) + 8;
            }
            phi_s1 += 0x14;
        } while (phi_s1->unk18 != 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099184.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800996BC(?); // extern

void func_8009969C(void) {
    func_800996BC(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009969C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
? dma_copy_base_729a30(u32, s32, s32);              /* extern */
? dma_copy_base_7fa3c0(u32, s32, s32);              /* extern */
? mio0decode(s32, s32);                             /* extern */
? tkmk00decode(s32, s32, s32, ?);                   /* extern */
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern s32 D_8018D9B8;

void func_800996BC(u32 arg0, s32 arg1) {
    Mk64_Texture *temp_v0;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_v0_2;
    s32 temp_v1;
    u16 temp_v0_3;
    s32 phi_v0;
    Mk64_Texture *phi_s0;
    s32 phi_a1;
    s32 phi_a1_2;
    s32 phi_a1_3;
    ? phi_v0_2;

    temp_v0 = segmented_to_virtual();
    phi_s0 = temp_v0;
    if (temp_v0->segmentAddress != 0) {
        do {
            temp_v1 = gNumD_8018E118Entries;
            phi_v0 = 0;
            phi_a1 = 0;
            if (temp_v1 > 0) {
loop_4:
                temp_v0_2 = phi_v0 + 1;
                phi_v0 = temp_v0_2;
                if (D_8018E118[phi_v0].textureData == phi_s0->segmentAddress) {
                    phi_a1 = 1;
                } else if (temp_v0_2 < temp_v1) {
                    goto loop_4;
                }
            }
            if ((phi_a1 == 0) || (arg1 > 0)) {
                temp_v0_3 = phi_s0->size;
                phi_a1_2 = 0x1000;
                if (temp_v0_3 != 0) {
                    phi_a1_2 = temp_v0_3 & 0xFFFF;
                }
                phi_a1_3 = phi_a1_2;
                if ((phi_a1_2 % 8) != 0) {
                    phi_a1_3 = (((phi_a1_2 / 8) * 8) + 8) & 0xFFFF;
                }
                switch (arg1) {                     /* irregular */
                case -1:
                case 1:
                    dma_copy_base_729a30(phi_s0->segmentAddress, phi_a1_3, D_8018D9B4);
                    break;
                case 0:
                case 2:
                    dma_copy_base_7fa3c0(phi_s0->segmentAddress, phi_a1_3, D_8018D9B4);
                    break;
                }
                switch (arg1) {                     /* switch 1; irregular */
                case -1:                            /* switch 1 */
                case 1:                             /* switch 1 */
                    mio0decode(D_8018D9B4, (gD_8018E118TotalSize * 2) + D_8018D9B0);
                    break;
                case 0:                             /* switch 1 */
                case 2:                             /* switch 1 */
                    phi_v0_2 = 1;
                    if (phi_s0->type == 1) {
                        phi_v0_2 = 0xBE;
                    }
                    tkmk00decode(D_8018D9B4, D_8018D9B8, (gD_8018E118TotalSize * 2) + D_8018D9B0, phi_v0_2);
                    break;
                }
                D_8018E118[gNumD_8018E118Entries].textureData = phi_s0->segmentAddress;
                D_8018E118[gNumD_8018E118Entries].offset = gD_8018E118TotalSize;
                gNumD_8018E118Entries += 1;
                temp_t0 = gD_8018E118TotalSize + (phi_s0->height * phi_s0->width);
                temp_t1 = temp_t0;
                gD_8018E118TotalSize = temp_t0;
                gD_8018E118TotalSize = ((temp_t1 / 8) * 8) + 8;
            }
            phi_s0 += 0x14;
        } while (phi_s0->unk18 != 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800996BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? dma_copy_base_729a30(s32, s32, u8 *); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern u8 *D_8018D9B4;

void func_80099958(s32 arg1, s32 arg2) {
    s32 temp_a0;
    s32 temp_t6;
    u16 temp_v0_2;
    u8 *temp_s2;
    void *temp_v0;
    void *phi_s0;
    s32 phi_a1;
    s32 phi_a0;
    s32 phi_a1_2;

    temp_v0 = segmented_to_virtual(arg0);
    temp_t6 = temp_v0->unk4;
    phi_s0 = temp_v0;
    phi_a0 = temp_t6;
    if (temp_t6 != 0) {
        temp_s2 = &D_802BFB80[(arg2 << 0x10) + ((arg1 / 2) << 0xF) + ((arg1 % 2) << 0xD) + 0x4000];
        do {
            temp_v0_2 = phi_s0->unk10;
            phi_a1 = 0x1400;
            if (temp_v0_2 != 0) {
                phi_a1 = temp_v0_2 & 0xFFFF;
            }
            phi_a1_2 = phi_a1;
            if ((phi_a1 % 8) != 0) {
                phi_a1_2 = (((phi_a1 / 8) * 8) + 8) & 0xFFFF;
            }
            dma_copy_base_729a30(phi_a0, phi_a1_2, D_8018D9B4);
            mio0decode(D_8018D9B4, temp_s2);
            temp_a0 = phi_s0->unk18;
            phi_s0 += 0x14;
            phi_a0 = temp_a0;
        } while (temp_a0 != 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099958.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018E060;

void func_80099A70(void) {
    s32 temp_v0;
    s32 phi_v0;

    D_8018E060 = 0;
    phi_v0 = 0;
    do {
        temp_v0 = phi_v0 + 4;
        phi_v0 = temp_v0;
    } while (temp_v0 != 0x10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099A70.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *segmented_to_virtual(segment_address_t); // extern
extern s32 D_8018E060;

void func_80099A94(s32 arg1) {
    s32 *sp1C;
    s32 *temp_v1;
    s32 *phi_v1;
    s32 *phi_v1_2;

    phi_v1 = &D_8018E060;
    phi_v1_2 = &D_8018E060;
    if (D_8018E060 != 0) {
        do {
            temp_v1 = phi_v1 + 8;
            phi_v1 = temp_v1;
            phi_v1_2 = temp_v1;
        } while (phi_v1->unk8 != 0);
    }
    sp1C = phi_v1_2;
    phi_v1_2->unk0 = segmented_to_virtual(arg0);
    phi_v1_2->unk4 = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099A94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
? mio0decode(s32, s32);                             /* extern */
? osInvalDCache(s32, s32);                          /* extern */
? osPiStartDma(? *, ?, ?, void *, s32, s32, ? *);   /* extern */
? osRecvMesg(? *, ? *, ?);                          /* extern */
extern s32 D_800DC50C;
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern void *D_8018E060;
extern ? _textures_0aSegmentRomStart;
extern ? gDmaMesgQueue;

void func_80099AEC(void) {
    ? sp6C;
    ? sp68;
    s32 sp60;
    ? *sp58;
    s32 temp_t7;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_s1;
    void *temp_s2;
    void *temp_v0;
    void *temp_v0_2;
    s32 phi_s0;
    s32 phi_s0_2;
    void **phi_s1;
    s32 phi_s0_3;
    s32 phi_s0_4;
    s8 phi_s5;
    s32 phi_s0_5;
    s32 phi_s0_6;
    s8 phi_s5_2;
    s8 phi_s5_3;

    if (D_800DC50C == RACING) {
        sp60 = 0x500;
    } else {
        sp60 = 0x1000;
    }
    temp_s2 = D_8018E060;
    phi_s1 = &D_8018E060;
    phi_s5_3 = 0;
    if (temp_s2 != 0) {
        temp_v1 = temp_s2->unk10;
        phi_s0 = 0x1400;
        phi_s0_3 = 0x1400;
        phi_s0_5 = 0x1400;
        if (temp_v1 != 0) {
            phi_s0 = (s32) temp_v1;
        }
        phi_s0_2 = phi_s0;
        if ((phi_s0 % 8) != 0) {
            phi_s0_2 = ((phi_s0 / 8) * 8) + 8;
        }
        osInvalDCache(D_8018D9B4, phi_s0_2);
        sp58 = &_textures_0aSegmentRomStart;
        osPiStartDma(&sp6C, 0, 0, &_textures_0aSegmentRomStart + (temp_s2->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_2, &gDmaMesgQueue);
        osRecvMesg(&gDmaMesgQueue, &sp68, 1);
loop_9:
        temp_v0 = phi_s1->unk8;
        phi_s5 = phi_s5_3;
        if (temp_v0 == 0) {
            phi_s5 = (s8) (phi_s5_3 + 1);
        } else {
            temp_v1_2 = temp_v0->unk10;
            temp_t7 = sp60 * 4;
            if (temp_v1_2 != 0) {
                phi_s0_3 = (s32) temp_v1_2;
            }
            phi_s0_4 = phi_s0_3;
            if ((phi_s0_3 % 8) != 0) {
                phi_s0_4 = ((phi_s0_3 / 8) * 8) + 8;
            }
            osInvalDCache(temp_t7 + D_8018D9B4, phi_s0_4);
            osPiStartDma(&sp6C, 0, 0, sp58 + (temp_v0->unk4 & 0xFFFFFF), temp_t7 + D_8018D9B4, phi_s0_4, &gDmaMesgQueue);
        }
        mio0decode(D_8018D9B4, (D_8018E118[phi_s1->unk4].offset * 2) + D_8018D9B0);
        phi_s1->unk0 = NULL;
        temp_s1 = phi_s1 + 8;
        phi_s5_2 = phi_s5;
        if (phi_s5 == 0) {
            osRecvMesg(&gDmaMesgQueue, &sp68, 1);
            temp_v0_2 = temp_s1->unk8;
            if (temp_v0_2 == 0) {
                phi_s5_2 = (s8) (phi_s5 + 1);
            } else {
                temp_v1_3 = temp_v0_2->unk10;
                if (temp_v1_3 != 0) {
                    phi_s0_5 = (s32) temp_v1_3;
                }
                phi_s0_6 = phi_s0_5;
                if ((phi_s0_5 % 8) != 0) {
                    phi_s0_6 = ((phi_s0_5 / 8) * 8) + 8;
                }
                osInvalDCache(D_8018D9B4, phi_s0_6);
                osPiStartDma(&sp6C, 0, 0, sp58 + (temp_v0_2->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_6, &gDmaMesgQueue);
            }
            mio0decode((sp60 * 4) + D_8018D9B4, (D_8018E118[temp_s1->unk4].offset * 2) + D_8018D9B0);
            temp_s1->unk0 = 0;
            phi_s1 = temp_s1 + 8;
            phi_s5_3 = phi_s5_2;
            if (phi_s5_2 == 0) {
                osRecvMesg(&gDmaMesgQueue, &sp68, 1);
                goto loop_9;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099AEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018E0E8;

void func_80099E54(void) {
    D_8018E0E8 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099E54.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *segmented_to_virtual(segment_address_t); // extern
extern s32 D_8018E0E8;

void func_80099E60(s32 arg1, s32 arg2) {
    s32 *sp1C;
    s32 *temp_v1;
    s32 *phi_v1;
    s32 *phi_v1_2;

    phi_v1 = &D_8018E0E8;
    phi_v1_2 = &D_8018E0E8;
    if (D_8018E0E8 != 0) {
        do {
            temp_v1 = phi_v1 + 8;
            phi_v1 = temp_v1;
            phi_v1_2 = temp_v1;
        } while (phi_v1->unk8 != 0);
    }
    sp1C = phi_v1_2;
    phi_v1_2->unk0 = segmented_to_virtual(arg0);
    phi_v1_2->unk4 = arg1;
    phi_v1_2->unk6 = arg2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099E60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern OSMesgQueue gDmaMesgQueue;
extern void *D_8018D9B4;
extern void *D_8018E0E8;
extern ? _textures_0aSegmentRomStart;

void func_80099EC4(void) {
    ? sp68;
    void *sp64;
    s16 temp_v0_2;
    s16 temp_v0_4;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_s1;
    void *temp_s2;
    void *temp_v0;
    void *temp_v0_3;
    s32 phi_s0;
    u32 phi_s0_2;
    void **phi_s1;
    s32 phi_s0_3;
    u32 phi_s0_4;
    s8 phi_s4;
    s32 phi_s0_5;
    u32 phi_s0_6;
    s8 phi_s4_2;
    s8 phi_s4_3;

    temp_s2 = D_8018E0E8;
    phi_s1 = &D_8018E0E8;
    phi_s4_3 = 0;
    if (temp_s2 != 0) {
        temp_v1 = temp_s2->unk10;
        phi_s0 = 0x1400;
        phi_s0_3 = 0x1400;
        phi_s0_5 = 0x1400;
        if (temp_v1 != 0) {
            phi_s0 = temp_v1;
        }
        phi_s0_2 = phi_s0;
        if ((phi_s0 % 8) != 0) {
            phi_s0_2 = ((phi_s0 / 8) * 8) + 8;
        }
        osInvalDCache(D_8018D9B4, phi_s0_2);
        osPiStartDma(&sp68, 0, 0, &_textures_0aSegmentRomStart + (temp_s2->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_2, &gDmaMesgQueue);
        osRecvMesg(&gDmaMesgQueue, &sp64, 1);
loop_6:
        temp_v0 = phi_s1->unk8;
        phi_s4 = phi_s4_3;
        if (temp_v0 == 0) {
            phi_s4 = phi_s4_3 + 1;
        } else {
            temp_v1_2 = temp_v0->unk10;
            if (temp_v1_2 != 0) {
                phi_s0_3 = temp_v1_2;
            }
            phi_s0_4 = phi_s0_3;
            if ((phi_s0_3 % 8) != 0) {
                phi_s0_4 = ((phi_s0_3 / 8) * 8) + 8;
            }
            osInvalDCache(D_8018D9B4 + 0x1400, phi_s0_4);
            osPiStartDma(&sp68, 0, 0, &_textures_0aSegmentRomStart + (temp_v0->unk4 & 0xFFFFFF), D_8018D9B4 + 0x1400, phi_s0_4, &gDmaMesgQueue);
        }
        temp_v0_2 = phi_s1->unk4;
        mio0decode(D_8018D9B4, D_802BFB80 + (phi_s1->unk6 << 0x10) + ((temp_v0_2 / 2) << 0xF) + ((temp_v0_2 % 2) << 0xD) + 0x4000);
        phi_s1->unk0 = 0;
        temp_s1 = phi_s1 + 8;
        phi_s4_2 = phi_s4;
        if (phi_s4 == 0) {
            osRecvMesg(&gDmaMesgQueue, &sp64, 1);
            temp_v0_3 = temp_s1->unk8;
            if (temp_v0_3 == 0) {
                phi_s4_2 = phi_s4 + 1;
            } else {
                temp_v1_3 = temp_v0_3->unk10;
                if (temp_v1_3 != 0) {
                    phi_s0_5 = temp_v1_3;
                }
                phi_s0_6 = phi_s0_5;
                if ((phi_s0_5 % 8) != 0) {
                    phi_s0_6 = ((phi_s0_5 / 8) * 8) + 8;
                }
                osInvalDCache(D_8018D9B4, phi_s0_6);
                osPiStartDma(&sp68, 0, 0, &_textures_0aSegmentRomStart + (temp_v0_3->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_6, &gDmaMesgQueue);
            }
            temp_v0_4 = temp_s1->unk4;
            mio0decode(D_8018D9B4 + 0x1400, D_802BFB80 + (temp_s1->unk6 << 0x10) + ((temp_v0_4 / 2) << 0xF) + ((temp_v0_4 % 2) << 0xD) + 0x4000);
            temp_s1->unk0 = 0;
            phi_s1 = temp_s1 + 8;
            phi_s4_3 = phi_s4_2;
            if (phi_s4_2 == 0) {
                osRecvMesg(&gDmaMesgQueue, &sp64, 1);
                goto loop_6;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099EC4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018DEE0;
extern ? D_8018E060;

void func_8009A344(void) {
    ? *temp_v1;
    ? *phi_v1;

    phi_v1 = &D_8018DEE0;
    do {
        temp_v1 = phi_v1 + 0x60;
        temp_v1->unk-3C = 0;
        temp_v1->unk-24 = 0;
        temp_v1->unk-C = 0;
        temp_v1->unk-54 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 != &D_8018E060);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A344.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
? func_8009969C(u32, s32, Mk64_Animation_Part *);   /* extern */

s32 func_8009A374(Mk64_Animation_Part *arg0) {
    s32 sp24;
    struct_8018DEE0_entry *sp1C;
    Mk64_Animation_Part *temp_a2;
    Mk64_Animation_Part *temp_v0;
    s32 temp_a1;
    struct_8018DEE0_entry *temp_v1;
    struct_8018DEE0_entry *temp_v1_2;
    u32 temp_a0;
    s32 phi_a1;
    struct_8018DEE0_entry *phi_v1;
    s32 phi_a1_2;
    Mk64_Animation_Part *phi_a2;

    temp_v0 = segmented_to_virtual_dupe(arg0);
    temp_a2 = temp_v0;
    phi_a1 = 0;
    phi_a1_2 = 0;
    phi_a2 = temp_a2;
    if (D_8018DEE0->visible != 0) {
        phi_v1 = D_8018DEE0;
loop_2:
        temp_a1 = phi_a1 + 1;
        temp_v1 = phi_v1 + 0x18;
        phi_a1 = temp_a1;
        phi_v1 = temp_v1;
        phi_a1_2 = temp_a1;
        if (temp_a1 >= 0x10) {
loop_3:
            goto loop_3;
        }
        if (temp_v1->visible == 0) {
            goto block_5;
        }
        goto loop_2;
    }
block_5:
    temp_v1_2 = &D_8018DEE0[phi_a1_2];
    temp_v1_2->texutreSequence = temp_v0;
    temp_v1_2->sequenceIndex = -1;
    temp_v1_2->frameCountDown = 0;
    temp_v1_2->visible = 0x80000000;
    temp_v1_2->D_8018E118_index = gNumD_8018E118Entries;
    if (temp_v0->texture != 0) {
        arg0 = temp_a2;
        sp24 = phi_a1_2;
        sp1C = temp_v1_2;
        func_8009969C(temp_a2->texture, phi_a1_2, temp_a2);
        phi_a2 = arg0;
    }
    temp_a0 = phi_a2->unk8;
    if (temp_a0 != 0) {
        sp1C = &D_8018DEE0[phi_a1_2];
        sp24 = phi_a1_2;
        func_8009969C(temp_a0, phi_a1_2, phi_a2);
    } else {
        sp24 = phi_a1_2;
        sp1C = &D_8018DEE0[phi_a1_2];
        func_8009969C(phi_a2->texture, phi_a1_2, phi_a2);
    }
    D_8018DEE0[phi_a1_2].unk14 = 0;
    return sp24;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A374.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
? func_80099958(u32, s32, ?, s32);                  /* extern */

s32 func_8009A478(Mk64_Animation_Part *arg0, s32 arg1) {
    s32 sp2C;
    struct_8018DEE0_entry *sp24;
    Mk64_Animation_Part *temp_s0;
    Mk64_Animation_Part *temp_v0;
    s32 temp_a3;
    struct_8018DEE0_entry *temp_v1;
    struct_8018DEE0_entry *temp_v1_2;
    u32 temp_a0;
    s32 phi_a3;
    struct_8018DEE0_entry *phi_v1;
    s32 phi_a3_2;

    temp_v0 = segmented_to_virtual_dupe(arg0);
    temp_s0 = temp_v0;
    phi_a3 = 0;
    phi_a3_2 = 0;
    if (D_8018DEE0->visible != 0) {
        phi_v1 = D_8018DEE0;
loop_2:
        temp_a3 = phi_a3 + 1;
        temp_v1 = phi_v1 + 0x18;
        phi_a3 = temp_a3;
        phi_v1 = temp_v1;
        phi_a3_2 = temp_a3;
        if (temp_a3 >= 0x10) {
loop_3:
            goto loop_3;
        }
        if (temp_v1->visible == 0) {
            goto block_5;
        }
        goto loop_2;
    }
block_5:
    temp_v1_2 = &D_8018DEE0[phi_a3_2];
    temp_v1_2->texutreSequence = temp_v0;
    temp_v1_2->sequenceIndex = -1;
    temp_v1_2->frameCountDown = 0;
    temp_v1_2->visible = 0x80000000;
    temp_v1_2->D_8018E118_index = gNumD_8018E118Entries;
    if (temp_v0->texture != 0) {
        sp2C = phi_a3_2;
        sp24 = temp_v1_2;
        func_80099958(temp_s0->texture, arg1, 0, phi_a3_2);
    }
    temp_a0 = temp_s0->unk8;
    if (temp_a0 != 0) {
        sp24 = &D_8018DEE0[phi_a3_2];
        sp2C = phi_a3_2;
        func_80099958(temp_a0, arg1, 1, phi_a3_2);
    } else {
        sp2C = phi_a3_2;
        sp24 = &D_8018DEE0[phi_a3_2];
        func_80099958(temp_s0->texture, arg1, 1, phi_a3_2);
    }
    D_8018DEE0[phi_a3_2].unk14 = 0;
    return sp2C;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A478.s")
#endif

#ifdef NON_MATCHING
void func_80099A94(Mk64_Texture *, s32);                       /* extern */

// Non-matching due to the argument registers to an addu command being swapped.
void func_8009A594(s32 arg0, s32 arg1, segment_address_t arg2) {
    Mk64_Animation temp_v0;
    struct_8018DEE0_entry *temp_s0;
    Mk64_Texture *temp_v0_2;
    s32 thing = arg1;

    temp_v0 = segmented_to_virtual_dupe(arg2);
    temp_s0 = &D_8018DEE0[arg0];
    temp_s0->textureSequence = temp_v0;
    temp_s0->sequenceIndex = arg1;
    temp_s0->frameCountDown = temp_v0[arg1].frame_length;
    temp_v0_2 = segmented_to_virtual(temp_v0[thing].mk64Texture);
    if (temp_s0->unk14 != 0) {
        func_80099A94(temp_v0_2, temp_s0->D_8018E118_index);
        temp_s0->unk14 = 0;
    } else {
        func_80099A94(temp_v0_2, temp_s0->D_8018E118_index + 1);
        temp_s0->unk14 = 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A594.s")
#endif

#ifdef NON_MATCHING
// Non-matching due to the argument registers to an addu command being swapped.
// Also some stack mangement around the segmented_to_virtual call is wrong
extern void func_80099E60(Mk64_Texture *, s32, s32);
void func_8009A640(s32 arg0, s32 arg1, s32 arg2, segment_address_t arg3) {
    Mk64_Animation temp_v0;
    Mk64_Texture *temp_a0;
    s32 thing = arg1;

    temp_v0 = segmented_to_virtual_dupe(arg3);
    D_8018DEE0[arg0].textureSequence = temp_v0;
    D_8018DEE0[arg0].sequenceIndex = arg1;
    D_8018DEE0[arg0].frameCountDown = temp_v0[arg1].frame_length;
    temp_a0 = segmented_to_virtual(temp_v0[thing].mk64Texture);
    D_8018DEE0[arg0].unk14 ^= 1;
    func_80099E60(temp_a0, arg2, D_8018DEE0[arg0].unk14);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A640.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit dacbf209f1bb5d4acaecaf1fefff331d60ffd80c
extern ? D_8018E060;

UNUSED void func_8009A6D4(void) {
    struct_8018DEE0_entry *temp_s0;
    struct_8018DEE0_entry *phi_s0;

    phi_s0 = D_8018DEE0;
    do {
        if ((phi_s0->visible & 0x80000000) != 0) {
            func_8009A878(phi_s0);
            gDisplayListHead = func_8009C434((s32) gDisplayListHead, phi_s0, 0, 0, 0);
        }
        temp_s0 = phi_s0 + 0x18;
        phi_s0 = temp_s0;
    } while (temp_s0 != &D_8018E060);
    func_80099AEC();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A6D4.s")
#endif

void func_8009A76C(s32 arg0, s32 arg1, s32 arg2, s32 arg3) {
    struct_8018DEE0_entry *temp = &D_8018DEE0[arg0];
    if (temp->visible & 0x80000000) {
        func_8009A878(temp);
        gDisplayListHead = func_8009C434(gDisplayListHead, temp, arg1, arg2, arg3);
    }
}

void func_8009A7EC(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    struct_8018DEE0_entry *temp = &D_8018DEE0[arg0];
    if (temp->visible & 0x80000000) {
        func_8009A944(temp, arg3);
        gDisplayListHead = func_8009C708(gDisplayListHead, temp, arg1, arg2, arg3, arg4);
    }
}

#ifdef MIPS_TO_C
void func_80099A94(Mk64_Texture *, s32);                       /* extern */

segment_address_t func_8009A878(struct_8018DEE0_entry *arg0) {
    Mk64_Animation_Part *temp_v0;
    Mk64_Animation_Part *temp_v1;
    Mk64_Texture *temp_v0_2;

    temp_v1 = arg0->textureSequence;
    if (arg0->sequenceIndex < 0) {
        arg0->sequenceIndex = 0;
        arg0->frameCountDown = 0;
    }
    arg0->frameCountDown--;
    if (arg0->frameCountDown <= 0) {
        arg0->sequenceIndex++;
        temp_v0 = &temp_v1[arg0->sequenceIndex];
        if (temp_v0->mk64Texture == 0) {
            arg0->sequenceIndex = 0;
            temp_v0 = &temp_v1[0];
        }
        arg0->frameCountDown = temp_v0->frame_length;
        temp_v0_2 = segmented_to_virtual(temp_v0->mk64Texture);
        if (arg0->unk14 != 0) {
            func_80099A94(temp_v0_2, arg0->D_8018E118_index);
            arg0->unk14 = 0;
        } else {
            func_80099A94(temp_v0_2, arg0->D_8018E118_index + 1);
            arg0->unk14 = 1;
        }
    }
    return arg0->textureSequence[arg0->sequenceIndex].mk64Texture;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A878.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80099E60(s32, s32, s32, void *); // extern
void *segmented_to_virtual(segment_address_t); // extern

s32 func_8009A944(void *arg0, s32 arg1) {
    s32 *temp_v0;
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_t1;
    s32 temp_t3;
    s32 temp_t8;
    s32 temp_v1;
    void *temp_a3;
    s32 *phi_v0;
    void *phi_a3;

    temp_a3 = arg0;
    temp_v1 = arg0->unk0;
    phi_a3 = temp_a3;
    if (arg0->unk4 < 0) {
        arg0->unk4 = 0;
        arg0->unk8 = 0;
    }
    temp_t8 = temp_a3->unk8 - 1;
    temp_a3->unk8 = temp_t8;
    if (temp_t8 <= 0) {
        temp_t1 = temp_a3->unk4 + 1;
        temp_t3 = temp_t1 * 8;
        temp_a3->unk4 = temp_t1;
        temp_v0 = temp_v1 + temp_t3;
        phi_v0 = temp_v0;
        if (*temp_v0 == 0) {
            temp_a3->unk4 = 0;
            phi_v0 = temp_v1 + (0 * 8);
        }
        temp_a3->unk8 = phi_v0->unk4;
        arg0 = temp_a3;
        temp_a0 = segmented_to_virtual(phi_v0->unk0);
        temp_a2 = arg0->unk14 ^ 1;
        arg0->unk14 = temp_a2;
        func_80099E60(temp_a0, arg1, temp_a2, arg0);
        phi_a3 = arg0;
    }
    return *(phi_a3->unk0 + (phi_a3->unk4 * 8));
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A944.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
f64 func_800917B0(f64, f64);                        /* extern */
extern s32 D_8018D9B0;

void func_8009B0A4(s32 D_8018E118_index, s32 arg1) {
    f32 sp48;
    f32 *temp_s1;
    f64 temp_f10;
    f64 temp_f6;
    s16 *temp_a3_2;
    s32 temp_s0_2;
    s32 temp_t5;
    s32 temp_v1;
    struct_8018E118_entry *temp_v0;
    u16 *temp_a3;
    u16 temp_v0_2;
    u16 temp_v0_3;
    u16 temp_v0_4;
    u32 temp_s0;
    u32 temp_v1_2;
    u32 temp_v1_3;
    u32 temp_v1_4;
    s32 phi_s0;
    f64 phi_f10;
    f64 phi_f6;
    f32 *phi_s1;
    u32 phi_v1;
    u16 *phi_a3;
    u32 phi_v1_2;
    u32 phi_v1_3;
    s32 phi_s0_2;

    temp_f6 = (f64) arg1;
    phi_s0 = 0;
    phi_f6 = temp_f6;
    phi_s0_2 = 0;
    if (arg1 < 0) {
        phi_f6 = temp_f6 + 4294967296.0;
    }
    phi_s1 = &sp48;
    do {
        temp_f10 = (f64) phi_s0;
        phi_f10 = temp_f10;
        if (phi_s0 < 0) {
            phi_f10 = temp_f10 + 4294967296.0;
        }
        temp_s0 = phi_s0 + 1;
        temp_s1 = phi_s1 + 4;
        temp_s1->unk-4 = (f32) func_800917B0(phi_f10 * 0.03125, (phi_f6 * 1.5 * 0.00390625) + 0.25);
        phi_s0 = (s32) temp_s0;
        phi_s1 = temp_s1;
    } while (temp_s0 < 0x20U);
    temp_v0 = &D_8018E118[D_8018E118_index];
    temp_v1 = temp_v0->offset;
    temp_t5 = temp_v0->unkC - temp_v1;
    temp_a3 = (temp_v1 * 2) + D_8018D9B0;
    phi_a3 = temp_a3;
    if (temp_t5 != 0) {
        if ((temp_t5 & 1) != 0) {
            temp_v0_2 = *temp_a3;
            temp_v1_2 = (u32) ((&sp48)[(u32) ((((s32) (temp_v0_2 & 0xF800) >> 0xB) * 0x55) + (((s32) (temp_v0_2 & 0x7C0) >> 6) * 0x4B) + (((s32) (temp_v0_2 & 0x3E) >> 1) * 0x5F)) >> 8] * 32.0f);
            phi_v1 = temp_v1_2;
            phi_s0_2 = 1;
            if (temp_v1_2 >= 0x20U) {
                phi_v1 = 0x1FU;
            }
            *temp_a3 = (phi_v1 * 0x842) + (temp_v0_2 & 1);
            phi_a3 = temp_a3 + 2;
            if (temp_t5 != 1) {
                goto block_11;
            }
        } else {
block_11:
            do {
                temp_v0_3 = phi_a3->unk0;
                temp_s0_2 = phi_s0_2 + 2;
                temp_v1_3 = (u32) ((&sp48)[(u32) ((((s32) (temp_v0_3 & 0xF800) >> 0xB) * 0x55) + (((s32) (temp_v0_3 & 0x7C0) >> 6) * 0x4B) + (((s32) (temp_v0_3 & 0x3E) >> 1) * 0x5F)) >> 8] * 32.0f);
                phi_v1_2 = temp_v1_3;
                phi_s0_2 = temp_s0_2;
                if (temp_v1_3 >= 0x20U) {
                    phi_v1_2 = 0x1FU;
                }
                temp_v0_4 = phi_a3->unk2;
                phi_a3->unk0 = (phi_v1_2 * 0x842) + (temp_v0_3 & 1);
                temp_a3_2 = phi_a3 + 2;
                temp_v1_4 = (u32) ((&sp48)[(u32) ((((s32) (temp_v0_4 & 0xF800) >> 0xB) * 0x55) + (((s32) (temp_v0_4 & 0x7C0) >> 6) * 0x4B) + (((s32) (temp_v0_4 & 0x3E) >> 1) * 0x5F)) >> 8] * 32.0f);
                phi_v1_3 = temp_v1_4;
                if (temp_v1_4 >= 0x20U) {
                    phi_v1_3 = 0x1FU;
                }
                *temp_a3_2 = (phi_v1_3 * 0x842) + (temp_v0_4 & 1);
                phi_a3 = temp_a3_2 + 2;
            } while (temp_s0_2 != temp_t5);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B0A4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9B0;
extern ? D_8018E11C;

void func_8009B538(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    s32 temp_a0;
    s32 temp_v1;
    s32 temp_v1_2;
    u16 *temp_v0;
    u16 *temp_v0_2;
    u16 *temp_v0_3;
    u16 temp_a2;
    u16 temp_a2_2;
    u16 temp_a2_3;
    u16 temp_a2_4;
    u16 temp_a2_5;
    u32 temp_t6;
    u32 temp_t8;
    u32 temp_t8_2;
    u32 temp_t9;
    u32 temp_t9_2;
    u16 *phi_v0;
    s32 phi_v1;
    u16 *phi_v0_2;
    s32 phi_v1_2;

    temp_v0 = (*(&D_8018E11C + (arg0 * 8)) * 2) + D_8018D9B0;
    phi_v0 = temp_v0;
    phi_v1 = 0;
    phi_v0_2 = temp_v0;
    phi_v1_2 = 0;
    if (arg1 != 0) {
        temp_a0 = arg1 & 3;
        if (temp_a0 != 0) {
            do {
                temp_a2 = *phi_v0;
                temp_v1 = phi_v1 + 1;
                temp_v0_2 = phi_v0 + 2;
                temp_t9 = ((((temp_a2 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2 & 0x7C0) >> 6) * 0x96) + (((temp_a2 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_2->unk-2 = (((arg2 * temp_t9) >> 8) << 0xB) + (((arg3 * temp_t9) >> 8) << 6) + (((arg4 * temp_t9) >> 8) * 2) + (temp_a2 & 1);
                phi_v0 = temp_v0_2;
                phi_v1 = temp_v1;
                phi_v0_2 = temp_v0_2;
                phi_v1_2 = temp_v1;
            } while (temp_a0 != temp_v1);
            if (temp_v1 != arg1) {
                goto block_5;
            }
        } else {
block_5:
            do {
                temp_a2_2 = *phi_v0_2;
                temp_v1_2 = phi_v1_2 + 4;
                temp_v0_3 = phi_v0_2 + 8;
                temp_a2_3 = temp_v0_3->unk-6;
                temp_t8 = ((((temp_a2_2 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_2 & 0x7C0) >> 6) * 0x96) + (((temp_a2_2 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-8 = (((arg2 * temp_t8) >> 8) << 0xB) + (((arg3 * temp_t8) >> 8) << 6) + (((arg4 * temp_t8) >> 8) * 2) + (temp_a2_2 & 1);
                temp_a2_4 = temp_v0_3->unk-4;
                temp_t6 = ((((temp_a2_3 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_3 & 0x7C0) >> 6) * 0x96) + (((temp_a2_3 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-6 = (((arg2 * temp_t6) >> 8) << 0xB) + (((arg3 * temp_t6) >> 8) << 6) + (((arg4 * temp_t6) >> 8) * 2) + (temp_a2_3 & 1);
                temp_a2_5 = temp_v0_3->unk-2;
                temp_t9_2 = ((((temp_a2_4 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_4 & 0x7C0) >> 6) * 0x96) + (((temp_a2_4 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-4 = (((arg2 * temp_t9_2) >> 8) << 0xB) + (((arg3 * temp_t9_2) >> 8) << 6) + (((arg4 * temp_t9_2) >> 8) * 2) + (temp_a2_4 & 1);
                temp_t8_2 = ((((temp_a2_5 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_5 & 0x7C0) >> 6) * 0x96) + (((temp_a2_5 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-2 = (((arg2 * temp_t8_2) >> 8) << 0xB) + (((arg3 * temp_t8_2) >> 8) << 6) + (((arg4 * temp_t8_2) >> 8) * 2) + (temp_a2_5 & 1);
                phi_v0_2 = temp_v0_3;
                phi_v1_2 = temp_v1_2;
            } while (temp_v1_2 != arg1);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B538.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
extern s32 D_8018D9B0;

s32 func_8009B8C4(u32 arg0) {
    s32 sp4;
    s32 temp_a1;
    s32 temp_v1;
    struct_8018E118_entry *phi_a2;
    s32 phi_v1;
    s32 phi_v0;

    temp_a1 = gNumD_8018E118Entries;
    phi_v1 = 0;
    phi_v0 = 0;
    if (temp_a1 > 0) {
        phi_a2 = D_8018E118;
loop_2:
        temp_v1 = phi_v1 + 1;
        phi_v1 = temp_v1;
        if (arg0 == phi_a2->textureData) {
            sp4 = phi_a2->offset;
            phi_v0 = 1;
        } else {
            phi_a2 += 8;
            if (temp_v1 < temp_a1) {
                goto loop_2;
            }
        }
    }
    if (phi_v0 != 0) {
        return (sp4 * 2) + D_8018D9B0;
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B8C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9C0;
extern s32 D_8018E75C;
extern s32 D_8018E760;

void func_8009B938(void) {
    D_8018E75C = D_8018D9C0;
    D_8018E760 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B938.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *segmented_to_virtual(segment_address_t); // extern
extern s32 D_8018E75C;
extern s32 D_8018E760;
extern ? D_8018E768;

void func_8009B954(void) {
    void *temp_v1;

    temp_v1 = (D_8018E760 * 8) + &D_8018E768;
    temp_v1->unk0 = segmented_to_virtual();
    temp_v1->unk4 = D_8018E75C;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B954.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern void *D_8018E75C;
extern s32 D_8018E760;

void func_8009B998(void) {
    void *temp_v1;

    temp_v1 = D_8018E75C;
    D_8018E75C = temp_v1 + 8;
    temp_v1->unk4 = 0;
    temp_v1->unk0 = 0xB8000000;
    D_8018E760 = D_8018E760 + 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B998.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_8018E768;
extern ? D_8018E7A8;

void *func_8009B9D0(void *arg0, ? arg1) {
    s32 sp34;
    s32 sp2C;
    ? *temp_s0;
    void *temp_t0;
    void *temp_v0;
    ? *phi_s0;
    void *phi_v0;

    sp2C = 0;
    phi_s0 = &D_8018E768;
loop_1:
    temp_v0 = segmented_to_virtual(arg1);
    phi_v0 = temp_v0;
    if (temp_v0 == phi_s0->unk0) {
        sp2C = 1;
        sp34 = phi_s0->unk4;
    } else {
        temp_s0 = phi_s0 + 8;
        phi_s0 = temp_s0;
        if (temp_s0 != &D_8018E7A8) {
            goto loop_1;
        }
    }
    temp_t0 = arg0;
    if (sp2C != 0) {
        arg0 = temp_t0 + 8;
        temp_t0->unk0 = 0x6000000;
        temp_t0->unk4 = sp34;
        phi_v0 = arg0;
    }
    return phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B9D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void *func_80095E10(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32); /* extern */
void *func_800987D0(void *, ?, ?, u16, s32, s32, s32, s32, s32, s32); /* extern */
void *segmented_to_virtual(segment_address_t);                    /* extern */
static ? D_02007708;                                /* unable to generate initializer */
static ? D_02007728;                                /* unable to generate initializer */
static ? D_02007748;                                /* unable to generate initializer */
static ? D_02007768;                                /* unable to generate initializer */
static ? D_02007788;                                /* unable to generate initializer */

void *func_8009BA74(void *arg0, s32 arg1, s32 arg2, s32 arg3) {
    s32 temp_v0_2;
    u16 temp_s1;
    u16 temp_s1_2;
    u16 temp_t7;
    u16 temp_v0_3;
    u16 temp_v0_4;
    void *temp_v0;
    void *phi_s2;
    void *phi_s0;
    void *phi_s0_2;
    s8 phi_s4;
    void *phi_s0_3;
    void *phi_s0_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s2 = temp_v0;
    phi_s0 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_t7 = phi_s2->unk0;
            phi_s4 = 0;
            switch (temp_t7) {
            case 0:
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007708;
                phi_s0_2 = phi_s0 + 8;
                break;
            case 1:
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007728;
                phi_s0_2 = phi_s0 + 8;
                break;
            case 2:
                phi_s0->unk4 = &D_02007748;
                phi_s0->unk0 = 0x6000000;
                phi_s0_2 = phi_s0 + 8;
                break;
            case 3:
                phi_s0->unk4 = &D_02007768;
                phi_s0->unk0 = 0x6000000;
                phi_s0_2 = phi_s0 + 8;
                phi_s4 = 3;
                break;
            case 4:
                phi_s0->unk4 = &D_02007788;
                phi_s0->unk0 = 0x6000000;
                phi_s0_2 = phi_s0 + 8;
                break;
            default:
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007728;
                phi_s0_2 = phi_s0 + 8;
                break;
            }
            temp_v0_2 = func_8009B8C4(phi_s2->unk4);
            phi_s0_4 = phi_s0_2;
            if (temp_v0_2 != 0) {
                if (D_8018E7B0 != 4) {
                    temp_s1 = phi_s2->unk8;
                    temp_v0_3 = phi_s2->unkA;
                    phi_v0 = func_80095E10(phi_s0_2, phi_s4, 0x400, 0x400, 0, 0, temp_s1, temp_v0_3, phi_s2->unkC + arg2, phi_s2->unkE + arg3, temp_v0_2, temp_s1, temp_v0_3);
                } else {
                    temp_v0_4 = phi_s2->unkA;
                    temp_s1_2 = phi_s2->unk8;
                    phi_v0 = func_800987D0(phi_s0_2, 0, 0, temp_s1_2, temp_v0_4, phi_s2->unkC + arg2, phi_s2->unkE + arg3, temp_v0_2, temp_s1_2, temp_v0_4);
                }
                phi_s0_4 = phi_v0;
            }
            phi_s2 += 0x14;
            phi_s0 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
        } while (phi_s2->unk18 != 0);
    }
    return phi_s0_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009BA74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097274(void *, ?, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80097A14(void *, ?, ?, ?, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80097AE4(void *, ?, s32, s32, s32, s32); // extern
void *func_80097E58(void *, ?, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32); // extern
s32 func_8009B8C4(s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_02007708;
extern ? D_02007728;

void *func_8009BC9C(void *arg0, ? arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s16 temp_v0_2;
    s32 temp_v0_3;
    u16 temp_v0_4;
    u16 temp_v0_5;
    u16 temp_v0_6;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_v0;
    void *phi_s0;
    void *phi_s1;
    void *phi_s1_2;
    void *phi_s1_3;
    void *phi_s1_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s0 = temp_v0;
    phi_s1 = arg0;
    phi_s1_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v0_2 = phi_s0->unk0;
            phi_s1_2 = phi_s1;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {

                } else {
                    phi_s1->unk4 = &D_02007728;
                    phi_s1->unk0 = 0x6000000;
                    phi_s1_2 = phi_s1 + 8;
                }
            } else {
                phi_s1->unk0 = 0x6000000;
                phi_s1->unk4 = &D_02007708;
                phi_s1_2 = phi_s1 + 8;
            }
            temp_v0_3 = func_8009B8C4(phi_s0->unk4);
            phi_s1_4 = phi_s1_2;
            if (temp_v0_3 != 0) {
                if (arg4 != 1) {
                    if (arg4 != 2) {
                        if (arg4 != 3) {
                            if (arg4 != 4) {

                            } else {
                                temp_v0_4 = phi_s0->unk8;
                                temp_v1 = phi_s0->unkA;
                                phi_v0 = func_80097274(phi_s1_2, 0, 0x400, 0x400, 0, 0, temp_v0_4, temp_v1, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, temp_v0_4, temp_v1, arg5);
                                goto block_17;
                            }
                        } else {
                            temp_v0_5 = phi_s0->unk8;
                            temp_v1_2 = phi_s0->unkA;
                            phi_v0 = func_80097A14(phi_s1_2, 0, 0, 0, temp_v0_5, temp_v1_2, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, temp_v0_5, temp_v1_2);
                            goto block_17;
                        }
                    } else {
                        temp_v0_6 = phi_s0->unk8;
                        temp_v1_3 = phi_s0->unkA;
                        phi_v0 = func_80097E58(phi_s1_2, 0, 0, 0, temp_v0_6, temp_v1_3, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, temp_v0_6, temp_v1_3, arg5);
                        goto block_17;
                    }
                } else {
                    phi_v0 = func_80097AE4(phi_s1_2, 0, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, arg5);
block_17:
                    phi_s1_4 = phi_v0;
                }
            }
            phi_s0 += 0x14;
            phi_s1 = phi_s1_4;
            phi_s1_3 = phi_s1_4;
        } while (phi_s0->unk18 != 0);
    }
    return phi_s1_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009BC9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80095BD0(void *, s32, f32, f32, s32, s32, f32, f32); // extern
s32 func_8009B8C4(s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_020077F8;
extern ? D_02007818;

void *func_8009BEF0(void *arg0, ? arg1, f32 arg2, f32 arg3, s32 arg4, f32 arg5, f32 arg6) {
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f10;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f16_3;
    f32 temp_f18;
    f32 temp_f4;
    f32 temp_f6;
    f32 temp_f6_2;
    s32 temp_a1;
    s32 temp_v0_2;
    u16 temp_t0;
    u16 temp_t1;
    u16 temp_t2;
    u16 temp_t5;
    u16 temp_t6;
    u16 temp_t7;
    u16 temp_t8;
    u16 temp_t9;
    void *temp_s0;
    void *temp_v0;
    void *phi_s0;
    f32 phi_f6;
    f32 phi_f16;
    f32 phi_f6_2;
    f32 phi_f16_2;
    s32 phi_v0;
    void *phi_s1;
    f32 phi_f16_3;
    f32 phi_f4;
    f32 phi_f18;
    f32 phi_f10;
    void *phi_s1_2;
    s32 phi_v0_2;
    void *phi_s1_3;
    s32 phi_v0_3;
    void *phi_v0_4;
    s32 phi_v0_5;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s0 = temp_v0;
    phi_s1 = arg0;
    phi_s1_2 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_t7 = phi_s0->unkC;
            temp_f6 = temp_t7;
            phi_f6 = temp_f6;
            phi_s1_3 = phi_s1;
            phi_v0_5 = 0;
            if (temp_t7 < 0) {
                phi_f6 = temp_f6 + 4294967296.0f;
            }
            temp_f0 = phi_f6 + arg2;
            if (temp_f0 > 320.0f) {
                phi_v0_5 = 1;
            }
            temp_t8 = phi_s0->unk8;
            temp_f16 = temp_t8;
            phi_f16 = temp_f16;
            phi_v0_3 = phi_v0_5;
            if (temp_t8 < 0) {
                phi_f16 = temp_f16 + 4294967296.0f;
            }
            if ((temp_f0 + (phi_f16 * arg5)) < 0.0f) {
                phi_v0_3 = phi_v0_5 + 1;
            }
            temp_t9 = phi_s0->unkE;
            temp_f6_2 = temp_t9;
            phi_f6_2 = temp_f6_2;
            phi_v0_2 = phi_v0_3;
            if (temp_t9 < 0) {
                phi_f6_2 = temp_f6_2 + 4294967296.0f;
            }
            temp_f0_2 = phi_f6_2 + arg3;
            if (temp_f0_2 < 0.0f) {
                phi_v0_2 = phi_v0_3 + 1;
            }
            temp_t0 = phi_s0->unkA;
            temp_f16_2 = temp_t0;
            phi_f16_2 = temp_f16_2;
            phi_v0 = phi_v0_2;
            if (temp_t0 < 0) {
                phi_f16_2 = temp_f16_2 + 4294967296.0f;
            }
            if ((temp_f0_2 - (phi_f16_2 * arg6)) > 240.0f) {
                phi_v0 = phi_v0_2 + 1;
            }
            if (phi_v0 != 0) {

            } else {
                temp_v0_2 = func_8009B8C4(phi_s0->unk4);
                temp_a1 = temp_v0_2;
                if (temp_v0_2 != 0) {
                    if (arg4 != 1) {
                        if (arg4 != 2) {

                        } else {
                            phi_s1->unk0 = 0x6000000;
                            phi_s1->unk4 = &D_02007818;
                            temp_t5 = phi_s0->unkC;
                            temp_f16_3 = temp_t5;
                            phi_f16_3 = temp_f16_3;
                            if (temp_t5 < 0) {
                                phi_f16_3 = temp_f16_3 + 4294967296.0f;
                            }
                            temp_t6 = phi_s0->unkE;
                            temp_f4 = temp_t6;
                            phi_f4 = temp_f4;
                            if (temp_t6 < 0) {
                                phi_f4 = temp_f4 + 4294967296.0f;
                            }
                            phi_v0_4 = func_80095BD0(phi_s1 + 8, temp_a1, phi_f16_3 + arg2, phi_f4 + arg3, phi_s0->unk8, phi_s0->unkA, arg5, arg6);
                            goto block_34;
                        }
                    } else {
                        phi_s1->unk0 = 0x6000000;
                        phi_s1->unk4 = &D_020077F8;
                        temp_t1 = phi_s0->unkC;
                        temp_f18 = temp_t1;
                        phi_f18 = temp_f18;
                        if (temp_t1 < 0) {
                            phi_f18 = temp_f18 + 4294967296.0f;
                        }
                        temp_t2 = phi_s0->unkE;
                        temp_f10 = temp_t2;
                        phi_f10 = temp_f10;
                        if (temp_t2 < 0) {
                            phi_f10 = temp_f10 + 4294967296.0f;
                        }
                        phi_v0_4 = func_80095BD0(phi_s1 + 8, temp_a1, phi_f18 + arg2, phi_f10 + arg3, phi_s0->unk8, phi_s0->unkA, arg5, arg6);
block_34:
                        phi_s1_3 = phi_v0_4;
                    }
                }
            }
            temp_s0 = phi_s0 + 0x14;
            phi_s0 = temp_s0;
            phi_s1 = phi_s1_3;
            phi_s1_2 = phi_s1_3;
        } while (temp_s0->unk4 != 0);
    }
    return phi_s1_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009BEF0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800963F0(void *, s8, ?, ?, f32, f32, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
s32 func_8009B8C4(s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_02007708;
extern ? D_02007728;
extern ? D_02007768;
extern f32 D_800F1074;

void *func_8009C204(void *arg0, ? arg1, s32 arg2, s32 arg3, s32 arg4) {
    f32 temp_f22;
    s16 temp_v0_2;
    s32 temp_v0_3;
    u16 temp_v0_4;
    u16 temp_v0_5;
    u16 temp_v1;
    u16 temp_v1_2;
    void *temp_v0;
    void *phi_s1;
    void *phi_s0;
    void *phi_s0_2;
    s8 phi_s2;
    void *phi_s0_3;
    void *phi_s0_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s1 = temp_v0;
    phi_s0 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0->unk4 != 0) {
        temp_f22 = D_800F1074;
        do {
            temp_v0_2 = phi_s1->unk0;
            phi_s2 = 0;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {
                    if (temp_v0_2 != 3) {
                        phi_s0->unk0 = 0x6000000;
                        phi_s0->unk4 = &D_02007728;
                        phi_s0_2 = phi_s0 + 8;
                    } else {
                        phi_s0->unk4 = &D_02007768;
                        phi_s0->unk0 = 0x6000000;
                        phi_s0_2 = phi_s0 + 8;
                        phi_s2 = 3;
                    }
                } else {
                    phi_s0->unk0 = 0x6000000;
                    phi_s0->unk4 = &D_02007728;
                    phi_s0_2 = phi_s0 + 8;
                }
            } else {
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007708;
                phi_s0_2 = phi_s0 + 8;
            }
            temp_v0_3 = func_8009B8C4(phi_s1->unk4);
            phi_s0_4 = phi_s0_2;
            if (arg4 != 2) {
                if (arg4 != 3) {

                } else {
                    temp_v0_4 = phi_s1->unk8;
                    temp_v1 = phi_s1->unkA;
                    phi_v0 = func_800963F0(phi_s0_2, phi_s2, 0x400, 0x400, temp_f22, 0.5f, 0, 0, temp_v0_4, temp_v1, phi_s1->unkC + arg2, phi_s1->unkE + arg3, temp_v0_3, temp_v0_4, temp_v1);
                    goto block_14;
                }
            } else {
                temp_v0_5 = phi_s1->unk8;
                temp_v1_2 = phi_s1->unkA;
                phi_v0 = func_800963F0(phi_s0_2, phi_s2, 0x400, 0x400, 0.5f, 0.5f, 0, 0, temp_v0_5, temp_v1_2, phi_s1->unkC + arg2, phi_s1->unkE + arg3, temp_v0_3, temp_v0_5, temp_v1_2);
block_14:
                phi_s0_4 = phi_v0;
            }
            phi_s1 += 0x14;
            phi_s0 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
        } while (phi_s1->unk18 != 0);
    }
    return phi_s0_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C204.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80095E10(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_800963F0(void *, s8, ?, ?, f32, f32, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80097E58(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_02007708;
extern ? D_02007728;
extern ? D_02007768;
extern s32 D_8018D9B0;
extern ? D_8018E11C;
extern ? D_8018E124;

void *func_8009C434(void *arg0, void *arg1, s32 arg2, s32 arg3, s32 arg4) {
    s16 temp_v0_2;
    u16 temp_v0_3;
    u16 temp_v0_4;
    u16 temp_v0_5;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_v0;
    void *phi_s0;
    void *phi_s1;
    void *phi_s1_2;
    s8 phi_t1;
    s32 phi_t0;
    void *phi_s1_3;
    void *phi_s1_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(*(arg1->unk0 + (arg1->unk4 * 8)));
    phi_s0 = temp_v0;
    phi_s1 = arg0;
    phi_s1_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v0_2 = phi_s0->unk0;
            phi_t1 = 0;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {
                    if (temp_v0_2 != 3) {
                        phi_s1->unk0 = 0x6000000;
                        phi_s1->unk4 = &D_02007728;
                        phi_s1_2 = phi_s1 + 8;
                    } else {
                        phi_s1->unk4 = &D_02007768;
                        phi_s1->unk0 = 0x6000000;
                        phi_s1_2 = phi_s1 + 8;
                        phi_t1 = 3;
                    }
                } else {
                    phi_s1->unk0 = 0x6000000;
                    phi_s1->unk4 = &D_02007728;
                    phi_s1_2 = phi_s1 + 8;
                }
            } else {
                phi_s1->unk0 = 0x6000000;
                phi_s1->unk4 = &D_02007708;
                phi_s1_2 = phi_s1 + 8;
            }
            phi_s1_4 = phi_s1_2;
            if (arg1->unk14 != 0) {
                phi_t0 = *(&D_8018E124 + (arg1->unk10 * 8));
            } else {
                phi_t0 = *(&D_8018E11C + (arg1->unk10 * 8));
            }
            if (arg4 >= 0) {
                temp_v0_3 = phi_s0->unk8;
                temp_v1 = phi_s0->unkA;
                phi_v0 = func_80097E58(phi_s1_2, phi_t1, 0, 0, temp_v0_3, temp_v1, phi_s0->unkC + arg2, phi_s0->unkE + arg3, (phi_t0 * 2) + D_8018D9B0, temp_v0_3, temp_v1, arg4);
                goto block_18;
            }
            if (arg4 != -2) {
                if (arg4 == -1) {
                    temp_v0_4 = phi_s0->unk8;
                    temp_v1_2 = phi_s0->unkA;
                    phi_v0 = func_80095E10(phi_s1_2, phi_t1, 0x400, 0x400, 0, 0, temp_v0_4, temp_v1_2, phi_s0->unkC + arg2, phi_s0->unkE + arg3, (phi_t0 * 2) + D_8018D9B0, temp_v0_4, temp_v1_2);
                    goto block_18;
                }
            } else {
                temp_v0_5 = phi_s0->unk8;
                temp_v1_3 = phi_s0->unkA;
                phi_v0 = func_800963F0(phi_s1_2, phi_t1, 0x400, 0x400, 0.5f, 0.5f, 0, 0, temp_v0_5, temp_v1_3, phi_s0->unkC + arg2, phi_s0->unkE + arg3, (phi_t0 * 2) + D_8018D9B0, temp_v0_5, temp_v1_3);
block_18:
                phi_s1_4 = phi_v0;
            }
            phi_s0 += 0x14;
            phi_s1 = phi_s1_4;
            phi_s1_3 = phi_s1_4;
        } while (phi_s0->unk18 != 0);
    }
    return phi_s1_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C434.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097E58(void *, s8, ?, ?, s32, s32, s32, s32, u8 *, s32, s32, s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_02007708;
extern ? D_02007728;
extern ? D_02007748;
extern ? D_02007768;

void *func_8009C708(void *arg0, void *arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s16 temp_v0_2;
    u16 temp_v0_3;
    u16 temp_v1;
    void *temp_v0;
    void *phi_s1;
    void *phi_s0;
    void *phi_s0_2;
    s8 phi_t0;
    void *phi_s0_3;
    void *phi_s0_4;

    temp_v0 = segmented_to_virtual(*(arg1->unk0 + (arg1->unk4 * 8)));
    phi_s1 = temp_v0;
    phi_s0 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v0_2 = phi_s1->unk0;
            phi_t0 = 0;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {
                    if (temp_v0_2 != 2) {
                        if (temp_v0_2 != 3) {
                            phi_s0->unk0 = 0x6000000;
                            phi_s0->unk4 = &D_02007728;
                            phi_s0_2 = phi_s0 + 8;
                        } else {
                            phi_s0->unk4 = &D_02007768;
                            phi_s0->unk0 = 0x6000000;
                            phi_s0_2 = phi_s0 + 8;
                            phi_t0 = 3;
                        }
                    } else {
                        phi_s0->unk4 = &D_02007748;
                        phi_s0->unk0 = 0x6000000;
                        phi_s0_2 = phi_s0 + 8;
                    }
                } else {
                    phi_s0->unk0 = 0x6000000;
                    phi_s0->unk4 = &D_02007728;
                    phi_s0_2 = phi_s0 + 8;
                }
            } else {
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007708;
                phi_s0_2 = phi_s0 + 8;
            }
            phi_s0_4 = phi_s0_2;
            if (arg5 >= 0) {
                temp_v0_3 = phi_s1->unk8;
                temp_v1 = phi_s1->unkA;
                phi_s0_4 = func_80097E58(phi_s0_2, phi_t0, 0, 0, temp_v0_3, temp_v1, phi_s1->unkC + arg2, phi_s1->unkE + arg3, &D_802BFB80[(arg1->unk14 << 0x10) + ((arg4 / 2) << 0xF) + ((arg4 % 2) << 0xD) + 0x4000], temp_v0_3, temp_v1, arg5);
            }
            phi_s1 += 0x14;
            phi_s0 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
        } while (phi_s1->unk18 != 0);
    }
    return phi_s0_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C708.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s16 D_8015F4AC;
extern s16 D_8015F4AE;
extern s16 D_8015F4B0;
extern s16 D_8015F4B2;
extern s16 D_8015F4EC;
extern s16 D_8015F4EE;
extern s16 D_8015F4F0;
extern s16 D_8015F4F2;
extern s16 D_8015F52C;
extern s16 D_8015F52E;
extern s16 D_8015F530;
extern s16 D_8015F532;
extern s16 D_8015F56C;
extern s16 D_8015F56E;
extern s16 D_8015F570;
extern s16 D_8015F572;
extern ? D_8018E7E8;
extern s16 D_8018E7F0;
extern s16 D_8018E7F8;
extern s16 D_8018E802;
extern ? D_8018E810;
extern s16 D_8018E818;
extern s16 D_8018E822;
extern s16 D_8018E828;

void func_8009C918(void) {
    D_8018E7E8.unk0 = D_8015F4B0;
    D_8018E7E8.unk0 = D_8015F4B2;
    D_8018E810.unk0 = D_8015F4AC;
    D_8018E810.unk0 = D_8015F4AE;
    D_8018E7F0 = D_8015F4F2;
    D_8018E7F0 = D_8015F4F0;
    D_8018E818 = D_8015F4EE;
    D_8018E818 = D_8015F4EC;
    D_8018E7F8 = D_8015F532;
    D_8018E7F8 = D_8015F530;
    D_8018E822 = D_8015F52C;
    D_8018E822 = D_8015F52E;
    D_8018E802 = D_8015F570;
    D_8018E802 = D_8015F572;
    D_8018E828 = D_8015F56E;
    D_8018E828 = D_8015F56C;
    D_8018E7E8.unk20 = 0xA0;
    D_8018E7E8.unk22 = 0x78;
    D_8018E810.unk20 = 0x140;
    D_8018E810.unk22 = 0xF0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C918.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009CA6C(s32); // extern

void func_8009CA2C(void) {
    s32 temp_s0;
    s32 phi_s0;

    phi_s0 = 0;
    do {
        func_8009CA6C(phi_s0);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 != 5);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CA2C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009CDDC(s32, ?, s32);                       /* extern */
? func_8009CDFC(s32, ?, s32);                       /* extern */
? func_8009D958(s32, ?, s32);                       /* extern */
? func_8009D978(s32, ?, s32);                       /* extern */
? func_8009D998(s32, ?, s32);                       /* extern */
? func_8009DAA8(Gfx **, ?, s32);                    /* extern */
? func_8009DB8C(Gfx **, ?, s32);                    /* extern */
s32 func_800AAF30(?);                               /* extern */
extern ? D_0D0076F8;
extern ? D_8018E7AC;

void func_8009CA6C(s32 arg0) {
    Gfx *temp_v1;
    u8 temp_t0;
    ? phi_a1;

    if ((arg0 == 4) || ((arg0 = arg0, (func_800AAF30(0xAA) == 0)) && (arg0 = arg0, (func_800AAF30(0xAB) == 0)) && (arg0 = arg0, (func_800AAF30(0xB9) == 0)) && (arg0 = arg0, (func_800AAF30(0xBA) == 0)) && (arg0 = arg0, (func_800AAF30(0xAC) == 0)) && (arg0 = arg0, (func_800AAF30(0xB0) == 0)))) {
        temp_v1 = gDisplayListHead;
        gDisplayListHead = temp_v1 + 8;
        temp_v1->words.w0 = 0x6000000;
        temp_v1->words.w1 = &D_0D0076F8;
        phi_a1 = 0;
        if ((arg0 != 4) && (D_800DC5FC != 0)) {
            phi_a1 = 1;
        }
        temp_t0 = *(&D_8018E7AC + arg0);
        switch (temp_t0) {
        case 1:
            func_8009CDDC(arg0, phi_a1, arg0);
            return;
        case 2:
            func_8009D958(arg0, phi_a1, arg0);
            return;
        case 3:
            func_8009DB8C(&gDisplayListHead, phi_a1, arg0);
            return;
        case 4:
            func_8009DAA8(&gDisplayListHead, phi_a1, arg0);
            return;
        case 5:
            func_8009D998(arg0, phi_a1, arg0);
            return;
        case 7:
            func_8009D978(arg0, phi_a1, arg0);
            return;
        case 8:
            func_8009CDFC(arg0, phi_a1, arg0);
            /* Duplicate return node #19. Try simplifying control flow for better match */
            return;
        }
    } else {
    default:
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CA6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern ? D_800E7AE8;
extern ? D_8015F480;
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern ? D_8018E7D0;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s8 D_8018EE0C;
extern s32 gDisplayListHead;

void func_8009CBE4(s32 arg0, s32 arg1, s32 arg2) {
    u32 *sp40;
    u32 *sp3C;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v1_3;
    u32 *temp_t4;
    u32 *temp_t9;
    u32 temp_t6;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_v0_3;
    void *temp_v0_5;
    void *temp_v1;
    void *temp_v1_2;
    s16 phi_t2;
    s32 phi_t5;
    s16 phi_t3;
    s32 phi_ra;

    temp_v0 = gModeSelection;
    if ((temp_v0 == GRAND_PRIX) || (temp_v0 == TIME_TRIALS)) {
        temp_v0_4 = arg0 * 8;
        temp_v1_2 = temp_v0_4 + &D_8018E7E8;
        temp_a0_2 = temp_v0_4 + &D_8018E810;
        phi_t2 = temp_v1_2->unk0;
        phi_t5 = temp_a0_2->unk0;
        phi_t3 = temp_v1_2->unk2;
        phi_ra = temp_a0_2->unk2;
    } else {
        temp_v0_2 = arg0 * 8;
        if (arg0 >= 4) {
            temp_v1 = temp_v0_2 + &D_8018E7E8;
            temp_a0 = temp_v0_2 + &D_8018E810;
            phi_t2 = temp_v1->unk0;
            phi_t5 = temp_a0->unk0;
            phi_t3 = temp_v1->unk2;
            phi_ra = temp_a0->unk2;
        } else {
            temp_v0_3 = (arg0 << 6) + &D_8015F480;
            phi_t2 = temp_v0_3->unk30;
            phi_t5 = temp_v0_3->unk2C;
            phi_t3 = temp_v0_3->unk32;
            phi_ra = temp_v0_3->unk2E;
        }
    }
    temp_v0_5 = (arg2 * 8) + &D_800E7AE8;
    temp_t1 = arg0 * 4;
    temp_t4 = temp_t1 + &D_8018E7D0;
    temp_v1_3 = phi_t5 / 2;
    temp_t0 = phi_ra / 2;
    temp_t9 = temp_t1 + &D_8018E7B8;
    sp3C = temp_t9;
    sp40 = temp_t4;
    gDisplayListHead = draw_box(gDisplayListHead, phi_t2 - temp_v1_3, phi_t3 - temp_t0, temp_v1_3 + phi_t2, temp_t0 + phi_t3, temp_v0_5->unk0, temp_v0_5->unk2, temp_v0_5->unk4, 0xFF - ((*temp_t4 * 0xFF) / *temp_t9));
    if ((arg1 == 0) && (temp_t6 = *temp_t4 + 1, *temp_t4 = temp_t6, ((temp_t6 < *sp3C) == 0))) {
        if (D_800DC50C == RACING) {
            *(&D_8018E7AC + arg0) = 6;
            return;
        }
        *(&D_8018E7AC + arg0) = 0;
        D_8018EE0C = 0;
        // Duplicate return node #11. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CBE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009CBE4(?); // extern

void func_8009CDDC(void) {
    func_8009CBE4(0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CDDC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009CBE4(?); // extern

void func_8009CDFC(void) {
    func_8009CBE4(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CDFC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800C3448(?); // extern
extern u8 gSoundMode;

void func_8009CE1C(void) {
    if ((gSoundMode != 3) && (gPlayerCountSelection1 >= 2)) {
        func_800C3448(0xE0000002);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CE1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8000F124(s8, s32);                           /* extern */
? func_8009CE1C(s32 *, s32, s32);                   /* extern */
void *func_800AAF30(?, s32, s32);                   /* extern */
? func_80290338();                                  /* extern */
? func_80290360();                                  /* extern */
? func_80290388();                                  /* extern */
? func_802903B0();                                  /* extern */
extern ? D_8018E7AC;
extern ? D_8018E7B0;
static ? gCupSelectionByCourseId;                                /* unable to generate initializer; const */
static ? gCharacterSelections;                                /* unable to generate initializer; const */
static ? gPerCupIndexByCourseId;                                /* unable to generate initializer; const */
s16 gCreditsCourseId;                                     /* unable to generate initializer */
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_8009CE64(s32 *arg0, s32 arg2, s32 arg3) {
    s32 sp28;
    s8 *sp18;
    s16 temp_a0;
    s16 temp_a0_2;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 temp_v1_8;
    s8 *temp_v0_2;
    s8 temp_v1_4;
    s8 temp_v1_7;
    s8 temp_v1_9;
    u32 temp_t9;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    s32 phi_a1;
    s32 phi_a1_2;
    s32 phi_a1_3;
    s32 phi_t7;
    s32 *phi_a0;
    s32 phi_a2;
    s32 phi_v0;

    temp_v0 = D_800DC50C;
    phi_a1 = 0;
    phi_a1_2 = 0;
    phi_a1_3 = 0;
    phi_a0 = arg0;
    phi_a2 = arg3;
    phi_a2 = arg3;
    phi_a2 = arg3;
    if (temp_v0 == ENDING_SEQUENCE) {
        temp_v1 = gCCSelection;
        if ((temp_v1 != CC_150) && (temp_v1 != CC_EXTRA)) {

        } else if ((D_802874F5 < 3) && (gCupSelection == SPECIAL_CUP)) {
            phi_a1 = 1;
        }
        if (phi_a1 != 0) {
            gMenuSelectionFromEndingSequence = CREDITS_SEQUENCE;
            gCreditsCourseId = COURSE_LUIGI_RACEWAY;
            return;
        }
        gMenuSelectionFromEndingSequence = MAIN_MENU_FROM_QUIT;
        gMenuSelection = MAIN_MENU;
        return;
    }
    if (temp_v0 == RACING) {
        temp_v0_2 = arg0 + &D_8018E7AC;
        if (*temp_v0_2 == 2) {
            if (temp_v0_2 != &D_8018E7B0) {
                *temp_v0_2 = 5;
                return;
            }
            sp18 = temp_v0_2;
            sp28 = 0;
            temp_v0_3 = func_800AAF30(0xB0, 0, 2);
            if (temp_v0_3 != 0) {
                temp_v1_2 = temp_v0_3->unk4;
                if (temp_v1_2 != 0xA) {
                    if (temp_v1_2 != 0xB) {
                        if (temp_v1_2 != 0xC) {
                            if (temp_v1_2 != 0xD) {

                            }
                            func_80290338();
                            return;
                        }
                        func_80290360();
                        return;
                    }
                    func_80290388();
                    return;
                }
                func_802903B0();
                return;
            }
            sp28 = 0;
            temp_v0_4 = func_800AAF30(0xAC, 0);
            if (temp_v0_4 != 0) {
                temp_v1_3 = temp_v0_4->unk4;
                if (temp_v1_3 != 0xB) {
                    if (temp_v1_3 != 0xC) {

                    }
                    func_80290338();
                    return;
                }
                func_802903B0();
                D_8016556E = 1;
                return;
            }
            sp28 = 0;
            temp_v0_5 = func_800AAF30(0xC7, 0);
            if (temp_v0_5 != 0) {
                temp_t6 = temp_v0_5->unk4;
                switch (temp_t6) {                  /* switch 1 */
                case 12:                            /* switch 1 */
                    func_802903B0();
                    phi_a1_2 = 1;
                    break;
                case 13:                            /* switch 1 */
                case 22:                            /* switch 1 */
                case 42:                            /* switch 1 */
                    func_80290388();
                    phi_a1_2 = 1;
                    break;
                case 14:                            /* switch 1 */
                case 23:                            /* switch 1 */
                case 43:                            /* switch 1 */
                    func_80290360();
                    phi_a1_2 = 1;
                    break;
                case 15:                            /* switch 1 */
                case 24:                            /* switch 1 */
                case 32:                            /* switch 1 */
                case 44:                            /* switch 1 */
                    func_80290338();
                    phi_a1_2 = 1;
                    break;
                default:                            /* switch 1 */
                    *sp18 = 5;
                    break;
                }
                phi_a1_3 = phi_a1_2;
                if (phi_a1_2 != 0) {
                    D_800DC5FC = 0;
                }
            }
            temp_v0_6 = func_800AAF30(0xBD, phi_a1_3);
            if (temp_v0_6 != 0) {
                temp_t6_2 = temp_v0_6->unk4;
                switch (temp_t6_2) {                /* switch 2 */
                case 11:                            /* switch 2 */
                    D_8015F892 = 1;
                    D_8015F890 = 0;
                    func_802903B0();
                    return;
                case 12:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 0;
                    func_80290388();
                    return;
                case 13:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 0;
                    func_80290360();
                    return;
                case 14:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 0;
                    func_80290338();
                    return;
                case 15:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 1;
                    func_802903B0();
                    return;
                }
            } else {
                *sp18 = 5;
            }
        } else {
            /* Duplicate return node #115. Try simplifying control flow for better match */
        }
    } else {
        *(&D_8018E7AC + arg0) = 0;
        if (gDebugMenuSelection != DEBUG_MENU_EXITED) {
            temp_t9 = D_8018EDE0;
            switch (temp_t9) {                      /* switch 3 */
            case 0:                                 /* switch 3 */
                temp_v0_7 = gMenuSelection;
                phi_t7 = temp_v0_7 + 1;
                phi_a0 = &gMenuSelection;
                phi_a2 = 2;
                phi_a2 = 2;
                if (temp_v0_7 == LOGO_INTRO_MENU) {
                    gMenuSelection = START_MENU;
                    D_800E86A4 = 2;
                } else {
block_74:
                    gMenuSelection = phi_t7;
                    phi_a0 = &gMenuSelection;
                }
                break;
            case 1:                                 /* switch 3 */
                gMenuSelection += -1;
                phi_a0 = &gMenuSelection;
                break;
            // Setting up game state for title screen demos
            case 2:                                 /* switch 3 */
                D_800DC51C = 1;
                D_8018EE08 = 1;

                D_800DC524 = RACING;
                gCCSelection = CC_100;
                switch (gNextDemoId) {                /* switch 4 */
                case DEMO_ONE:                             /* switch 4 */
                    gCurrentCourseId = COURSE_MARIO_RACEWAY;
                    gScreenModeSelection = SCREEN_MODE_1P;
                    gPlayerCountSelection1 = 1;
                    D_8018EDF3 = ONE_PLAYERS_SELECTED;
                    gCharacterSelections[0] = MARIO;
                    gModeSelection = GRAND_PRIX;
                    break;
                case DEMO_TWO:                             /* switch 4 */
                    gCurrentCourseId = COURSE_CHOCO_MOUNTAIN;
                    gScreenModeSelection = SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL;
                    gPlayerCountSelection1 = 2;
                    D_8018EDF3 = TWO_PLAYERS_SELECTED;
                    gCharacterSelections[0] = YOSHI;
                    gCharacterSelections[1] = DK;
                    gModeSelection = VERSUS;
                    phi_a2 = 2;
                    break;
                case DEMO_THREE:                             /* switch 4 */
                    gCurrentCourseId = COURSE_KALAMARI_DESERT;
                    gScreenModeSelection = SCREEN_MODE_1P;
                    gPlayerCountSelection1 = 1;
                    D_8018EDF3 = ONE_PLAYERS_SELECTED;
                    gCharacterSelections[0] = LUIGI;
                    gModeSelection = GRAND_PRIX;
                    break;
                case DEMO_FOUR:                             /* switch 4 */
                    gCurrentCourseId = COURSE_WARIO_STADIUM;
                    gScreenModeSelection = SCREEN_MODE_3P_4P_SPLITSCREEN;
                    gPlayerCountSelection1 = 3;
                    D_8018EDF3 = THREE_PLAYERS_SELECTED;
                    gCharacterSelections[0] = WARIO;
                    gCharacterSelections[1] = YOSHI;
                    gCharacterSelections[2] = BOWSER;
                    gModeSelection = VERSUS;
                    phi_a2 = 2;
                    break;
                case DEMO_FIVE:                             /* switch 4 */
                    gCurrentCourseId = COURSE_BOWSER_CASTLE;
                    gScreenModeSelection = SCREEN_MODE_1P;
                    gPlayerCountSelection1 = 1;
                    D_8018EDF3 = ONE_PLAYERS_SELECTED;
                    gCharacterSelections[0] = BOWSER;
                    gModeSelection = GRAND_PRIX;
                    phi_a2 = 2;
                    break;
                case DEMO_SIX:                             /* switch 4 */
                    gCurrentCourseId = COURSE_SHERBET_LAND;
                    gScreenModeSelection = SCREEN_MODE_3P_4P_SPLITSCREEN;
                    gPlayerCountSelection1 = 4;
                    D_8018EDF3 = FOUR_PLAYERS_SELECTED;
                    gCharacterSelections[0] = MARIO;
                    gCharacterSelections[1] = LUIGI;
                    gCharacterSelections[2] = PEACH;
                    gCharacterSelections[3] = TOAD;
                    gModeSelection = VERSUS;
                    phi_a2 = 2;
                    break;
                }
                gNextDemoId += 1;
                if (gNextDemoId >= NUM_DEMOS) {
                    gNextDemoId = DEMO_ONE;
                }
                gCupSelection = gCupSelectionByCourseId[gCurrentCourseId];
                D_800DC540 = gCupSelection;
                gCupCourseSelection = gPerCupIndexByCourseId[gCurrentCourseId];
                phi_a0 = gCurrentCourseId;
                break;
            case 3:                                 /* switch 3 */
                temp_v1_5 = gMenuSelection;
                phi_a0 = &gMenuSelection;
                if (temp_v1_5 != DATA_MENU) {
                    if (temp_v1_5 == MAIN_MENU) {
                        gMenuSelection = DATA_MENU;
                    }
                } else {
                    gMenuSelection = MAIN_MENU;
                }
                break;
            case 4:                                 /* switch 3 */
                temp_v1_6 = gMenuSelection;
                phi_t7 = 0xB;
                phi_a0 = &gMenuSelection;
                if (temp_v1_6 != OPTIONS_MENU) {
                    if (temp_v1_6 == MAIN_MENU) {
                        gMenuSelection = OPTIONS_MENU;
                    }
                } else {
                    goto block_74;
                }
                break;
            }
            if (D_800E86A4 == 0) {
                D_800E86A4 = 1;
            }
            if (gMenuSelection >= RACING_DUPLICATE) {
                D_800DC524 = RACING;
                if (gModeSelection == TIME_TRIALS) {
                    D_8018EDFB = 1;
                }
                func_8009CE1C(phi_a0, 1, phi_a2);
            }
            D_8018EE0C = 0;
            return;
        }
        temp_v1_7 = gDebugGotoScene;
        if (temp_v1_7 != DEBUG_GOTO_ENDING_SEQUENCE) {
            if ((temp_v1_7 != DEBUG_GOTO_CREDITS_SEQUENCE_CC_50) && (temp_v1_7 != DEBUG_GOTO_CREDITS_SEQUENCE_CC_EXTRA)) {
                D_800DC524 = RACING;
                if (gModeSelection == TIME_TRIALS) {
                    D_8018EDFB = 1;
                }
            } else {
                D_800DC524 = CREDITS_SEQUENCE;
                gCreditsCourseId = COURSE_LUIGI_RACEWAY;
            }
        } else {
            D_800DC524 = ENDING_SEQUENCE;
        }
        func_8000F124(1, 2);
        if ((gScreenModeSelection == SCREEN_MODE_3P_4P_SPLITSCREEN) && ((temp_v1_8 = gModeSelection, (temp_v1_8 == 0)) || (temp_v1_8 == 1))) {
            gModeSelection = VERSUS;
        }
        temp_a0_2 = gCurrentCourseId;
        if ((temp_a0_2 != 0xF) && (temp_a0_2 != 0x10) && (temp_a0_2 != 0x11) && (temp_a0_2 != 0x13)) {
            // Selected course is not one of the battle courses
            temp_v0_8 = gModeSelection;
            phi_v0 = temp_v0_8;
            if (temp_v0_8 == 3) {
                gModeSelection = GRAND_PRIX;
                phi_v0 = 0;
            }
            if ((phi_v0 == 2) && (gPlayerCountSelection1 == 1)) {
                gModeSelection = GRAND_PRIX;
            }
        } else {
            gModeSelection = BATTLE;
            if (gPlayerCountSelection1 == 1) {
                D_8018EDF3 = TWO_PLAYERS_SELECTED;
                gScreenModeSelection = SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL;
                gPlayerCountSelection1 = D_8018EDF3;
            }
        }
        gCupSelection = gCupSelectionByCourseId[gCurrentCourseId];
        temp_v1_9 = gDebugGotoScene;
        D_800DC540 = gCupSelection;
        gCupCourseSelection = gPerCupIndexByCourseId[gCurrentCourseId];
        if (temp_v1_9 != DEBUG_GOTO_ENDING_SEQUENCE) {
            if (temp_v1_9 != DEBUG_GOTO_CREDITS_SEQUENCE_CC_50) {
                if (temp_v1_9 != DEBUG_GOTO_CREDITS_SEQUENCE_CC_EXTRA) {
                    if (gCCSelection == CC_EXTRA) {
                        gIsMirrorMode = 1;
                        return;
                    }
                    gIsMirrorMode = 0;
                    /* Duplicate return node #115. Try simplifying control flow for better match */
                    return;
                }
                gCCSelection = CC_EXTRA;
                return;
            }
            gCCSelection = CC_50;
            return;
        }
    default:                                        /* switch 2 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CE64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, u32); // extern
? func_8009CE64(s32); // extern
extern ? D_800E7AE8;
extern ? D_8015F480;
extern ? D_8018E7B8;
extern ? D_8018E7D0;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s32 gDisplayListHead;

void func_8009D77C(s32 arg0, s32 arg1, s32 arg2) {
    s32 sp44;
    u32 *sp3C;
    u32 *sp38;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v1_3;
    u32 *temp_t1;
    u32 *temp_t5;
    u32 temp_lo;
    u32 temp_t6;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_v0_3;
    void *temp_v0_6;
    void *temp_v1;
    void *temp_v1_2;
    s16 phi_t3;
    s32 phi_ra;
    s16 phi_t4;
    u32 phi_t2;

    temp_v0 = gModeSelection;
    if ((temp_v0 == GRAND_PRIX) || (temp_v0 == TIME_TRIALS)) {
        temp_v0_4 = arg0 * 8;
        temp_a0_2 = temp_v0_4 + &D_8018E810;
        temp_v1_2 = temp_v0_4 + &D_8018E7E8;
        sp44 = temp_a0_2->unk2;
        phi_t3 = temp_v1_2->unk0;
        phi_ra = temp_a0_2->unk0;
        phi_t4 = temp_v1_2->unk2;
    } else if (arg0 >= 4) {
        temp_v0_2 = arg0 * 8;
        temp_a0 = temp_v0_2 + &D_8018E810;
        temp_v1 = temp_v0_2 + &D_8018E7E8;
        sp44 = temp_a0->unk2;
        phi_t3 = temp_v1->unk0;
        phi_ra = temp_a0->unk0;
        phi_t4 = temp_v1->unk2;
    } else {
        temp_v0_3 = (arg0 << 6) + &D_8015F480;
        sp44 = temp_v0_3->unk2E;
        phi_t3 = temp_v0_3->unk30;
        phi_ra = temp_v0_3->unk2C;
        phi_t4 = temp_v0_3->unk32;
    }
    temp_v0_5 = arg0 * 4;
    temp_t1 = temp_v0_5 + &D_8018E7D0;
    temp_t5 = temp_v0_5 + &D_8018E7B8;
    temp_lo = (*temp_t1 * 0xFF) / *temp_t5;
    phi_t2 = temp_lo;
    if (temp_lo >= 0x100) {
        phi_t2 = 0xFF;
    }
    temp_v1_3 = phi_ra / 2;
    temp_t8 = sp44 / 2;
    temp_v0_6 = (arg2 * 8) + &D_800E7AE8;
    sp3C = temp_t1;
    sp38 = temp_t5;
    gDisplayListHead = draw_box(gDisplayListHead, phi_t3 - temp_v1_3, phi_t4 - temp_t8, temp_v1_3 + phi_t3, temp_t8 + phi_t4, temp_v0_6->unk0, temp_v0_6->unk2, temp_v0_6->unk4, phi_t2);
    if (arg1 == 0) {
        temp_t6 = *temp_t1 + 1;
        *temp_t1 = temp_t6;
        if ((*temp_t5 + 1) < temp_t6) {
            func_8009CE64(arg0);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D77C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009D77C(?); // extern

void func_8009D958(void) {
    func_8009D77C(0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D958.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009D77C(?); // extern

void func_8009D978(void) {
    func_8009D77C(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D978.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern ? D_8015F480;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s32 gDisplayListHead;

void func_8009D998(s32 arg0) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v1_3;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_v0_3;
    void *temp_v1;
    void *temp_v1_2;
    s16 phi_t0;
    s32 phi_t2;
    s16 phi_t1;
    s32 phi_t3;

    temp_v0 = gModeSelection;
    if ((temp_v0 == GRAND_PRIX) || (temp_v0 == TIME_TRIALS)) {
        temp_v0_4 = arg0 * 8;
        temp_v1_2 = temp_v0_4 + &D_8018E7E8;
        temp_a0_2 = temp_v0_4 + &D_8018E810;
        phi_t0 = temp_v1_2->unk0;
        phi_t2 = temp_a0_2->unk0;
        phi_t1 = temp_v1_2->unk2;
        phi_t3 = temp_a0_2->unk2;
    } else {
        temp_v0_2 = arg0 * 8;
        if (arg0 >= 4) {
            temp_v1 = temp_v0_2 + &D_8018E7E8;
            temp_a0 = temp_v0_2 + &D_8018E810;
            phi_t0 = temp_v1->unk0;
            phi_t2 = temp_a0->unk0;
            phi_t1 = temp_v1->unk2;
            phi_t3 = temp_a0->unk2;
        } else {
            temp_v0_3 = (arg0 << 6) + &D_8015F480;
            phi_t0 = temp_v0_3->unk30;
            phi_t2 = temp_v0_3->unk2C;
            phi_t1 = temp_v0_3->unk32;
            phi_t3 = temp_v0_3->unk2E;
        }
    }
    temp_v0_5 = phi_t2 / 2;
    temp_v1_3 = phi_t3 / 2;
    gDisplayListHead = draw_box(gDisplayListHead, phi_t0 - temp_v0_5, phi_t1 - temp_v1_3, temp_v0_5 + phi_t0, temp_v1_3 + phi_t1, 0, 0, 0, 0xFF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D998.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, u32); // extern
? func_8009CE64(?, ? *); // extern
extern u32 D_8018E7C8;
extern ? D_8018E7D0;
extern void *gDisplayListHead;

void func_8009DAA8(void) {
    u32 temp_lo;
    u32 temp_t8;
    void *temp_v1;
    u32 phi_t0;

    temp_t8 = D_8018E7D0.unk10 + 1;
    D_8018E7D0.unk10 = temp_t8;
    if (temp_t8 >= (D_8018E7C8 + 1)) {
        func_8009CE64(4, &D_8018E7D0);
    }
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk4 = 0;
    temp_v1->unk0 = 0xE7000000;
    temp_lo = (D_8018E7D0.unk10 * 0xFF) / D_8018E7C8;
    phi_t0 = temp_lo;
    if (temp_lo >= 0x100) {
        phi_t0 = 0xFF;
    }
    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x140, 0xF0, 0, 0, 0, phi_t0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DAA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, u32); // extern
? func_8009CE64(?); // extern
extern s32 D_8018D9B8;
extern u32 D_8018E7C8;
extern ? D_8018E7D0;
extern void *gDisplayListHead;

void func_8009DB8C(void) {
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s0_3;
    s32 temp_t4;
    s32 temp_t5;
    u32 temp_lo;
    u32 temp_t7;
    u32 temp_v0;
    u32 temp_v0_2;
    void *temp_a0;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_a1_3;
    void *temp_v0_3;
    void *temp_v1;
    s32 phi_s0;
    s32 phi_s0_2;
    u32 phi_v0;
    u32 phi_s3;
    s32 phi_s0_3;
    u32 phi_v1;
    u32 phi_s3_2;

    temp_t7 = D_8018E7D0.unk10 + 1;
    D_8018E7D0.unk10 = temp_t7;
    temp_v0 = D_8018E7C8;
    phi_v0 = temp_v0;
    if (temp_t7 >= temp_v0) {
        phi_s0 = 0;
        if (temp_t7 == temp_v0) {
            do {
                *(D_8018D9B8 + phi_s0) = 1;
                (D_8018D9B8 + phi_s0)->unk1 = 1;
                (D_8018D9B8 + phi_s0)->unk2 = 1;
                temp_s0 = phi_s0 + 4;
                (D_8018D9B8 + phi_s0)->unk3 = 1;
                phi_s0 = temp_s0;
            } while (temp_s0 != 0x4B0);
        } else {
            func_8009CE64(4);
        }
        goto block_14;
    }
    phi_s0_2 = 0;
    phi_s0_2 = 0;
    phi_s3_2 = 0;
    if ((0x4B0 / temp_v0) != 0) {
        do {
            phi_s3 = phi_s3_2;
            if ((*(D_8018D9B8 + phi_s0_2) == 0) && (random_int(((0x4B0 - D_8018E7D0.unk10) / phi_v0) & 0xFFFF) == 0)) {
                *(D_8018D9B8 + phi_s0_2) = 1;
                phi_s3 = phi_s3_2 + 1;
            }
            temp_v0_2 = D_8018E7C8;
            temp_s0_2 = phi_s0_2 + 1;
            phi_v0 = temp_v0_2;
            phi_s0_2 = temp_s0_2;
            phi_s3_2 = phi_s3;
            if (temp_s0_2 >= 0x4B0) {

            }
        } while (phi_s3 < (0x4B0 / temp_v0_2));
block_14:
    }
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = 0;
    temp_v0_3->unk0 = 0xE7000000;
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk0 = 0xB900031D;
    temp_v1->unk4 = 0x504240;
    temp_a0 = gDisplayListHead;
    gDisplayListHead = temp_a0 + 8;
    temp_a0->unk4 = 0xFF;
    temp_a0->unk0 = 0xFA000000;
    temp_a1 = gDisplayListHead;
    gDisplayListHead = temp_a1 + 8;
    temp_a1->unk4 = 0xFFFDF6FB;
    temp_a1->unk0 = 0xFCFFFFFF;
    phi_s0_3 = 0;
    do {
        if (*(D_8018D9B8 + phi_s0_3) != 0) {
            temp_a1_2 = gDisplayListHead;
            temp_t4 = (phi_s0_3 % 0x28) * 8;
            gDisplayListHead = temp_a1_2 + 8;
            temp_t5 = (phi_s0_3 / 0x28) * 8;
            temp_a1_2->unk4 = ((temp_t4 & 0x3FF) << 0xE) | ((temp_t5 & 0x3FF) * 4);
            temp_a1_2->unk0 = (((temp_t4 + 8) & 0x3FF) << 0xE) | 0xF6000000 | (((temp_t5 + 8) & 0x3FF) * 4);
        }
        temp_s0_3 = phi_s0_3 + 1;
        phi_s0_3 = temp_s0_3;
    } while (temp_s0_3 != 0x4B0);
    temp_a1_3 = gDisplayListHead;
    gDisplayListHead = temp_a1_3 + 8;
    temp_a1_3->unk4 = 0;
    temp_a1_3->unk0 = 0xE7000000;
    temp_lo = (D_8018E7D0.unk10 * 0xFF) / D_8018E7C8;
    phi_v1 = temp_lo;
    if (temp_lo >= 0x100) {
        phi_v1 = 0xFF;
    }
    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x140, 0xF0, 0, 0, 0, phi_v1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DB8C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern s32 D_8018E7E0;

void func_8009DEF8(u32 arg0, s8 arg1) {
    s8 temp_v0;
    u32 phi_a0;

    phi_a0 = arg0;
    if (arg0 == 0) {
        phi_a0 = 1;
    }
    temp_v0 = D_8018E7AC.unk4;
    if ((temp_v0 != 1) && (temp_v0 != 6)) {
        D_8018E7AC.unk4 = arg1;
        D_8018E7B8.unk10 = phi_a0;
        if (phi_a0 >= 0x100) {
            D_8018E7B8.unk10 = 0xFF;
        }
        D_8018E7E0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DEF8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DEF8(?); // extern

void func_8009DF4C(void) {
    func_8009DEF8(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DF4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DEF8(?); // extern

void func_8009DF6C(void) {
    func_8009DEF8(8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DF6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern s32 D_8018E7E0;

void func_8009DF8C(u32 arg0, s8 arg1) {
    s8 temp_v0;
    u32 phi_a0;

    phi_a0 = arg0;
    if (arg0 == 0) {
        phi_a0 = 1;
    }
    temp_v0 = D_8018E7AC.unk4;
    if ((temp_v0 != 2) && (temp_v0 != 5)) {
        D_8018E7AC.unk4 = arg1;
        D_8018E7B8.unk10 = phi_a0;
        if (phi_a0 >= 0x100) {
            D_8018E7B8.unk10 = 0xFF;
        }
        D_8018E7E0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DF8C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DF8C(?); // extern

void func_8009DFE0(void) {
    func_8009DF8C(2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DFE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DF8C(?); // extern

void func_8009E000(void) {
    func_8009DF8C(7);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E000.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern ? D_8018E7D0;

void func_8009E020(s32 arg0, u32 arg1) {
    s32 temp_v0_2;
    s8 *temp_v1;
    s8 temp_v0;
    u32 *temp_a2;
    u32 phi_a1;

    phi_a1 = arg1;
    if (arg1 == 0) {
        phi_a1 = 1;
    }
    temp_v1 = arg0 + &D_8018E7AC;
    temp_v0 = *temp_v1;
    if ((temp_v0 != 1) && (temp_v0 != 6)) {
        temp_v0_2 = arg0 * 4;
        temp_a2 = temp_v0_2 + &D_8018E7B8;
        *temp_v1 = 1;
        *temp_a2 = phi_a1;
        if (phi_a1 >= 0x100) {
            *temp_a2 = 0xFF;
        }
        *(&D_8018E7D0 + temp_v0_2) = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E020.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern ? D_8018E7D0;

void func_8009E088(s32 arg0, u32 arg1) {
    s32 temp_v0_2;
    s8 *temp_v1;
    s8 temp_v0;
    u32 *temp_a2;
    u32 phi_a1;

    phi_a1 = arg1;
    if (arg1 == 0) {
        phi_a1 = 1;
    }
    temp_v1 = arg0 + &D_8018E7AC;
    temp_v0 = *temp_v1;
    if ((temp_v0 != 2) && (temp_v0 != 5)) {
        temp_v0_2 = arg0 * 4;
        temp_a2 = temp_v0_2 + &D_8018E7B8;
        *temp_v1 = 2;
        *temp_a2 = phi_a1;
        if (phi_a1 >= 0x100) {
            *temp_a2 = 0xFF;
        }
        *(&D_8018E7D0 + temp_v0_2) = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E088.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9B8;
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern s32 D_8018E7E0;

void func_8009E0F0(u32 arg0) {
    s32 temp_v0;
    s32 phi_v0;

    if (D_8018E7AC.unk4 != 3) {
        D_8018E7AC.unk4 = 3;
        D_8018E7B8.unk10 = arg0;
        if (arg0 >= 0x100) {
            D_8018E7B8.unk10 = 0xFF;
        }
        D_8018E7E0 = 0;
        phi_v0 = 0;
        do {
            *(D_8018D9B8 + phi_v0) = 0;
            (D_8018D9B8 + phi_v0)->unk1 = 0;
            (D_8018D9B8 + phi_v0)->unk2 = 0;
            temp_v0 = phi_v0 + 4;
            (D_8018D9B8 + phi_v0)->unk3 = 0;
            phi_v0 = temp_v0;
        } while (temp_v0 != 0x4B0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E0F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E1C0(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E1C0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E000(?); // extern
extern s32 D_8018EDE0;

void func_8009E1E4(void) {
    func_8009E000(0xA);
    D_8018EDE0 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E1E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E208(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E208.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E230(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E230.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E258(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E258.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E280(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 4;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E280.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E2F0(); // extern
extern ? D_8018E838;

void func_8009E2A8(s32 arg0) {
    s8 *temp_v1;
    s8 temp_v0;

    temp_v1 = arg0 + &D_8018E838;
    temp_v0 = *temp_v1;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            *temp_v1 = 0;
            return;
        }
        func_8009E2F0();
        // Duplicate return node #4. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E2A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, u32, s32, s32, s32, s32); // extern
extern ? D_800E7AC8;
extern ? D_800F0B28;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s8 D_8018E838;
extern ? D_8018E840;
extern s32 gDisplayListHead;

void func_8009E2F0(s32 arg0) {
    s32 sp38;
    f32 temp_f4;
    f64 temp_f6;
    s16 temp_t2;
    s16 temp_t2_2;
    s16 temp_t4;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t7_2;
    s32 temp_t7_3;
    s32 temp_t8;
    s32 temp_v1;
    s8 temp_t7;
    u16 temp_t6_3;
    u32 *temp_s0;
    u32 temp_ra;
    u32 temp_t7_4;
    void *temp_t0;
    void *temp_t0_2;
    void *temp_t1;
    void *temp_t1_2;
    void *temp_v0;
    f32 phi_f4;
    f64 phi_f6;

    temp_s0 = (arg0 * 4) + &D_8018E840;
    temp_ra = *temp_s0;
    temp_t7 = *(&D_800F0B28 + temp_ra);
    sp38 = temp_t7;
    if (temp_t7 != 0) {
        if (temp_ra < 0x1B) {
            temp_v1 = arg0 * 8;
            temp_t1 = temp_v1 + &D_8018E810;
            temp_t0 = temp_v1 + &D_8018E7E8;
            temp_t4 = temp_t0->unk2;
            temp_t2 = temp_t0->unk0;
            temp_t6 = temp_t1->unk0 / 2;
            temp_t8 = temp_t1->unk2 / 2;
            temp_v0 = (temp_t7 * 8) + &D_800E7AC8;
            gDisplayListHead = draw_box(gDisplayListHead, temp_t2 - temp_t6, temp_t4 - temp_t8, temp_t2 + temp_t6, temp_t4 + temp_t8, temp_v0->unk0, temp_v0->unk2, temp_v0->unk4, temp_v0->unk6);
        } else {
            temp_t7_2 = 0x26 - temp_ra;
            temp_f6 = temp_t7_2;
            phi_f6 = temp_f6;
            if (temp_t7_2 < 0) {
                phi_f6 = temp_f6 + 4294967296.0;
            }
            temp_t6_2 = arg0 * 8;
            temp_t1_2 = temp_t6_2 + &D_8018E810;
            temp_t0_2 = temp_t6_2 + &D_8018E7E8;
            temp_t2_2 = temp_t0_2->unk0;
            temp_t7_3 = temp_t1_2->unk0 / 2;
            temp_t6_3 = ((sp38 * 8) + &D_800E7AC8)->unk6;
            temp_f4 = temp_t6_3;
            phi_f4 = temp_f4;
            if (temp_t6_3 < 0) {
                phi_f4 = temp_f4 + 4294967296.0f;
            }
            gDisplayListHead = draw_box(gDisplayListHead, temp_t2_2 - temp_t7_3, temp_t0_2->unk2 - (temp_t1_2->unk2 / 2), temp_t2_2 + temp_t7_3, phi_f4 * (phi_f6 / 11.0));
        }
    }
    temp_t7_4 = *temp_s0 + 1;
    *temp_s0 = temp_t7_4;
    if (temp_t7_4 >= 0x26) {
        D_8018E838 = 0;
        D_8018E838 = 0;
        D_8018E838 = 0;
        D_8018E838 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E2F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E5FC(s32); // extern

void func_8009E5BC(void) {
    s32 temp_s0;
    s32 phi_s0;

    phi_s0 = 0;
    do {
        func_8009E5FC(phi_s0);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E5BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E838;
extern ? D_8018E840;

void func_8009E5FC(s32 arg0) {
    *(&D_8018E838 + arg0) = 1;
    *(&D_8018E840 + (arg0 * 4)) = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E5FC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018D9E0;
extern ? D_8018DEE0;

void func_8009E620(void) {
    ? *temp_v1;
    ? *phi_v1;

    phi_v1 = &D_8018D9E0;
    do {
        temp_v1 = phi_v1 + 0xA0;
        temp_v1->unk-78 = 0;
        temp_v1->unk-50 = 0;
        temp_v1->unk-28 = 0;
        temp_v1->unk-A0 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 != &D_8018DEE0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E620.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 5bd751fca3befef73d6a2e20d84a88cc918a77fe
struct _struct_D_800E8234_0x8 {
    /* 0x0 */ u32 unk0;                             /* inferred */
    /* 0x4 */ struct _struct_D_800E8234_0x8 unk4;   /* inferred */
};                                                  /* size = 0x8 */

s32 func_800051C4();                                /* extern */
? func_8006EE44(s8);                                /* extern */
? func_8006EF60();                                  /* extern */
? func_80099184(? *, s8);                           /* extern */
? func_800996BC(? *, ?, s8);                        /* extern */
s32 func_8009A374(void *);                          /* extern */
s32 func_8009A478(void *, s32);                     /* extern */
? func_8009B0A4(?, ?);                              /* extern */
? func_8009B538(?, ?, u16, u16, s32);               /* extern */
s32 func_8009B8C4(? *);                             /* extern */
? func_8009B954(? *);                               /* extern */
? func_8009B998();                                  /* extern */
s32 *func_8009BA74(s32 *, ? *, s32, s32);           /* extern */
s32 func_800B5020(s32, s8, s8);                     /* extern */
s32 func_800B5218();                                /* extern */
s32 func_800B54C0(s8, s32, s8);                     /* extern */
s32 func_800B555C(s8);                              /* extern */
? func_800B559C(s32);                               /* extern */
s32 func_800B5B94();                                /* extern */
? func_800B6708();                                  /* extern */
s32 random_int(?, s8);                              /* extern */
extern ? D_020014C8;
extern ? D_02001540;
extern ? D_0200157C;
extern ? D_020015A4;
extern ? D_020015CC;
extern ? D_02001630;
extern ? D_02001658;
extern ? D_0200184C;
extern ? D_02001874;
extern ? D_0200198C;
extern ? D_0200199C;
extern ? D_020019AC;
extern ? D_020019BC;
extern ? D_020019CC;
extern ? D_020019DC;
extern ? D_02001B2C;
extern ? D_02001B54;
extern ? D_02001B7C;
extern ? D_02001BA4;
extern ? D_02001BCC;
extern ? D_02001BF4;
extern ? D_02001C1C;
extern ? D_02001C44;
extern ? D_02001C6C;
extern ? D_02001C94;
extern ? D_02001CBC;
extern ? D_02001CE4;
extern ? D_02001D0C;
extern ? D_02001D34;
extern ? D_02001D5C;
extern ? D_02001D84;
extern ? D_02001DAC;
extern ? D_02001DD4;
extern ? D_02001DFC;
extern ? D_02001E24;
extern ? D_02001E64;
extern ? D_02001E74;
extern ? D_02001E84;
extern ? D_02001E94;
extern ? D_02001EA4;
extern ? D_02001EB4;
extern ? D_02001EC4;
extern ? D_02001ED4;
extern ? D_02001EE4;
extern ? D_02001EF4;
extern ? D_02001F04;
extern ? D_02001F14;
extern ? D_02001F24;
extern ? D_02001F34;
extern ? D_02001F44;
extern ? D_02001F54;
extern ? D_02001F64;
extern ? D_02001F74;
extern ? D_02001F84;
extern ? D_02001F94;
extern ? D_02001FA4;
extern ? D_020020BC;
extern ? D_020020CC;
extern ? D_020020DC;
extern ? D_02003594;
extern ? D_020035BC;
extern ? D_020035E4;
extern ? D_0200360C;
extern ? D_02003634;
extern ? D_0200365C;
extern ? D_02003684;
extern ? D_020036AC;
extern ? D_020036D4;
extern ? D_020036FC;
extern ? D_02003724;
extern ? D_0200374C;
extern ? D_02003774;
extern ? D_0200379C;
extern ? D_020037C4;
extern ? D_020037EC;
extern ? D_02003814;
extern ? D_0200383C;
extern ? D_02003864;
extern ? D_0200388C;
extern ? D_020038B4;
extern ? D_020038DC;
extern ? D_02003904;
extern ? D_0200392C;
extern ? D_02003954;
extern ? D_0200397C;
extern ? D_020039A4;
extern ? D_020039CC;
extern ? D_02003A1C;
extern ? D_02003A44;
extern ? D_02003A6C;
extern ? D_02003A94;
extern ? D_02003ABC;
extern ? D_02003AE4;
extern ? D_02003B0C;
extern ? D_02003B34;
extern ? D_02003B5C;
extern ? D_02003B84;
extern ? D_02003BAC;
extern ? D_02003BFC;
extern ? D_02003C24;
extern ? D_02003C4C;
extern ? D_02003C74;
extern ? D_02003C9C;
extern ? D_02003CC4;
extern ? D_02003CEC;
extern ? D_02003D14;
extern ? D_02003D3C;
extern ? D_02003D64;
extern ? D_02003D8C;
extern ? D_02003DB4;
extern ? D_02003DDC;
extern ? D_02003E04;
extern ? D_02003E2C;
extern ? D_02003E54;
extern ? D_02003E7C;
extern ? D_02003EA4;
extern ? D_02003ECC;
extern ? D_02003EF4;
extern ? D_02003F1C;
extern ? D_02003F44;
extern ? D_02003F6C;
extern ? D_02003F94;
extern ? D_02003FE4;
extern ? D_0200400C;
extern ? D_02004034;
extern ? D_0200405C;
extern ? D_02004084;
extern ? D_020040AC;
extern ? D_020040D4;
extern ? D_020040FC;
extern ? D_02004124;
extern ? D_0200414C;
extern ? D_02004174;
extern ? D_0200419C;
extern ? D_020041C4;
extern ? D_020041EC;
extern ? D_02004214;
extern ? D_0200423C;
extern ? D_02004264;
extern ? D_0200428C;
extern ? D_020042B4;
extern ? D_020042DC;
extern ? D_02004304;
extern ? D_0200432C;
extern ? D_02004354;
extern ? D_0200437C;
extern ? D_020043A4;
extern ? D_020043CC;
extern ? D_020043F4;
extern ? D_0200441C;
extern ? D_02004444;
extern ? D_0200446C;
extern ? D_02004494;
extern ? D_020044BC;
extern ? D_020044E4;
extern ? D_0200450C;
extern ? D_02004534;
extern ? D_0200455C;
extern ? D_02004598;
extern ? D_020045C0;
extern ? D_020045E8;
extern ? D_02004610;
extern ? D_02004638;
extern ? D_020048F4;
extern ? D_0200491C;
extern ? D_02004944;
extern ? D_0200496C;
extern ? D_02004994;
extern ? D_020049BC;
extern ? D_020049E4;
extern ? D_02004A0C;
extern ? D_02004A34;
extern ? D_02004B4C;
extern ? D_02004B74;
extern ? D_02004EA8;
extern ? D_02004ED0;
extern ? D_02004EF8;
extern ? D_02004F20;
extern ? D_02004F48;
extern ? D_02004F70;
extern ? D_02004F98;
extern ? D_02004FC0;
extern ? D_02004FE8;
extern ? D_02005010;
extern ? D_02005038;
extern ? D_02005060;
extern ? D_02005088;
extern ? D_020050B0;
extern ? D_020050D8;
extern ? D_02005100;
extern ? D_02005128;
extern ? D_02005150;
extern ? D_02005178;
extern ? D_020051A0;
extern ? D_02006708;
extern ? D_020068E0;
extern ? D_020068F0;
extern ? D_02006AC8;
extern ? D_02006AD8;
extern ? D_02006CB0;
extern ? D_02006CC0;
extern ? D_02006E98;
extern ? D_02006EA8;
extern ? D_02007080;
extern ? D_02007090;
extern ? D_02007270;
extern ? D_02007280;
extern ? D_02007458;
extern ? D_02007468;
extern ? D_02007640;
extern s32 gPlayerWinningIndex;
extern u16 D_80162DD4;
extern ? D_801640F4;
extern s32 D_8018CA78;
extern s32 gD_8018E118TotalSize;
extern s32 *D_8018E75C;
extern s8 D_8018ED90;
extern s32 D_8018ED94;
extern s32 D_8018EDC0;
extern f32 D_8018EDC4;
extern f32 D_8018EDC8;
extern f32 D_8018EDCC;
extern f32 D_8018EDD0;
extern f32 D_8018EDD4;
extern f32 D_8018EDD8;
extern f32 D_8018EDDC;
extern ? D_8018EE10;
extern ? D_802874D8;
extern s8 gCupCourseSelection;
extern u8 gSoundMode;
extern ? gTexture7ED50C;
extern s8 gTimeTrialDataCourseIndex;
static struct _struct_D_800E7248_0x8 D_800E7248[0]; /* unable to generate initializer; const */
static ? D_800E7268;                                /* unable to generate initializer; const */
static struct _struct_D_800E74E8_0x8 D_800E74E8[0]; /* unable to generate initializer; const */
static struct _struct_D_800E8234_0x8 D_800E7AF8[0x36]; /* unable to generate initializer; const */
static ? D_800E7CA8;                                /* unable to generate initializer; const */
static struct _struct_D_800E8234_0x8 D_800E7D0C[5]; /* unable to generate initializer; const */
static u32 D_800E7D34[6] = {
    (u32) &D_0200198C,
    (u32) &D_0200199C,
    (u32) &D_020019AC,
    (u32) &D_020019BC,
    (u32) &D_020019CC,
    (u32) &D_020019DC,
}; /* const */
static ? *D_800E7D4C[2] = { &D_02004598, &D_020045C0 }; /* const */
static ? D_800E7D54;                                /* unable to generate initializer; const */
static u32 D_800E7D74[0x14] = {
    (u32) &D_02001B2C,
    (u32) &D_02001B54,
    (u32) &D_02001B7C,
    (u32) &D_02001BA4,
    (u32) &D_02001BCC,
    (u32) &D_02001BF4,
    (u32) &D_02001C1C,
    (u32) &D_02001C44,
    (u32) &D_02001C6C,
    (u32) &D_02001C94,
    (u32) &D_02001CBC,
    (u32) &D_02001CE4,
    (u32) &D_02001D0C,
    (u32) &D_02001D34,
    (u32) &D_02001D5C,
    (u32) &D_02001D84,
    (u32) &D_02001DAC,
    (u32) &D_02001DD4,
    (u32) &D_02001DFC,
    (u32) &D_02001E24,
}; /* const */
static u32 D_800E7DC4[0x17] = {
    (u32) &D_02004EA8,
    (u32) &D_02004ED0,
    (u32) &D_02004EF8,
    (u32) &D_02004F20,
    (u32) &D_02004F48,
    (u32) &D_02004F70,
    (u32) &D_02004F98,
    (u32) &D_02004FC0,
    (u32) &D_02004FE8,
    (u32) &D_02005010,
    (u32) &D_02005038,
    (u32) &D_02005060,
    (u32) &D_02005088,
    (u32) &D_020050B0,
    (u32) &D_020050D8,
    (u32) &D_02005100,
    (u32) &D_02005128,
    (u32) &D_02005150,
    (u32) &D_02005178,
    (u32) &D_020051A0,
    (u32) &D_020020BC,
    (u32) &D_020020CC,
    (u32) &D_020020DC,
}; /* const */
static ? D_800E7E20;                                /* unable to generate initializer; const */
static u32 D_800E7E34[0x14] = {
    (u32) &D_02001E64,
    (u32) &D_02001E74,
    (u32) &D_02001E84,
    (u32) &D_02001E94,
    (u32) &D_02001EA4,
    (u32) &D_02001EB4,
    (u32) &D_02001EC4,
    (u32) &D_02001ED4,
    (u32) &D_02001EE4,
    (u32) &D_02001EF4,
    (u32) &D_02001F04,
    (u32) &D_02001F14,
    (u32) &D_02001F24,
    (u32) &D_02001F34,
    (u32) &D_02001F44,
    (u32) &D_02001F54,
    (u32) &D_02001F64,
    (u32) &D_02001F74,
    (u32) &D_02001F84,
    (u32) &D_02001F94,
}; /* const */
static ? D_800E7FF0;                                /* unable to generate initializer; const */
static u32 D_800E80A0[0x1D] = {
    (u32) &D_02003594,
    (u32) &D_02003BFC,
    (u32) &D_020035BC,
    (u32) &D_02003C24,
    (u32) &D_020035E4,
    (u32) &D_02003C4C,
    (u32) &D_0200360C,
    (u32) &D_02003C74,
    (u32) &D_02003634,
    (u32) &D_02003C9C,
    (u32) &D_0200365C,
    (u32) &D_02003CC4,
    (u32) &D_02003684,
    (u32) &D_02003CEC,
    (u32) &D_020036AC,
    (u32) &D_02003D14,
    (u32) &D_020036D4,
    (u32) &D_02003D3C,
    (u32) &D_020036FC,
    (u32) &D_02003D64,
    (u32) &D_02003724,
    (u32) &D_02003D8C,
    (u32) &D_02004034,
    (u32) &D_0200374C,
    (u32) &D_02003DB4,
    (u32) &D_02003774,
    (u32) &D_02003DDC,
    (u32) &D_0200379C,
    (u32) &D_02003E04,
}; /* const */
static u32 D_800E8114[0x18] = {
    (u32) &D_020037C4,
    (u32) &D_020037EC,
    (u32) &D_02003814,
    (u32) &D_0200383C,
    (u32) &D_02003864,
    (u32) &D_0200388C,
    (u32) &D_02003E2C,
    (u32) &D_02003EF4,
    (u32) &D_020038B4,
    (u32) &D_02003E54,
    (u32) &D_02003F1C,
    (u32) &D_020038DC,
    (u32) &D_02003E7C,
    (u32) &D_02003F44,
    (u32) &D_02003904,
    (u32) &D_02003EA4,
    (u32) &D_02003F6C,
    (u32) &D_0200392C,
    (u32) &D_02003ECC,
    (u32) &D_02003F94,
    (u32) &D_02003954,
    (u32) &D_0200397C,
    (u32) &D_020039A4,
    (u32) &D_020039CC,
}; /* const */
static u32 D_800E817C[0x1A] = {
    (u32) &D_02003A1C,
    (u32) &D_02003FE4,
    (u32) &D_02003A44,
    (u32) &D_0200400C,
    (u32) &D_02003A6C,
    (u32) &D_02003A94,
    (u32) &D_02003ABC,
    (u32) &D_02003AE4,
    (u32) &D_02003B0C,
    (u32) &D_02003B34,
    (u32) &D_02003B5C,
    (u32) &D_02003B84,
    (u32) &D_02003BAC,
    (u32) &D_0200405C,
    (u32) &D_02004084,
    (u32) &D_020040AC,
    (u32) &D_020040D4,
    (u32) &D_020040FC,
    (u32) &D_020043CC,
    (u32) &D_02004444,
    (u32) &D_0200437C,
    (u32) &D_020043F4,
    (u32) &D_02004124,
    (u32) &D_0200414C,
    (u32) &D_02004174,
    (u32) &D_0200419C,
}; /* const */
static u32 D_800E81E4[0x12] = {
    (u32) &D_020041C4,
    (u32) &D_020041EC,
    (u32) &D_02004214,
    (u32) &D_0200423C,
    (u32) &D_02004264,
    (u32) &D_0200428C,
    (u32) &D_020042B4,
    (u32) &D_020042DC,
    (u32) &D_02004354,
    (u32) &D_020043A4,
    (u32) &D_0200441C,
    (u32) &D_0200446C,
    (u32) &D_02004494,
    (u32) &D_020044BC,
    (u32) &D_02004304,
    (u32) &D_0200432C,
    (u32) &D_020044E4,
    (u32) &D_0200450C,
}; /* const */
static u32 D_800E822C[2] = { (u32) &D_02004534, (u32) &D_0200455C }; /* const */
static struct _struct_D_800E8234_0x8 D_800E8234[3]; /* unable to generate initializer; const */
static u32 D_800E8274[8] = {
    (u32) &D_020048F4,
    (u32) &D_0200491C,
    (u32) &D_02004944,
    (u32) &D_0200496C,
    (u32) &D_020049BC,
    (u32) &D_02004994,
    (u32) &D_020049E4,
    (u32) &D_02004A34,
}; /* const */
static u32 D_800E8294[8] = {
    (u32) &D_020048F4,
    (u32) &D_0200491C,
    (u32) &D_02004944,
    (u32) &D_0200496C,
    (u32) &D_020049BC,
    (u32) &D_02004994,
    (u32) &D_020049E4,
    (u32) &D_02004A34,
}; /* const */
static u32 D_800E8320[8] = {
    (u32) &D_02006708,
    (u32) &D_020068F0,
    (u32) &D_02006CC0,
    (u32) &D_02006EA8,
    (u32) &D_02007090,
    (u32) &D_02007280,
    (u32) &D_02007468,
    (u32) &D_02006AD8,
}; /* const */
static u32 D_800E8420[8] = {
    (u32) &D_020068E0,
    (u32) &D_02006AC8,
    (u32) &D_02006E98,
    (u32) &D_02007080,
    (u32) &D_02007270,
    (u32) &D_02007458,
    (u32) &D_02007640,
    (u32) &D_02006CB0,
}; /* const */
static ? D_800E85F7;                                /* unable to generate initializer; const */
static s8 gCharacterSelections = 0;                           /* const */
static ? D_800EFD64;                                /* unable to generate initializer; const */
s16 gCupCourseOrder[5][4];                          /* unable to generate initializer; const */

void add_8018D9E0_entry(s32 type, s32 column, s32 row, s8 priority) {
    struct_8018D9E0_entry *sp7C;
    s32 *sp6C;
    s32 sp3C;
    struct _struct_D_800E8234_0x8 *sp24;            /* compiler-managed */
    s32 sp20;
    s32 *temp_v0_2;
    s32 *temp_v1_10;
    s32 *temp_v1_2;
    s32 *temp_v1_3;
    s32 *temp_v1_4;
    s32 *temp_v1_5;
    s32 *temp_v1_6;
    s32 *temp_v1_7;
    s32 *temp_v1_8;
    s32 *temp_v1_9;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s32 temp_v0_9;
    s32 temp_v1_12;
    s8 temp_a1;
    s8 temp_a1_2;
    s8 temp_v0_10;
    struct _struct_D_800E7248_0x8 *temp_v0_5;
    struct _struct_D_800E74E8_0x8 *temp_v0_3;
    struct _struct_D_800E8234_0x8 *temp_v0_4;
    struct _struct_D_800E8234_0x8 *temp_v1;
    struct _struct_D_800E8234_0x8 *temp_v1_11;
    struct_8018D9E0_entry *phi_ra;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v1;
    u32 phi_a0;
    struct _struct_D_800E8234_0x8 *phi_v1_2;
    struct _struct_D_800E8234_0x8 *phi_v1_3;
    u8 phi_v1_4;
    s32 phi_v1_5;
    struct _struct_D_800E8234_0x8 *phi_a2;
    u32 phi_a0_2;

    phi_ra = D_8018D9E0;
    phi_v0 = 0;
    phi_v0_2 = 0;
loop_1:
    temp_v0 = phi_v0 + 1;
    phi_v0 = temp_v0;
    if (phi_ra->type != 0) {
        if (temp_v0 >= 0x21) {
loop_3:
            goto loop_3;
        }
        phi_ra += 0x28;
        goto loop_1;
    }
    phi_ra->unk4 = 0;
    phi_ra->unk8 = 0;
    phi_ra->column = column;
    phi_ra->row = row;
    phi_ra->priority = priority;
    phi_ra->visible = 1;
    phi_ra->unk1C = 0;
    phi_ra->unk20 = 0;
    phi_ra->type = type;
    phi_v1_4 = 1U;
    switch (type) {                                 /* irregular */
    case 0xFA:
        D_8018ED94 = 0;
        D_800E8530 = 0.0f;
        D_800E8534 = 3.0f;
        D_8018EDC0 = 0x9C4;
        D_8018EDC8 = 0.0f;
        D_8018EDCC = -270.0f;
        D_8018EDD0 = 0.0f;
        D_8018EDD4 = 0.0f;
        D_8018EDD8 = 0.0f;
        D_8018EDDC = 0.0f;
        D_8018EDC4 = 3.0f;
        phi_ra->unk1C = -1;
        phi_ra->unk20 = (s32) 1U;
        return;
    case 0xFB:
        D_8018EDC0 = 0x708;
        D_8018EDC8 = -51.0f;
        D_8018EDCC = -12.0f;
        D_8018EDD0 = -18.0f;
        D_8018EDD4 = -270.0f;
        D_8018EDD8 = 750.0f;
        D_8018EDDC = 0.0f;
        D_8018EDC4 = 1.0f;
        phi_ra->unk1C = -1;
        phi_ra->unk20 = (s32) 1U;
        return;
    case 0xD2:
        sp7C = phi_ra;
        func_800996BC(&D_020014C8, 0, priority);
        func_8009B954(&D_020014C8);
        D_8018E75C = func_8009BA74(D_8018E75C, &D_020014C8, phi_ra->column, phi_ra->row);
        func_8009B998();
        return;
    case 0xD3:
        sp7C = phi_ra;
        func_800996BC(&D_02001540, 0, priority);
        func_8009B954(&D_02001540);
        D_8018E75C = func_8009BA74(D_8018E75C, &D_02001540, phi_ra->column, phi_ra->row);
        func_8009B998();
        return;
    case 0xD4:
        sp7C = phi_ra;
        func_800996BC(&D_0200157C, 0, priority);
        func_80099184(&D_02001874);
        phi_ra->row = 0x69;
        phi_v1_2 = D_800E7AF8;
        do {
            sp24 = phi_v1_2;
            func_80099184(segmented_to_virtual(phi_v1_2->unk0));
            temp_v1 = &phi_v1_2->unk4;
            phi_v1_2 = temp_v1;
        } while (temp_v1 != D_800E7D0C);
        return;
    case 0xD5:
        sp7C = phi_ra;
        func_80099184(&D_020015A4, priority);
        func_8009B954(&D_020015A4);
        temp_v0_2 = func_8009BA74(D_8018E75C, &D_020015A4, phi_ra->column, phi_ra->row);
        D_8018E75C = temp_v0_2;
        D_8018E75C = temp_v0_2 + 8;
        *temp_v0_2 = 0xFD700000;
        sp6C = temp_v0_2;
        sp6C->unk4 = func_8009B8C4(&gTexture7ED50C);
        temp_v1_2 = D_8018E75C;
        D_8018E75C = temp_v1_2 + 8;
        temp_v1_2->unk0 = 0xF5700000;
        temp_v1_2->unk4 = 0x07080200;
        temp_v1_3 = D_8018E75C;
        D_8018E75C = temp_v1_3 + 8;
        temp_v1_3->unk4 = 0;
        temp_v1_3->unk0 = 0xE6000000;
        temp_v1_4 = D_8018E75C;
        D_8018E75C = temp_v1_4 + 8;
        temp_v1_4->unk4 = 0x074FF020;
        temp_v1_4->unk0 = 0xF3000000;
        temp_v1_5 = D_8018E75C;
        D_8018E75C = temp_v1_5 + 8;
        temp_v1_5->unk4 = 0;
        temp_v1_5->unk0 = 0xE7000000;
        temp_v1_6 = D_8018E75C;
        D_8018E75C = temp_v1_6 + 8;
        temp_v1_6->unk0 = 0xF5708000;
        temp_v1_6->unk4 = 0x80200;
        temp_v1_7 = D_8018E75C;
        D_8018E75C = temp_v1_7 + 8;
        temp_v1_7->unk0 = 0xF2000000;
        temp_v1_7->unk4 = 0x3FC010;
        temp_v1_8 = D_8018E75C;
        D_8018E75C = temp_v1_8 + 8;
        temp_v1_8->unk4 = 0x802C0;
        temp_v1_8->unk0 = 0xE44802D4;
        temp_v1_9 = D_8018E75C;
        D_8018E75C = temp_v1_9 + 8;
        temp_v1_9->unk4 = 0x80;
        temp_v1_9->unk0 = 0xB3000000;
        temp_v1_10 = D_8018E75C;
        D_8018E75C = temp_v1_10 + 8;
        temp_v1_10->unk0 = 0xB2000000;
        temp_v1_10->unk4 = 0x0400FC00;
        sp7C = phi_ra;
        func_8009B998();
        func_80099184(&D_020015CC);
        func_8009B954(&D_020015CC);
        D_8018E75C = func_8009BA74(D_8018E75C, &D_020015CC, phi_ra->column, phi_ra->row);
        func_8009B998();
        func_80099184(&D_02001630);
        func_8009B954(&D_02001630);
        D_8018E75C = func_8009BA74(D_8018E75C, &D_02001630, phi_ra->column, phi_ra->row);
        func_8009B998();
        func_80099184(&D_02001658);
        func_8009B954(&D_02001658);
        D_8018E75C = func_8009BA74(D_8018E75C, &D_02001658, phi_ra->column, phi_ra->row);
        func_8009B998();
        return;
    case 0xD6:
        sp7C = phi_ra;
        phi_ra->D_8018DEE0_index = func_8009A374(segmented_to_virtual_dupe(*D_800E7D34));
        return;
    case 0xD7:
        phi_v1_3 = D_800E7D0C;
        do {
            sp24 = phi_v1_3;
            func_80099184(segmented_to_virtual(phi_v1_3->unk0));
            temp_v1_11 = &phi_v1_3->unk4;
            phi_v1_3 = temp_v1_11;
        } while (temp_v1_11 != D_800E7D34);
        return;
    case 0xD8:
    case 0xD9:
        func_80099184(&D_0200184C, priority);
        return;
    case 0x1:
        func_800996BC(D_800E7D4C[func_800B555C(priority)], 0);
        return;
    case 0x2:
        func_8006EE44(priority);
        gD_8018E118TotalSize += 0x10000;
        func_80099184(&D_020045E8);
        return;
    case 0x3:
        func_80099184(&D_02004610, priority);
        return;
    case 0x23:
    case 0x24:
    case 0x25:
        func_800996BC(D_800E7D4C[func_800B555C(priority)], 0);
        func_800996BC(&D_02004B74, 0);
        func_8009B0A4(0, 0x19);
        temp_v0_3 = &D_800E74E8[type];
        func_8009B538(0, 0x12C00, temp_v0_3->unk-118, temp_v0_3->unk-116, (s32) temp_v0_3->unk-114);
        return;
    case 0xF:
        phi_ra->unk1C = 0x20;
        /* fallthrough */
    case 0xA:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
        func_800996BC(segmented_to_virtual(D_800E822C[type]), 0);
        return;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
        temp_v0_4 = &D_800E8234[type];
        sp24 = temp_v0_4;
        func_800996BC(segmented_to_virtual(temp_v0_4->unk-58), 0);
        func_80099184(segmented_to_virtual(sp24->unk-54));
        return;
    case 0x2A:
        func_800996BC(&D_02004B4C, 0, priority);
        return;
    case 0x33:
        sp7C = phi_ra;
        func_800996BC(&D_02004B74, 0, priority);
        phi_ra->unk1C = 0x20;
        return;
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
        func_80099184(segmented_to_virtual(D_800E81E4[type]));
        return;
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
        sp7C = phi_ra;
        sp24 = type * 4;
        phi_ra->D_8018DEE0_index = func_8009A374(segmented_to_virtual_dupe(D_800E8274[type]));
        func_800996BC(segmented_to_virtual(*(&D_800E7CA8 + sp24)), 0);
        return;
    case 0xA0:
    case 0xA1:
        sp7C = phi_ra;
        phi_ra->D_8018DEE0_index = func_8009A374(segmented_to_virtual_dupe(D_800E80A0[type]));
        return;
    case 0x5D:
        phi_ra->unk1C = 0x20;
        /* fallthrough */
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x58:
    case 0x59:
    case 0x5A:
    case 0x5B:
    case 0x5C:
        func_800996BC(segmented_to_virtual(D_800E817C[type]), 0);
        return;
    case 0x5F:
    case 0x60:
    case 0x61:
    case 0x62:
        sp7C = phi_ra;
        phi_ra->D_8018DEE0_index = func_8009A374(segmented_to_virtual_dupe(D_800E7E34[*(gCupCourseOrder - 0xBE + (phi_ra->type * 2))]));
        return;
    case 0x5E:
        sp7C = phi_ra;
        phi_ra->unk20 = random_int(4, priority) + 2;
        return;
    case 0x65:
    case 0x66:
        temp_v0_5 = &D_800E7248[type];
        phi_ra->column = (s32) temp_v0_5->unk-328;
        phi_ra->row = (s32) temp_v0_5->unk-326;
        return;
    case 0x67:
        phi_ra->unk1C = (s32) gCupSelection;
        sp7C = phi_ra;
        temp_v0_6 = func_800B54C0(gCupSelection, gCCSelection, priority);
        temp_v1_12 = temp_v0_6;
        phi_ra->unk20 = temp_v0_6;
        phi_ra->D_8018DEE0_index = func_8009A374(segmented_to_virtual_dupe(*(&D_800E7E20 + ((((s32) gCCSelection / 2) * 0x10) + -(s32) (temp_v1_12 * 4)))));
        phi_ra->column = (s32) D_800E7268.unk0;
        phi_ra->row = (s32) D_800E7268.unk2;
        return;
    case 0x68:
        sp7C = phi_ra;
        func_800996BC(segmented_to_virtual(D_800E8294[gCCSelection]), 0);
        phi_ra->column = 0x37;
        phi_ra->row = 0xC3;
        return;
    case 0x69:
        func_800996BC(segmented_to_virtual((u32) &D_02004A0C), 0);
        if (func_800B5B94() == 0) {
            func_800B6708();
            return;
        }
        D_8018EE10.unk4 = 0;
        D_8018EE10.unk84 = 0;
        return;
    case 0x78:
    case 0x79:
    case 0x7A:
    case 0x7B:
        func_800996BC(segmented_to_virtual(D_800E8114[type]), 0);
        return;
    case 0x8C:
        func_800996BC(segmented_to_virtual((u32) &D_02004A34), 0);
        if (func_800B5B94() == 0) {
            func_800B6708();
            return;
        }
        D_8018EE10.unk4 = 0;
        D_8018EE10.unk84 = 0;
        return;
    case 0x8D:
        func_80099184(segmented_to_virtual((u32) &D_02001FA4));
        return;
    case 0x7C:
    case 0x7D:
    case 0x7E:
    case 0x7F:
    case 0x80:
    case 0x81:
    case 0x82:
    case 0x83:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
    case 0x88:
    case 0x89:
    case 0x8A:
    case 0x8B:
        sp7C = phi_ra;
        temp_v0_7 = phi_ra->type - 0x7C;
        func_800996BC(segmented_to_virtual(D_800E7D74[*(gCupCourseOrder + (((temp_v0_7 / 4) * 8) + ((temp_v0_7 % 4) * 2)))]), -1);
        temp_v0_8 = phi_ra->type - 0x7C;
        func_800996BC(segmented_to_virtual(D_800E7DC4[*(gCupCourseOrder + (((temp_v0_8 / 4) * 8) + ((temp_v0_8 % 4) * 2)))]), 0);
        func_800996BC(segmented_to_virtual((u32) &D_02004A0C), 0);
        return;
    case 0xB1:
    case 0xB2:
    case 0xB3:
    case 0xB4:
        temp_v0_9 = gModeSelection;
        temp_a1 = *(&D_800EFD64 + *(&D_800E85F7 + type));
        phi_v1_4 = 0U;
        if (temp_v0_9 != 2) {
            if (temp_v0_9 != 3) {
                phi_a2 = (struct _struct_D_800E8234_0x8 *) (type * 4);
            } else {
                temp_t8 = type * 4;
                phi_a2 = (struct _struct_D_800E8234_0x8 *) temp_t8;
                phi_a2 = (struct _struct_D_800E8234_0x8 *) temp_t8;
                if (type != (gPlayerWinningIndex + 0xB1)) {

                }
            }
        } else {
            temp_t9 = type * 4;
            phi_a2 = (struct _struct_D_800E8234_0x8 *) temp_t9;
            phi_a2 = (struct _struct_D_800E8234_0x8 *) temp_t9;
            if (*(&D_801640F4 + temp_t9) != 0) {

            }
        }
        if (phi_v1_4 != 0) {
            phi_v1_5 = temp_a1 * 4;
            phi_a0_2 = D_800E8420[temp_a1];
        } else {
            phi_v1_5 = temp_a1 * 4;
            phi_a0_2 = D_800E8320[temp_a1];
        }
        sp7C = phi_ra;
        sp20 = phi_v1_5;
        sp24 = phi_a2;
        sp3C = type - 0xB1;
        phi_ra->D_8018DEE0_index = func_8009A478(segmented_to_virtual_dupe(phi_a0_2), sp3C);
        func_800996BC(segmented_to_virtual(*(&D_800E7D54 + phi_v1_5)), 0);
        func_80099184(segmented_to_virtual(*(&D_800E7FF0 + phi_a2)));
        return;
    case 0xBB:
        sp7C = phi_ra;
        phi_ra->unk1C = func_800B5020(D_8018CA78, D_800E86A8, priority);
        phi_ra->unk20 = func_800B5218();
        if (D_80162DD4 != 1) {
            sp7C = phi_ra;
            if (func_800051C4() >= 0x3C01) {
                D_80162DD4 = 1;
            }
        }
        if ((phi_ra->unk1C == 0) || (phi_ra->unk20 != 0)) {
            func_800B559C((gCupSelection * 4) + gCupCourseSelection);
            return;
        }
        return;
    case 0xE6:
        temp_v0_10 = gTimeTrialDataCourseIndex;
        sp7C = phi_ra;
        phi_ra->D_8018DEE0_index = func_8009A374(segmented_to_virtual_dupe(D_800E7E34[*(gCupCourseOrder + ((((s32) temp_v0_10 / 4) * 8) + (((s32) temp_v0_10 % 4) * 2)))]));
        phi_ra->unk1C = (s32) gTimeTrialDataCourseIndex;
        func_800996BC(segmented_to_virtual((u32) &D_02004A0C), 0);
        func_8006EF60();
        if (func_800B5B94() == 0) {
            func_800B6708();
            return;
        }
        D_8018EE10.unk4 = 0;
        D_8018EE10.unk84 = 0;
        return;
    case 0xF0:
        phi_ra->unk4 = (s32) gSoundMode;
        return;
    case 0xF1:
        func_800996BC(segmented_to_virtual((u32) &D_02004638), 0);
        return;
    case 0xBE:
        D_8018ED90 = 0;
        return;
    case 0x130:
        temp_a1_2 = *(&D_800EFD64 + D_802874D8.unk1E);
        if ((s32) D_802874D8.unk1D >= 3) {
            phi_v0_2 = 1;
        }
        phi_v1 = temp_a1_2 * 4;
        if (phi_v0_2 != 0) {
            phi_v1 = temp_a1_2 * 4;
            phi_a0 = D_800E8420[temp_a1_2];
        } else {
            phi_a0 = D_800E8320[temp_a1_2];
        }
        sp7C = phi_ra;
        sp20 = phi_v1;
        phi_ra->D_8018DEE0_index = func_8009A478(segmented_to_virtual_dupe(phi_a0), 0);
        func_800996BC(segmented_to_virtual(*(&D_800E7D54 + phi_v1)), 0);
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/add_8018D9E0_entry.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void *draw_box(void *, s32, s32, s32, s32, s32, s32, s32, s32); /* extern */
? draw_text(s32, s32, ? *, ?, f32, f32);            /* extern */
? func_8004C8D4(s16, s16);                          /* extern */
s32 get_string_width(? *);                             /* extern */
? func_80093324(s32, s32, ? *, s32, f32, f32);      /* extern */
? func_800936B8(s32, s32, ? *, s32, f32, f32);      /* extern */
? func_800939C8(?, ?, ? *, ?, f32, f32);            /* extern */
? func_80094660(s32, s32);                          /* extern */
? func_800947B4(s32, s32);                          /* extern */
void *func_800959A0(void *, s32, s32, s32, s32);    /* extern */
void *func_800959CC(void *, s32, s32, s32, s32);    /* extern */
void *func_80096CD8(void *, ?, ?, ?, s32);          /* extern */
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); /* extern */
? func_8009A76C(s32, s32, s32, s32);                /* extern */
? func_8009A7EC(s32, s32, s32, s32, s32);           /* extern */
void *func_8009B9D0(void *, ? *);                   /* extern */
void *func_8009BA74(void *, ? *, s32, s32);         /* extern */
void *func_8009BC9C(void *, ? *, s32, s32, s32, s32); /* extern */
? func_800A09E0(void *);                            /* extern */
? func_800A0AD0(void *);                            /* extern */
? func_800A0B80(void *);                            /* extern */
? func_800A0DFC(s32);                               /* extern */
? func_800A0EB8(void *, s32);                       /* extern */
? func_800A0FA4(void *, s32);                       /* extern */
? func_800A10CC(void *);                            /* extern */
? func_800A11D0(void *, s32, s32);                  /* extern */
? func_800A12BC(void *, ? *);                       /* extern */
? func_800A143C(void *, s32);                       /* extern */
? func_800A1500(void *);                            /* extern */
? func_800A15EC(void *);                            /* extern */
? func_800A1780(void *);                            /* extern */
? func_800A1924(void *);                            /* extern */
? func_800A1A20(void *);                            /* extern */
? func_800A1BE0(void *);                            /* extern */
? func_800A1DE0(void *);                            /* extern */
? func_800A1F30(void *);                            /* extern */
? func_800A1FB0(void *);                            /* extern */
? func_800A2D1C(void *);                            /* extern */
? func_800A2EB8(void *);                            /* extern */
? func_800A34A8(void *);                            /* extern */
? func_800A3C84(void *);                            /* extern */
? func_800A3E60(void *);                            /* extern */
? func_800A4A24(void *);                            /* extern */
? func_800A4B38(void *);                            /* extern */
? func_800A5738(void *);                            /* extern */
? func_800A6034(void *);                            /* extern */
? func_800A6154(void *);                            /* extern */
? func_800A638C(void *);                            /* extern */
? func_800A70E8(void *);                            /* extern */
? func_800A7258(void *);                            /* extern */
? func_800A72FC(void *);                            /* extern */
? func_800A7448(void *);                            /* extern */
? func_800A75A0(void *);                            /* extern */
? func_800A761C(void *);                            /* extern */
? func_800A7790(void *);                            /* extern */
? get_time_record_minutes(s32, ? *);                          /* extern */
? get_time_record_seconds(s32, ? *);                          /* extern */
? get_time_record_centiseconds(s32, ? *);                          /* extern */
? func_800A8270(s32, void *);                       /* extern */
? func_800A8564(void *);                            /* extern */
? func_800A86E8(void *);                            /* extern */
? func_800A874C(void *);                            /* extern */
? func_800A890C(s32, void *);                       /* extern */
? func_800A8A98(void *);                            /* extern */
? func_800A8CA4(void *);                            /* extern */
? func_800A8E14(void *);                            /* extern */
? func_800A8EC0(void *);                            /* extern */
? func_800A8F48(void *);                            /* extern */
? func_800A90D4(s32, void *);                       /* extern */
s32 func_800B4EB4(?, ?);                            /* extern */
s32 func_800B555C(s32);                             /* extern */
void *segmented_to_virtual(segment_address_t);              /* extern */
? set_text_color(s32);                              /* extern */
extern s32 D_800DC540;
extern s32 D_800DC548;
extern ? D_8018EDE8;
extern s8 gMainMenuSelectionDepth;
extern s8 D_8018EDF3;
extern s8 D_802874F6;
extern ? gCharacterGridSelections;
extern void *gDisplayListHead;
extern s32 gGfxPool;
extern s32 gGlobalTimer;
static ? D_020014C8;                                /* unable to generate initializer */
static ? D_02001540;                                /* unable to generate initializer */
static ? D_020015A4;                                /* unable to generate initializer */
static ? D_020015CC;                                /* unable to generate initializer */
static ? D_02001630;                                /* unable to generate initializer */
static ? D_02001658;                                /* unable to generate initializer */
static ? D_020045E8;                                /* unable to generate initializer */
static ? D_02004610;                                /* unable to generate initializer */
static ? D_02004638;                                /* unable to generate initializer */
static ? D_02004660;                                /* unable to generate initializer */
static ? D_0200487C;                                /* unable to generate initializer */
static ? D_02004A34;                                /* unable to generate initializer */
static ? D_02004B4C;                                /* unable to generate initializer */
static ? D_02004B74;                                /* unable to generate initializer */
static ? D_02004E80;                                /* unable to generate initializer */
static s16 gCurrentCourseId;                        /* type too large by 2; unable to generate initializer */
static ? D_800E7500;                                /* unable to generate initializer; const */
static ? D_800E7524;                                /* unable to generate initializer; const */
static ? *D_800E7574[8] = {
    "mario raceway",
    "choco mountain",
    "bowser's castle",
    "banshee boardwalk",
    "yoshi valley",
    "frappe snowland",
    "koopa troopa beach",
    "royal raceway",
}; /* const */
static ? D_800E7594;                                /* unable to generate initializer; const */
static ? *D_800E77A0[2] = { "CONNECT A CONTROLLER TO SOCKET 1,", "THEN POWER ON AGAIN" }; /* const */
static ? D_800E77A8;                                /* unable to generate initializer; const */
static ? D_800E7CA8;                                /* unable to generate initializer; const */
static ? D_800E7D4C;                                /* unable to generate initializer; const */
static ? D_800E7D54;                                /* unable to generate initializer; const */
static ? D_800E817C;                                /* unable to generate initializer; const */
static ? D_800E824C;                                /* unable to generate initializer; const */
static ? D_800E8254;                                /* unable to generate initializer; const */
static ? D_800E8294;                                /* unable to generate initializer; const */
static ? gCharacterSelections;                                /* unable to generate initializer; const */
static ? gGameModeRowSelectionForNumPlayers;                                /* unable to generate initializer; const */
static ? gGameModeSubMenuRowSelectionForNumPlayers;                                /* unable to generate initializer; const */
static ? D_800EFD64;                                /* unable to generate initializer; const */
static ? gGameModeFromNumPlayersAndRowSelection;                                /* unable to generate initializer; const */

void func_8009F5E0(void *arg0) {
    s32 spAC;
    s32 spA8;
    ? *sp9C;
    ? sp80;
    s32 sp58;
    f32 sp4C;
    s32 sp44;
    ? **sp40;
    s32 sp3C;
    f32 sp38;
    ? **temp_v0_8;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_4;
    s32 temp_a1_5;
    s32 temp_a1_6;
    s32 temp_a1_7;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_a2_6;
    s32 temp_a2_8;
    s32 temp_a2_9;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t4;
    s32 temp_t5;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_v0_10;
    s32 temp_v0_13;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v0_9;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 temp_v1_8;
    s8 temp_a2;
    s8 temp_a2_5;
    s8 temp_a2_7;
    s8 temp_v0_11;
    s8 temp_v0_12;
    s8 temp_v0_4;
    s8 temp_v1_7;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v1;
    void *temp_v1_2;
    f32 phi_f0;
    void *phi_v0;
    s32 phi_t0;
    ? **phi_v0_2;
    s32 phi_v1;
    s32 phi_t0_2;
    s32 phi_v1_2;
    s32 phi_a2;
    s8 phi_a2_2;
    s32 phi_a1;
    void *phi_v0_3;
    s32 phi_a2_3;
    s32 phi_a2_4;

    if (arg0->unk15 != 0) {
        temp_v1 = gDisplayListHead;
        gDisplayListHead = temp_v1 + 8;
        temp_v1->unk4 = 0;
        temp_v1->unk0 = 0xE7000000;
        temp_t0 = arg0->unk0;
        phi_t0_2 = temp_t0;
        if (temp_t0 >= 0x10F) {
            if (temp_t0 >= 0x131) {
                switch (temp_t0) {                  /* switch 1 */
                    func_800A7790(arg0);
                    break;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            }
            switch (temp_t0) {                      /* switch 2 */
            case 0x12B:                             /* switch 2 */
                func_800A7258(arg0);
                return;
            case 0x12C:                             /* switch 2 */
                func_800A72FC(arg0);
                return;
            case 0x12D:                             /* switch 2 */
                func_800A7448(arg0);
                return;
            case 0x12E:                             /* switch 2 */
                func_800A75A0(arg0);
                return;
            case 0x12F:                             /* switch 2 */
                func_800A761C(arg0);
                return;
            case 0x130:                             /* switch 2 */
                if (arg0->unk4 != 0) {
                    temp_a2 = *(&D_800EFD64 + D_802874F6);
                    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7D54 + (temp_a2 * 4))), arg0->unkC, arg0->unk10);
                    func_8009A7EC(arg0->unk18, arg0->unkC, arg0->unk10, 0, arg0->unk1C);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            }
        } else if (temp_t0 >= 0x38) {
            switch (temp_t0) {                      /* switch 3 */
            case 0xFA:                              /* switch 3 */
                func_80094660(gGfxPool, arg0->unk1C);
                return;
            case 0xFB:                              /* switch 3 */
                func_800947B4(gGfxPool, arg0->unk1C);
                return;
            case 0xD2:                              /* switch 3 */
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_020014C8);
                return;
            case 0xD3:                              /* switch 3 */
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_02001540);
                return;
            case 0xD4:                              /* switch 3 */
                func_800A09E0(arg0);
                func_800A0AD0(arg0);
                func_800A0B80(arg0);
                return;
            case 0xD5:                              /* switch 3 */
            // Sets the text color of the text on the Controller Pak menu
            // Also sets the color of the shading at the top and bottom of the menu
            // Does not set color of the text in the table itself
                gDPSetPrimColor(gDisplayListHead, 0, 0, 0x00, 0x00, 0x00, 0xFF);
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_020015A4);
                gDPSetPrimColor(gDisplayListHead, 0, 0, 0x32, 0x00, 0x00, 0xFF);
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_020015CC);
                gDPSetPrimColor(gDisplayListHead, 0, 0, 0x00, 0x32, 0x00, 0xFF);
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_02001630);
                gDPSetPrimColor(gDisplayListHead, 0, 0, 0x32, 0x32, 0x00, 0xFF);
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_02001658);
                return;
            case 0xD6:                              /* switch 3 */
                func_8009A76C(arg0->unk0, arg0->unk0, arg0->unk0, -1);
                return;
            case 0xD7:                              /* switch 3 */
                func_800A0DFC(temp_t0);
                return;
            case 0xD8:                              /* switch 3 */
            case 0xD9:                              /* switch 3 */
                func_800A0EB8(arg0, temp_t0 - 0xD8);
                return;
            case 0x58:                              /* switch 3 */
            case 0x59:                              /* switch 3 */
            case 0x5A:                              /* switch 3 */
            case 0x5B:                              /* switch 3 */
            case 0x5C:                              /* switch 3 */
                func_800A8A98(arg0);
                gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E817C + (arg0->unk0 * 4))), arg0->unkC, arg0->unk10);
                func_800A8CA4(arg0);
                return;
            case 0x52:                              /* switch 3 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E817C + (temp_t0 * 4))), arg0->unkC, arg0->unk10);
                return;
            case 0x5F:                              /* switch 3 */
            case 0x60:                              /* switch 3 */
            case 0x61:                              /* switch 3 */
            case 0x62:                              /* switch 3 */
                func_800A1500(arg0);
                return;
            case 0x53:                              /* switch 3 */
            case 0x54:                              /* switch 3 */
            case 0x55:                              /* switch 3 */
            case 0x56:                              /* switch 3 */
                temp_a0 = temp_t0 - 0x53;
                spAC = temp_a0;
                func_800A890C(temp_a0, arg0);
                func_800A143C(arg0, spAC);
                return;
            case 0x5D:                              /* switch 3 */
                func_800A8564(arg0);
                gDisplayListHead = func_8009BC9C(gDisplayListHead, &D_02004E80, arg0->unkC, arg0->unk10, 2, arg0->unk1C);
                return;
            case 0x65:                              /* switch 3 */
            case 0x66:                              /* switch 3 */
                if (temp_t0 == 0x65) {
                    phi_f0 = 0.6f;
                } else {
                    phi_f0 = 0.8f;
                }
                sp4C = phi_f0;
                func_800A86E8(arg0);
                set_text_color(TEXT_YELLOW);
                func_80093324(arg0->unkC + 8, arg0->unk10 + 0x10, *(&D_800E7594 + (arg0->unk0 * 4)), 0, phi_f0, 0.8f);
                func_800A874C(arg0);
                return;
            case 0x6E:                              /* switch 3 */
                func_800A8E14(arg0);
                return;
            case 0x67:                              /* switch 3 */
                func_800A8EC0(arg0);
                return;
            case 0x68:                              /* switch 3 */
                temp_a1 = arg0->unkC;
                temp_a2_2 = arg0->unk10;
                gDisplayListHead = func_80098C18(gDisplayListHead, temp_a1, temp_a2_2, temp_a1 + 0x3F, temp_a2_2 + 0x11, 1, 1, 1, 0xFF);
                gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E8294 + (D_800DC548 * 4))), arg0->unkC, arg0->unk10);
                return;
            case 0x69:                              /* switch 3 */
                func_800A8F48(arg0);
                return;
            case 0x78:                              /* switch 3 */
            case 0x79:                              /* switch 3 */
            case 0x7A:                              /* switch 3 */
            case 0x7B:                              /* switch 3 */
                temp_a0_2 = temp_t0 - 0x78;
                spAC = temp_a0_2;
                func_800A90D4(temp_a0_2, arg0);
                func_800A143C(arg0, spAC);
                return;
            case 0x8C:                              /* switch 3 */
                temp_v0_4 = gMainMenuSelectionDepth;
                if ((temp_v0_4 >= GAME_MODE_CC_OR_TIME_TRIALS_OPTIONS_SELECTION) && (spAC == (temp_t0 - spA8))) {
                    if (temp_v0_4 >= CONFIRM_OK_SELECTION) {
                        temp_a1_2 = arg0->unkC;
                        temp_a2_3 = arg0->unk10;
                        phi_v0 = func_80098C18(gDisplayListHead, temp_a1_2, temp_a2_3, temp_a1_2 + 0x3F, temp_a2_3 + 0x11, 0xFF, 0xF9, 0xDC, 0xFF);
                    } else {
                        temp_v1_3 = arg0->unk10;
                        temp_v0_5 = arg0->unkC;
                        phi_v0 = func_800959A0(gDisplayListHead, temp_v0_5, temp_v1_3, temp_v0_5 + 0x3F, temp_v1_3 + 0x11);
                    }
                } else {
                    temp_a1_3 = arg0->unkC;
                    temp_a2_4 = arg0->unk10;
                    phi_v0 = func_80098C18(gDisplayListHead, temp_a1_3, temp_a2_4, temp_a1_3 + 0x3F, temp_a2_4 + 0x11, 1, 1, 1, 0xFF);
                }
                gDisplayListHead = phi_v0;
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004A34, arg0->unkC, arg0->unk10);
                set_text_color(TEXT_YELLOW);
                func_800936B8(0x125, 0x1C, "a BUTTON*SEE DATA  B BUTTON*EXIT", 0, 0.55f, 0.55f);
                return;
            case 0x8D:                              /* switch 3 */
                func_800A1780(arg0);
                return;
            case 0x7C:                              /* switch 3 */
            case 0x7D:                              /* switch 3 */
            case 0x7E:                              /* switch 3 */
            case 0x7F:                              /* switch 3 */
            case 0x80:                              /* switch 3 */
            case 0x81:                              /* switch 3 */
            case 0x82:                              /* switch 3 */
            case 0x83:                              /* switch 3 */
            case 0x84:                              /* switch 3 */
            case 0x85:                              /* switch 3 */
            case 0x86:                              /* switch 3 */
            case 0x87:                              /* switch 3 */
            case 0x88:                              /* switch 3 */
            case 0x89:                              /* switch 3 */
            case 0x8A:                              /* switch 3 */
            case 0x8B:                              /* switch 3 */
                func_800A15EC(arg0);
                return;
            case 0x96:                              /* switch 3 */
                set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
                func_800936B8(arg0->unkC, arg0->unk10, *(&D_800E7500 + (D_800DC540 * 4)), arg0->unk1C, arg0->unk24, 1.0f);
                return;
            case 0x97:                              /* switch 3 */
                set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
                func_80093324(arg0->unkC, arg0->unk10, *(&D_800E7524 + (gCurrentCourseId * 4)), arg0->unk1C, arg0->unk24, 1.0f);
                return;
            case 0x98:                              /* switch 3 */
                func_800A2D1C(arg0);
                return;
            case 0x5E:                              /* switch 3 */
                gDisplayListHead = func_80096CD8(gDisplayListHead, 0x19, 0x72, 0x7C, 0x4A);
                return;
            case 0xAA:                              /* switch 3 */
                func_800A2EB8(arg0);
                return;
            case 0xAB:                              /* switch 3 */
                func_800A34A8(arg0);
                return;
            case 0xAC:                              /* switch 3 */
                func_800A6154(arg0);
                return;
            case 0xAF:                              /* switch 3 */
                func_800A6034(arg0);
                return;
            case 0xB0:                              /* switch 3 */
                func_800A638C(arg0);
                return;
            case 0xB1:                              /* switch 3 */
            case 0xB2:                              /* switch 3 */
            case 0xB3:                              /* switch 3 */
            case 0xB4:                              /* switch 3 */
                temp_v0_6 = temp_t0 - 0xB1;
                if (arg0->unk4 != 0) {
                    temp_a2_5 = *(&D_800EFD64 + *(&gCharacterSelections + temp_v0_6));
                    spA8 = temp_v0_6;
                    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7D54 + (temp_a2_5 * 4))), arg0->unkC, arg0->unk10);
                    func_8009A7EC(arg0->unk18, arg0->unkC, arg0->unk10, spA8, arg0->unk1C);
                    func_800A11D0(arg0, spA8, 0xFF);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0xB9:                              /* switch 3 */
                func_800A3C84(arg0);
                return;
            case 0xBA:                              /* switch 3 */
                func_800A3E60(arg0);
                return;
            case 0xBC:                              /* switch 3 */
                func_800A4A24(arg0);
                return;
            case 0xC7:                              /* switch 3 */
                func_800A4B38(arg0);
                return;
            case 0xBD:                              /* switch 3 */
                func_800A5738(arg0);
                return;
            case 0xE6:                              /* switch 3 */
                func_800A1924(arg0);
                return;
            case 0xE7:                              /* switch 3 */
                func_800A1A20(arg0);
                return;
            case 0xE8:                              /* switch 3 */
                func_800A1BE0(arg0);
                return;
            case 0xE9:                              /* switch 3 */
                func_800A1DE0(arg0);
                return;
            case 0xEA:                              /* switch 3 */
                func_800A1F30(arg0);
                return;
            case 0xF0:                              /* switch 3 */
                func_800A1FB0(arg0);
                return;
            case 0xF1:                              /* switch 3 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004638, arg0->unkC, arg0->unk10);
                return;
            case 0x10E:                             /* switch 3 */
                func_800A70E8(arg0);
                return;
            }
        } else {
            switch (temp_t0) {                      /* switch 4 */
            case 0x1:                               /* switch 4 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, *(&D_800E7D4C + (func_800B555C(temp_t0) * 4)), arg0->unk0, arg0->unk0);
                return;
            case 0x2:                               /* switch 4 */
                func_8004C8D4(arg0->unk0 + 0xA0, arg0->unk0 + 0x47);
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_020045E8, arg0->unk0, arg0->unk0);
                return;
            case 0x3:                               /* switch 4 */
                if (((gGlobalTimer / 8) % 3) != 0) {
                    gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004610, arg0->unk0, arg0->unk0);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0x5:                               /* switch 4 */
                temp_t4 = ((get_string_width(*D_800E7574) + 5) * 0.9f) / 2;
                gDisplayListHead = draw_box(gDisplayListHead, 0xA0 - temp_t4, 0x7B, temp_t4 + 0xA0, 0xA4, 0, 0, 0, 0x96);
                set_text_color(TEXT_GREEN);
                draw_text(0x9B, 0x8C, *D_800E7574, 0, 0.9f, 0.9f);
                temp_v1_4 = func_800B4EB4(0, 7) & 0xFFFFF;
                if (temp_v1_4 < 0x1EAA) {
                    set_text_color(gGlobalTimer % 2);
                } else if (temp_v1_4 < 0x2329) {
                    set_text_color(gGlobalTimer % 3);
                } else {
                    set_text_color(TEXT_YELLOW);
                }
                get_time_record_minutes(temp_v1_4, &sp80);
                func_800939C8(0x77, 0xA0, &sp80, 0, 1.0f, 1.0f);
                func_80093324(0x8B, 0xA0, "'", 0, 1.0f, 1.0f);
                get_time_record_seconds(temp_v1_4, &sp80);
                func_800939C8(0x94, 0xA0, &sp80, 0, 1.0f, 1.0f);
                func_80093324(0xA7, 0xA0, "\"", 0, 1.0f, 1.0f);
                get_time_record_centiseconds(temp_v1_4, &sp80);
                func_800939C8(0xB4, 0xA0, &sp80, 0, 1.0f, 1.0f);
                return;
            case 0x4:                               /* switch 4 */
                sp58 = get_string_width(D_800E77A0->unk0);
                temp_v0_7 = get_string_width(D_800E77A0->unk4);
                phi_t0 = sp58;
                if (sp58 < temp_v0_7) {
                    phi_t0 = temp_v0_7;
                }
                temp_t2 = (phi_t0 * 0.75f) / 2;
                temp_t5 = (((0.75f * 2.0f) + 0.5) * 16.0) / 2;
                gDisplayListHead = draw_box(gDisplayListHead, 0xA0 - temp_t2, 0xB6 - temp_t5, temp_t2 + 0xA0, temp_t5 + 0xB6, 0, 0, 0, 0x96);
                set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
                sp38 = 0xB4;
                sp3C = 0xA0 - (1.0f * 0.75f);
                phi_v0_2 = D_800E77A0;
                phi_v1 = 0;
                do {
                    sp40 = phi_v0_2;
                    sp44 = phi_v1;
                    draw_text(sp3C, sp38 + (phi_v1 * 0.75f), *phi_v0_2, 0, 0.75f, 0.75f);
                    temp_v0_8 = phi_v0_2 + 4;
                    phi_v0_2 = temp_v0_8;
                    phi_v1 += 0x12;
                } while (temp_v0_8 != &D_800E77A8);
                return;
            case 0x23:                              /* switch 4 */
            case 0x24:                              /* switch 4 */
            case 0x25:                              /* switch 4 */
                gDisplayListHead = func_8009BC9C(gDisplayListHead, *(&D_800E7D4C + (func_800B555C(temp_t0) * 4)), arg0->unkC, arg0->unk10, 3, 0);
                return;
            case 0xA:                               /* switch 4 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004660, arg0->unkC, arg0->unk10);
                return;
            case 0xB:                               /* switch 4 */
            case 0xC:                               /* switch 4 */
            case 0xD:                               /* switch 4 */
            case 0xE:                               /* switch 4 */
                temp_a0_3 = temp_t0 - 0xB;
                spAC = temp_a0_3;
                func_800A8270(temp_a0_3, arg0);
                func_800A0FA4(arg0, spAC);
                return;
            case 0xF:                               /* switch 4 */
                func_800A8564(arg0);
                gDisplayListHead = func_8009BC9C(gDisplayListHead, &D_0200487C, arg0->unkC, arg0->unk10, 2, arg0->unk1C);
                return;
            case 0x10:                              /* switch 4 */
            case 0x11:                              /* switch 4 */
                temp_v1_5 = arg0->unk1C;
                phi_v1_2 = temp_v1_5;
                if (temp_v1_5 < 0x20) {
                    temp_t9 = (temp_v1_5 * 0x3A) / 64;
                    if ((temp_t0 - 0xF) == gMainMenuSelectionDepth) {
                        temp_v0_9 = arg0->unkC;
                        temp_v1_6 = arg0->unk10;
                        gDisplayListHead = func_800959CC(gDisplayListHead, temp_v0_9 + temp_t9, temp_v1_6, (temp_v0_9 - temp_t9) + 0x39, temp_v1_6 + 0x12);
                    } else {
                        temp_v0_10 = arg0->unkC;
                        temp_a2_6 = arg0->unk10;
                        gDisplayListHead = func_80098C18(gDisplayListHead, temp_v0_10 + temp_t9, temp_a2_6, (temp_v0_10 - temp_t9) + 0x39, temp_a2_6 + 0x12, 1, 1, 1, 0xFF);
                    }
                    phi_t0_2 = arg0->unk0;
                    phi_v1_2 = arg0->unk1C;
                }
                temp_t8 = phi_t0_2 - 0xA;
                spA8 = temp_t8;
                gDisplayListHead = func_8009BC9C(gDisplayListHead, *(&D_800E8254 + (temp_t8 * 4)), arg0->unkC, arg0->unk10, 2, phi_v1_2);
                return;
            case 0x12:                              /* switch 4 */
            case 0x13:                              /* switch 4 */
            case 0x14:                              /* switch 4 */
            case 0x15:                              /* switch 4 */
            case 0x16:                              /* switch 4 */
            case 0x17:                              /* switch 4 */
            case 0x18:                              /* switch 4 */
            case 0x19:                              /* switch 4 */
                temp_v0_11 = D_8018EDF3;
                temp_v1_7 = *(&gGameModeRowSelectionForNumPlayers + temp_v0_11);
                temp_a2_7 = *(&gGameModeSubMenuRowSelectionForNumPlayers + ((temp_v0_11 * 3) + temp_v1_7));
                temp_a1_4 = *(&gGameModeFromNumPlayersAndRowSelection + ((temp_v0_11 * 0xC) + (temp_v1_7 * 4)));
                phi_a2 = temp_a2_7;
                phi_a2_2 = temp_a2_7;
                phi_a1 = temp_a1_4;
                switch (temp_t0) {                  /* switch 5 */
                case 18:                            /* switch 5 */
                case 19:                            /* switch 5 */
                case 20:                            /* switch 5 */
                case 21:                            /* switch 5 */
                    if ((temp_a1_4 != 0) && (temp_a1_4 != 2)) {
                        phi_a2 = -1;
                    }
                    spA8 = 0x12;
                    spAC = phi_a2;
                    sp9C = segmented_to_virtual(*(&D_800E824C + (temp_t0 * 4)));
                    phi_a2_2 = phi_a2;
block_58:
                    phi_a1 = spA8;
                    break;
                case 22:                            /* switch 5 */
                case 23:                            /* switch 5 */
                    if (temp_a1_4 != 2) {
                        phi_a2_2 = -1;
                    } else {
                        spA8 = 0x16;
                        spAC = temp_a2_7;
                        sp9C = segmented_to_virtual(*(&D_800E824C + (temp_t0 * 4)));
                        phi_a2_2 = temp_a2_7;
                        goto block_58;
                    }
                    break;
                case 24:                            /* switch 5 */
                case 25:                            /* switch 5 */
                    if (temp_a1_4 != 1) {
                        phi_a2_2 = -1;
                    } else {
                        spA8 = 0x18;
                        spAC = temp_a2_7;
                        sp9C = segmented_to_virtual(*(&D_800E824C + (temp_t0 * 4)));
                        phi_a2_2 = temp_a2_7;
                        goto block_58;
                    }
                    break;
                }
                if (phi_a2_2 != -1) {
                    temp_v0_12 = gMainMenuSelectionDepth;
                    if ((temp_v0_12 >= GAME_MODE_CC_OR_TIME_TRIALS_OPTIONS_SELECTION) && (phi_a2_2 == (arg0->unk0 - phi_a1))) {
                        if (temp_v0_12 >= CONFIRM_OK_SELECTION) {
                            temp_a1_5 = arg0->unkC;
                            temp_a2_8 = arg0->unk10;
                            phi_v0_3 = func_80098C18(gDisplayListHead, temp_a1_5, temp_a2_8, temp_a1_5 + 0x3F, temp_a2_8 + 0x11, 0xFF, 0xF9, 0xDC, 0xFF);
                        } else {
                            temp_v1_8 = arg0->unk10;
                            temp_v0_13 = arg0->unkC;
                            phi_v0_3 = func_800959A0(gDisplayListHead, temp_v0_13, temp_v1_8, temp_v0_13 + 0x3F, temp_v1_8 + 0x11);
                        }
                    } else {
                        temp_a1_6 = arg0->unkC;
                        temp_a2_9 = arg0->unk10;
                        phi_v0_3 = func_80098C18(gDisplayListHead, temp_a1_6, temp_a2_9, temp_a1_6 + 0x3F, temp_a2_9 + 0x11, 1, 1, 1, 0xFF);
                    }
                    gDisplayListHead = phi_v0_3;
                    gDisplayListHead = func_8009BA74(gDisplayListHead, sp9C, arg0->unkC, arg0->unk10);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0x1B:                              /* switch 4 */
                func_800A10CC(arg0);
                return;
            case 0x2A:                              /* switch 4 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004B4C, arg0->unkC, arg0->unk10);
                return;
            case 0x34:                              /* switch 4 */
            case 0x35:                              /* switch 4 */
            case 0x36:                              /* switch 4 */
            case 0x37:                              /* switch 4 */
                temp_a1_7 = temp_t0 - 0x34;
                if (*(&gCharacterGridSelections + temp_a1_7) != 0) {
                    if (*(&D_8018EDE8 + temp_a1_7) == 0) {
                        phi_a2_3 = 0xFF;
                    } else {
                        temp_t1 = gGlobalTimer % 16;
                        if (temp_t1 >= 8) {
                            phi_a2_4 = (temp_t1 * -8) + 0x80;
                        } else {
                            phi_a2_4 = temp_t1 * 8;
                        }
                        phi_a2_3 = phi_a2_4 + 0xBF;
                    }
                    func_800A11D0(arg0, temp_a1_7, phi_a2_3);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0x33:                              /* switch 4 */
                func_800A8564(arg0);
                gDisplayListHead = func_8009BC9C(gDisplayListHead, &D_02004B74, arg0->unkC, arg0->unk10, 2, arg0->unk1C);
                return;
            case 0x2B:                              /* switch 4 */
            case 0x2C:                              /* switch 4 */
            case 0x2D:                              /* switch 4 */
            case 0x2E:                              /* switch 4 */
            case 0x2F:                              /* switch 4 */
            case 0x30:                              /* switch 4 */
            case 0x31:                              /* switch 4 */
            case 0x32:                              /* switch 4 */
                func_800A12BC(arg0, segmented_to_virtual(*(&D_800E7CA8 + (temp_t0 * 4))));
            case 0xA0:                              /* switch 3 */
            case 0xA1:                              /* switch 3 */
                func_8009A76C(arg0->unk18, arg0->unkC, arg0->unk10, arg0->unk1C);
                return;
            }
        }
    } else {
    default:                                        /* switch 4 */
    default:                                        /* switch 3 */
    default:                                        /* switch 2 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009F5E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8009BA74(s32, s32, s32, s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_800E7AF8;
extern s32 gDisplayListHead;

void func_800A08D8(s32 arg0, s32 arg1, s32 arg2) {
    s32 temp_a3;
    s32 temp_t6;
    s32 phi_a3;

    temp_a3 = arg0 & 0xFF;
    if (temp_a3 >= 0x10) {
        temp_t6 = (temp_a3 - 0x10) & 0xFF;
        phi_a3 = temp_t6;
        if (temp_t6 < 0x85) {
            if (temp_t6 >= 0x32) {
                phi_a3 = 0x2B;
            }
            gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7AF8 + (phi_a3 * 4))), arg1, arg2);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A08D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A08D8(s32, s32, ?); // extern

s32 func_800A095C(s8 *arg0, s32 arg1, s32 arg2, ? arg3) {
    s32 temp_s1;
    s8 temp_v0;
    s8 *phi_s2;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s3;
    s32 phi_s3_2;
    s32 phi_s3_3;

    phi_s2 = arg0;
    phi_s0 = arg2;
    phi_s1 = arg1;
    phi_s3 = 0;
    phi_s3_3 = 0;
    if (arg1 != 0) {
        do {
            temp_v0 = *phi_s2;
            phi_s3_2 = phi_s3_3;
            if (temp_v0 != 0) {
                phi_s3_2 = phi_s3_3 + 1;
            }
            func_800A08D8(temp_v0 & 0xFF, phi_s0, arg3);
            temp_s1 = phi_s1 - 1;
            phi_s2 += 1;
            phi_s0 += 8;
            phi_s1 = temp_s1;
            phi_s3 = phi_s3_2;
            phi_s3_3 = phi_s3_2;
        } while (temp_s1 != 0);
    }
    return phi_s3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A095C.s")
#endif

#ifdef NON_MATCHING
// Non-matching due to the constants 9 and 0xA being saved to the wrong registers
// Same functionality, but doesn't match byte for byte :/
void func_800A09E0(struct_8018D9E0_entry *arg0) {
    s32 table_row, x = 0x20, y;
    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, 319, 194);
    for(table_row = 0; table_row < 9; table_row++)
    {
        if ((D_800E86D0[0] != 0) || ((table_row != 0) && (table_row != 8)))
        {
            y = (table_row * 0xA) + arg0->row;
            gDisplayListHead = func_8009BA74(gDisplayListHead, &D_0200157C, x, y);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A09E0.s")
#endif

void func_800A0AD0(UNUSED struct_8018D9E0_entry *unused) {
    struct_8018D9E0_entry *temp_t1;
    // Find struct_8018D9E0_entry with a type/id of 0xDA
    temp_t1 = func_800AAEF4(0xDA);
    if ((gControllerPakMenuSelection != CONTROLLER_PAK_MENU_SELECT_RECORD) && (gControllerPakMenuSelection != CONTROLLER_PAK_MENU_END))
    {
        gDPSetPrimColor(gDisplayListHead++, 0, 0, 0xFF, temp_t1->unk20, 0x00, 0xFF);
        gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02001874, 0x24, (gControllerPakSelectedTableRow * 0xA) + 0x7C);
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A08D8(u8, s32, s32); // extern
s32 func_800A095C(void *, ?, ?, s32); // extern
extern s8 D_800E86C4;
extern ? D_8018E938;
extern ? D_8018EB34;
extern void *gDisplayListHead;

void func_800A0B80(void *arg0) {
    s32 temp_a2;
    s32 temp_lo;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s2;
    s32 temp_s5;
    s8 temp_v0;
    s8 temp_v0_2;
    void *temp_s4;
    void *temp_v1;
    void *temp_v1_2;
    s8 *phi_s6;
    s32 phi_s5;
    s32 phi_s0;
    s32 phi_s1;

    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk4 = 0x32FF;
    temp_v1->unk0 = 0xFA000000;
    phi_s6 = &D_800E86C4;
    phi_s5 = 0;
    do {
        temp_v0 = *phi_s6;
        if (temp_v0 != 0) {
            temp_s1 = phi_s5 * 0xA;
            temp_a2 = arg0->unk10 + temp_s1 + 1;
            if (temp_v0 < 0xA) {
                func_800A08D8((temp_v0 + 0x10) & 0xFF, 0x32, temp_a2);
            } else {
                func_800A08D8(((temp_v0 % 0xA) + 0x10) & 0xFF, 0x35, temp_a2);
                func_800A08D8(0x11, 0x2F, arg0->unk10 + temp_s1 + 1);
            }
            temp_v0_2 = *phi_s6;
            temp_s2 = arg0->unk10 + temp_s1 + 1;
            if (*(&D_8018EB34 + (temp_v0_2 * 4)) == 0) {
                temp_s4 = (temp_v0_2 << 5) - 0x20 + &D_8018E938;
                temp_s1_2 = func_800A095C(temp_s4 + 0xE, 0x10, 0x4F, temp_s2) * 8;
                if (temp_s4->unkA != 0) {
                    func_800A08D8(0x3C, temp_s1_2 + 0x4F, temp_s2);
                    func_800A08D8(temp_s4->unkA, temp_s1_2 + 0x57, temp_s2);
                }
                phi_s0 = (temp_s4->unk0 + 0xFF) >> 8;
                phi_s1 = 0x10;
                do {
                    func_800A08D8(((phi_s0 % 0xA) + 0x10) & 0xFF, phi_s1 + 0xFD, temp_s2);
                    temp_lo = phi_s0 / 0xA;
                    phi_s0 = temp_lo;
                    phi_s1 += -8;
                } while (temp_lo != 0);
            }
        }
        temp_s5 = phi_s5 + 1;
        phi_s6 += 1;
        phi_s5 = temp_s5;
    } while (temp_s5 != 9);
    temp_v1_2 = gDisplayListHead;
    gDisplayListHead = temp_v1_2 + 8;
    temp_v1_2->unk0 = 0xED000000;
    temp_v1_2->unk4 = 0x4FC3BC;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0B80.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8009BA74(s32, s32, s32, ?); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_800E7D0C;
extern s32 gControllerPakNumPagesFree;
extern s32 gDisplayListHead;

void func_800A0DFC(void) {
    s32 temp_lo;
    s32 phi_s0;
    s32 phi_s1;

    phi_s0 = gControllerPakNumPagesFree;
    phi_s1 = 0x110;
    do {
        temp_lo = phi_s0 / 0xA;
        gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7D0C + ((phi_s0 % 0xA) * 4))), phi_s1, 0xB8);
        phi_s0 = temp_lo;
        phi_s1 += -9;
    } while (temp_lo != 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0DFC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_8009BA74(void *, ? *, s16, s16); // extern
void *func_800AAEF4(?); // extern
extern ? D_0200184C;
extern ? D_800E7278;
extern void *gDisplayListHead;
extern s8 gControllerPakMenuSelection;

void func_800A0EB8(s32 arg0, s32 arg1) {
    s8 temp_v0;
    void *temp_t0;
    void *temp_t3;
    void *temp_v0_2;
    s32 phi_t1;

    temp_t3 = func_800AAEF4(0xDA);
    if (arg1 == 0) {
        if (gControllerPakMenuSelection == CONTROLLER_PAK_MENU_END) {
            phi_t1 = 1;
        } else {
            phi_t1 = 0;
        }
        goto block_7;
    }
    temp_v0 = gControllerPakMenuSelection;
    if ((temp_v0 == CONTROLLER_PAK_MENU_ERASE) || (temp_v0 == CONTROLLER_PAK_MENU_QUIT)) {
        phi_t1 = ((arg1 * 2) + temp_v0) - 3;
block_7:
        temp_t0 = gDisplayListHead;
        gDisplayListHead = temp_t0 + 8;
        temp_t0->unk0 = 0xFA000000;
        temp_t0->unk4 = ((temp_t3->unk20 & 0xFF) << 0x10) | 0xFF000000 | 0xFF;
        temp_v0_2 = (phi_t1 * 8) + &D_800E7278;
        gDisplayListHead = func_8009BA74(gDisplayListHead, &D_0200184C, temp_v0_2->unk0, temp_v0_2->unk2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0EB8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
static ? D_800E8234;                                /* unable to generate initializer; const */

void func_800A0FA4(void *arg0, s32 arg1) {
    u32 temp_t6;
    void *temp_s1;
    void *temp_s1_2;
    s32 phi_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
    case 2:
    case 3:
        temp_s1 = (arg1 * 8) + &D_800E8234;
        gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(temp_s1->unk0), arg0->unkC, arg0->unk10);
        phi_v0 = func_8009BA74(gDisplayListHead, segmented_to_virtual(temp_s1->unk4), arg0->unkC, arg0->unk10);
block_4:
        gDisplayListHead = phi_v0;
        break;
    case 1:
    case 4:
        temp_s1_2 = (arg1 * 8) + &D_800E8234;
        gDisplayListHead = func_8009BC9C(gDisplayListHead, segmented_to_virtual(temp_s1_2->unk0), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        phi_v0 = func_8009BC9C(gDisplayListHead, segmented_to_virtual(temp_s1_2->unk4), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        goto block_4;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0FA4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
/*
Failed to decompile function func_800A10CC:

Label L800A1114 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
*/
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A10CC.s")
#endif

void func_800A11D0(struct_8018D9E0_entry *arg0, s32 arg1, s32 arg2) {
    RGBA16 *temp_v1;

    temp_v1 = &D_800E74A8[arg1];
    gDPSetPrimColor(gDisplayListHead++, 0, 0, temp_v1->red, temp_v1->green, temp_v1->blue, temp_v1->alpha);
    gDPSetEnvColor(gDisplayListHead++, arg2, arg2, arg2, 0x00);
    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(D_800E82B4[arg1]), arg0->column, arg0->row);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800A12BC(void *arg0) {
    u32 temp_t6;
    s32 phi_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
    case 2:
    case 4:
        phi_v0 = func_8009BA74(gDisplayListHead, MIPS2C_ERROR(Read from unset register $a1), arg0->unkC);
block_4:
        gDisplayListHead = phi_v0;
        break;
    case 1:
    case 3:
        phi_v0 = func_8009BC9C(gDisplayListHead, MIPS2C_ERROR(Read from unset register $a1), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        goto block_4;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A12BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
static ? D_800E82C8;                                /* unable to generate initializer; const */

void func_800A143C(void *arg0, s32 arg1) {
    u32 temp_t6;
    s32 phi_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
    case 2:
    case 3:
        phi_v0 = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E82C8 + (arg1 * 4))), arg0->unkC, arg0->unk10);
block_4:
        gDisplayListHead = phi_v0;
        break;
    case 1:
    case 4:
        phi_v0 = func_8009BC9C(gDisplayListHead, segmented_to_virtual(*(&D_800E82C8 + (arg1 * 4))), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        goto block_4;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A143C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A76C(s32, s16, s16, ?); // extern
void *func_800AAEF4(?); // extern
extern ? D_800E7168;

void func_800A1500(void *arg0) {
    s32 sp1C;
    s32 temp_v1;
    void *temp_v0;
    void *temp_v0_2;
    s32 phi_a1;

    sp1C = 0;
    temp_v0 = func_800AAEF4(0x64);
    temp_v1 = temp_v0->unk4;
    phi_a1 = sp1C;
    if ((temp_v1 != 0) && (temp_v1 != 1)) {
        if (temp_v1 != 2) {
            if (temp_v1 != 3) {

            } else {
                goto block_7;
            }
        } else if (arg0->unk0 != ((temp_v0->unk1C % 4) + 0x5F)) {
block_7:
            phi_a1 = 1;
        }
    }
    if (phi_a1 != 0) {
        if (phi_a1 != 1) {
            return;
        }
        temp_v0_2 = (arg0->unk0 * 8) - 0x2F8 + &D_800E7168;
        func_8009A76C(arg0->unk18, temp_v0_2->unk0, temp_v0_2->unk2, -2);
        return;
    }
    func_8009A76C(arg0->unk18, 0x17, 0x70, -1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1500.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
s32 func_800959A0(s32, s32, s32, s32, s32); // extern
s32 func_8009C204(s32, s32, s32, s32, s32); // extern
s32 func_800B639C(s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_02004A0C;
extern ? D_800E7D74;
extern ? D_800E7DC4;
extern ? gCupCourseOrder;
extern s32 gDisplayListHead;

void func_800A15EC(void *arg0) {
    s32 sp44;
    s32 temp_a1;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1;
    s32 temp_v1_2;

    temp_v0 = arg0->unk0 - 0x7C;
    temp_a1 = *(&gCupCourseOrder + (((temp_v0 / 4) * 8) + ((temp_v0 % 4) * 2))) * 4;
    sp44 = temp_a1;
    temp_v0_2 = func_8009C204(gDisplayListHead, segmented_to_virtual(*(&D_800E7D74 + temp_a1)), arg0->unkC, arg0->unk10, 2);
    gDisplayListHead = temp_v0_2;
    temp_v1 = arg0->unk10;
    temp_s1 = arg0->unkC;
    gDisplayListHead = draw_box(temp_v0_2, temp_s1, temp_v1 + 0x27, temp_s1 + 0x40, temp_v1 + 0x30, 0, 0, 0, 0xFF);
    gDisplayListHead = func_8009C204(gDisplayListHead, segmented_to_virtual(*(&D_800E7DC4 + sp44)), arg0->unkC, arg0->unk10 + 0x27, 3);
    if (func_800B639C(arg0->unk0 - 0x7C) >= 0) {
        temp_v1_2 = arg0->unk10;
        temp_s1_2 = arg0->unkC;
        gDisplayListHead = func_800959A0(gDisplayListHead, temp_s1_2 + 0x20, temp_v1_2, temp_s1_2 + 0x3F, temp_v1_2 + 9);
        gDisplayListHead = func_8009C204(gDisplayListHead, segmented_to_virtual(&D_02004A0C), arg0->unkC + 0x20, arg0->unk10, 2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A15EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_8009BA74(void *, s32, s32, s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_02001FA4;
extern ? D_800E74D0;
extern void *gDisplayListHead;

void func_800A1780(void *arg0) {
    s32 temp_a2;
    s32 temp_a3;
    s32 temp_v0;
    void *temp_a1;
    void *temp_t0;
    void *temp_v1;

    temp_a3 = arg0->unk20;
    temp_v1 = &D_800E74D0 + (temp_a3 * 8);
    temp_v0 = arg0->unk1C;
    temp_a2 = 0x100 - temp_v0;
    temp_a1 = &D_800E74D0 + (((temp_a3 + 1) % 3) * 8);
    temp_t0 = gDisplayListHead;
    gDisplayListHead = temp_t0 + 8;
    temp_t0->unk0 = 0xFA000000;
    temp_t0->unk4 = ((((temp_v1->unk0 * temp_a2) + (temp_a1->unk0 * temp_v0)) / 0x100) << 0x18) | (((((temp_v1->unk2 * temp_a2) + (temp_a1->unk2 * temp_v0)) / 0x100) & 0xFF) << 0x10) | (((((temp_v1->unk4 * temp_a2) + (temp_a1->unk4 * temp_v0)) / 0x100) & 0xFF) << 8) | ((((temp_v1->unk6 * temp_a2) + (temp_a1->unk6 * temp_v0)) / 0x100) & 0xFF);
    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(&D_02001FA4), arg0->unkC, arg0->unk10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1780.s")
#endif

void func_800A1924(struct_8018D9E0_entry *arg0) {
    func_8009A76C(arg0->D_8018DEE0_index, 0x17, 0x84, -1);
    if (func_800B639C(gTimeTrialDataCourseIndex) >= TIME_TRIAL_DATA_LUIGI_RACEWAY) {
        gDisplayListHead = func_800959A0(gDisplayListHead, 0x57, 0x84, 0x96, 0x95);
        gDisplayListHead = func_8009BA74(gDisplayListHead, D_02004A0C, 0x57, 0x84);
    }
    func_8004EF9C(gCupCourseOrder[gTimeTrialDataCourseIndex / 4][gTimeTrialDataCourseIndex % 4]);
    do {
        gDPSetTextureFilter(gDisplayListHead++, G_TF_BILERP);
    } while(0);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(?, s32, s32, ?, f32, f32); // extern
? func_80093324(?, s32, ? *, ?, f32, f32); // extern
? func_800936B8(?, s32, s32, ?, f32, f32); // extern
? func_800A474C(s32, ?, s32); // extern
? set_text_color(?); // extern
extern ? D_800E7574;
extern ? *D_800E7728;
extern ? *D_800E772C;
extern ? D_800E77D8;
extern ? D_800E77E4;
extern s8 gTimeTrialDataCourseIndex;
extern ? gCupCourseOrder;

void func_800A1A20(void *arg0) {
    s16 temp_s1;
    s32 temp_s0;
    s32 temp_s0_2;
    s8 temp_v0;
    s32 phi_s0;
    s32 phi_s1;

    temp_v0 = gTimeTrialDataCourseIndex;
    temp_s1 = *(&gCupCourseOrder + (((temp_v0 / 4) * 8) + ((temp_v0 % 4) * 2)));
    arg0->unkC = 0x14;
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    temp_s0 = temp_s1 * 4;
    draw_text(0x69, arg0->unk10 + 0x19, *(&D_800E7574 + temp_s0), 0, 0.75f, 0.75f);
    set_text_color(TEXT_RED);
    func_80093324(0x2D, arg0->unk10 + 0x28, &D_800E77D8, 0, 0.75f, 0.75f);
    func_800936B8(0xA5, arg0->unk10 + 0x28, *(&D_800E77E4 + temp_s0), 1, 0.75f, 0.75f);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xA0, arg0->unk10 + 0x86, D_800E7728, 0, 0.75f, 0.75f);
    phi_s0 = 0;
    phi_s1 = 0;
    do {
        set_text_color(TEXT_RED);
        func_800A474C(phi_s0, 0x96, arg0->unk10 + phi_s1 + 0x92);
        temp_s0_2 = phi_s0 + 1;
        phi_s0 = temp_s0_2;
        phi_s1 += 0xD;
    } while (temp_s0_2 != 5);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xA0, arg0->unk10 + 0xD5, D_800E772C, 0, 0.75f, 0.75f);
    func_800A474C(5, 0x96, arg0->unk10 + 0xE1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1A20.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_80093358(?, s32, s32, ?, f32, f32); // extern
? func_800A66A8(s32, s16 *); // extern
s32 func_800B639C(s8); // extern
? set_text_color(?); // extern
extern s32 D_800E7834;
extern f32 D_800F1B54;
extern ? D_8018EB90;
extern s8 gTimeTrialDataCourseIndex;
extern s8 gCourseRecordsMenuSelection;
extern void *gDisplayListHead;

void func_800A1BE0(s32 arg0) {
    s16 sp7A;
    s16 sp78;
    f32 temp_f20;
    s32 temp_s0;
    s8 temp_v0;
    void *temp_v1;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s4;
    s32 *phi_s3;
    ? phi_s2;

    temp_v0 = gTimeTrialDataCourseIndex;
    temp_f20 = D_800F1B54;
    phi_s0 = 0;
    phi_s4 = 0x3F;
    phi_s3 = &D_800E7834;
    do {
        phi_s1 = 0;
        if (phi_s0 == gCourseRecordsMenuSelection) {
            phi_s2 = TEXT_BLUE_GREEN_RED_CYCLE_2;
        } else {
            phi_s2 = TEXT_GREEN;
            if (phi_s0 != 1) {
                if (phi_s0 != 2) {

                } else if (func_800B639C(gTimeTrialDataCourseIndex) < 0) {
                    goto block_9;
                }
            } else if ((((temp_v0 / 4) * 0x60) + ((temp_v0 % 4) * 0x18) + &D_8018EB90)->unk12 == 0) {
block_9:
                phi_s1 = 1;
            }
        }
        if (phi_s1 != 0) {
            set_text_color(TEXT_BLUE);
            temp_v1 = gDisplayListHead;
            gDisplayListHead = temp_v1 + 8;
            temp_v1->unk4 = 0x96;
            temp_v1->unk0 = 0xFA000000;
            func_80093358(0x25, phi_s4, *phi_s3, 0, temp_f20, temp_f20);
        } else {
            set_text_color(phi_s2);
            func_80093324(0x25, phi_s4, *phi_s3, 0, temp_f20, temp_f20);
        }
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
        phi_s4 += 0xD;
        phi_s3 += 4;
    } while (temp_s0 != 3);
    sp78 = 0x1F;
    sp7A = (gCourseRecordsMenuSelection * 0xD) + 0x3A;
    func_800A66A8(arg0, &sp78);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1BE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_800A66A8(s32, s16 *); // extern
? set_text_color(?); // extern
extern s32 D_800E7840;
extern ? D_800E7848;
extern f32 D_800F1B58;
extern s8 gCourseRecordsMenuSelection;
extern s8 D_8018EDF9;

void func_800A1DE0(s32 arg0) {
    s16 sp5A;
    s16 sp58;
    f32 temp_f20;
    s32 temp_s0;
    s32 temp_s2;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s2;
    ? phi_a0;
    s32 phi_s1_2;
    s32 *phi_s0_2;

    set_text_color(TEXT_GREEN);
    temp_f20 = D_800F1B58;
    phi_s0 = 0x3C;
    phi_s1 = 0;
    do {
        func_80093324(0x1B, phi_s0, (&D_800E7848 + (gCourseRecordsMenuSelection * 0xC) + phi_s1)->unk-C, 0, temp_f20, temp_f20);
        temp_s0 = phi_s0 + 0xD;
        phi_s0 = temp_s0;
        phi_s1 += 4;
    } while (temp_s0 < 0x63);
    phi_s2 = 0;
    phi_s1_2 = 0x6E;
    phi_s0_2 = &D_800E7840;
    do {
        phi_a0 = TEXT_GREEN;
        if (phi_s2 == D_8018EDF9) {
            phi_a0 = TEXT_BLUE_GREEN_RED_CYCLE_2;
        }
        set_text_color(phi_a0);
        func_80093324(0x43, phi_s1_2, *phi_s0_2, 0, temp_f20, temp_f20);
        temp_s2 = phi_s2 + 1;
        phi_s2 = temp_s2;
        phi_s1_2 += 0xD;
        phi_s0_2 += 4;
    } while (temp_s2 != 2);
    sp58 = 0x3B;
    sp5A = (D_8018EDF9 * 0xD) + 0x66;
    func_800A66A8(arg0, &sp58);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1DE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? set_text_color(?); // extern
extern s32 D_800E7860;

void func_800A1F30(s32 arg0) {
    s32 temp_s0;
    s32 phi_s0;
    s32 *phi_s1;

    set_text_color(TEXT_RED);
    phi_s0 = 0x49;
    phi_s1 = &D_800E7860;
    do {
        func_80093324(0x2A, phi_s0, *phi_s1, 0, 0.75f, 0.75f);
        temp_s0 = phi_s0 + 0x10;
        phi_s0 = temp_s0;
        phi_s1 += 4;
    } while (temp_s0 != 0x69);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1F30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
Gfx *draw_box(Gfx *, ?, ?, ?, s32, s32, s32, s32, s32); /* extern */
? draw_text(s32, s32, ? *, ?, f32, f32);            /* extern */
? func_800921C0(s32, s32, ?);                       /* extern */
? func_80092224(s32, s32, ?);                       /* extern */
? func_80093324(s16, s16, ? *, ?, f32, f32);        /* extern */
? func_800A66A8(void *, s16 *);                     /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? set_text_color(s32);                              /* extern */
extern ? D_8018EE10;
static ? D_800E75C4;                                /* unable to generate initializer; const */
static ? gSoundModeNames;                                /* unable to generate initializer; const */
static ? *D_800E7840[2] = { "quit", "erase" };      /* const */
static ? *D_800E7868[4] = {
    "RETURN TO GAME SELECT",
    "SOUND MODE",
    "COPY N64 CONTROLLER PAK",
    "ERASE ALL DATA",
}; /* const */
static ? *D_800E7878[3] = { "ALL SAVED DATA WILL BE", "PERMANENTLY ERASED.", "ARE YOU REALLY SURE?" }; /* const */
static ? *D_800E7884[3] = { "", "ALL SAVED DATA", "HAS BEEN NOW ERASED." }; /* const */
static ? D_800E7890;                                /* unable to generate initializer; const */
static ? D_800E78D0;                                /* unable to generate initializer; const */
static ? D_800E7900;                                /* unable to generate initializer; const */
static ? *D_800E7918[2] = { "CONTROLLER 1", "CONTROLLER 2" }; /* const */
static ? D_800E7920;                                /* unable to generate initializer; const */
static ? *D_800E7928[2] = { "CURRENT DATA WILL BE ERASED,", "IS THIS OK?" }; /* const */
static ? *D_800E7930[2] = { "QUIT", "COPY" };       /* const */
static ? D_800E7938;                                /* unable to generate initializer; const */
static ? *D_800E7A44 = "NO DATA";                   /* const */
static ? *D_800E7A48[3] = { "CREATING ", "MARIO KART 64 ", "GAME DATA" }; /* const */
static ? D_800E7A54;                                /* unable to generate initializer; const */
static ? gCupCourseOrder;                            /* unable to generate initializer; const */

void func_800A1FB0(void *arg0) {
    s16 spE2;
    s16 spE0;
    ? spB9;
    ? spB8;
    ? spA9;
    ? spA8;
    ? sp99;
    ? sp98;
    s32 sp88;
    ? **sp84;
    ? **sp78;
    ? **temp_s0_4;
    ? **temp_s1;
    ? **temp_s1_2;
    ? **temp_s1_3;
    ? **temp_v0_3;
    s16 temp_s0;
    s16 temp_s0_2;
    s16 temp_s0_3;
    s16 temp_s3;
    s16 temp_s3_3;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_s1_4;
    s32 temp_s1_5;
    s32 temp_s1_6;
    s32 temp_s2;
    s32 temp_s2_2;
    s32 temp_s2_3;
    s32 temp_s3_2;
    s8 temp_v0;
    s8 temp_v0_2;
    s8 temp_v0_4;
    s8 temp_v1;
    s8 temp_v1_2;
    s32 phi_a0;
    s32 phi_s2;
    s16 phi_s0;
    ? **phi_s1;
    s16 phi_s0_2;
    ? **phi_s1_2;
    s32 phi_a0_2;
    s32 phi_s2_2;
    s16 phi_s0_3;
    ? **phi_s1_3;
    s16 phi_s0_4;
    ? **phi_s1_4;
    s16 phi_s0_5;
    ? **phi_s1_5;
    s16 phi_s0_6;
    ? **phi_s1_6;
    s16 phi_s0_7;
    ? **phi_s1_7;
    s16 phi_s0_8;
    ? **phi_s1_8;
    s32 phi_s4;
    s16 phi_s3;
    s32 phi_s5;
    s32 phi_s0_9;
    s16 phi_s6;
    s16 phi_s2_3;
    void *phi_v1;
    s32 phi_s1_9;
    ? **phi_s0_10;
    s16 phi_s3_2;
    s32 phi_s0_11;
    s16 phi_s6_2;
    s16 phi_s2_4;
    void *phi_v1_2;
    s32 phi_s2_5;
    s16 phi_s1_10;
    ? **phi_s3_3;
    s16 phi_s3_4;
    s32 phi_s0_12;
    s16 phi_s6_3;
    s16 phi_s2_6;
    void *phi_v1_3;
    s8 phi_v1_4;
    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x140, 0xF0, 0, 0, 0, 0x64);
    temp_v1 = D_8018EDEC;
    phi_v1_4 = temp_v1;
    switch (temp_v1) {                              /* switch 1 */
    case 0x15:                                      /* switch 1 */
    case 0x16:                                      /* switch 1 */
    case 0x17:                                      /* switch 1 */
    case 0x18:                                      /* switch 1 */
        phi_a0 = temp_v1 - 0x15;
        phi_s2 = 0;
        phi_s0 = 0x55;
        phi_s1 = D_800E7868;
        do {
            func_80092224(phi_a0, phi_s2, TEXT_YELLOW);
            func_80093324(0x32, phi_s0, *phi_s1, 0, 0.9f, 1.0f);
            temp_a0 = D_8018EDEC - 0x15;
            phi_a0 = temp_a0;
            phi_s1 += 4;
            if (phi_s2 == temp_a0) {
                spE0 = 0x32;
                spE2 = phi_s0;
            }
            temp_s2 = phi_s2 + 1;
            phi_s2 = temp_s2;
            phi_s0 += 0x23;
        } while (temp_s2 != 4);
        set_text_color(TEXT_GREEN);
        draw_text(0xE6, 0x78, gSoundModeNames[gSoundMode], 0, 1.0f, 1.0f);
block_98:
        phi_v1_4 = D_8018EDEC;
        break;
    case 0x1E:                                      /* switch 1 */
    case 0x1F:                                      /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_s0_2 = 0x55;
        phi_s1_2 = D_800E7878;
        do {
            func_80093324(0x28, phi_s0_2, *phi_s1_2, 0, 1.0f, 1.0f);
            temp_s1 = phi_s1_2 + 4;
            phi_s0_2 += 0x14;
            phi_s1_2 = temp_s1;
        } while (temp_s1 < D_800E7884);
        phi_a0_2 = D_8018EDEC - 0x1E;
        phi_s2_2 = 0;
        phi_s0_3 = 0x96;
        phi_s1_3 = D_800E7840;
        do {
            func_80092224(phi_a0_2, phi_s2_2, TEXT_GREEN);
            func_80093324(0x84, phi_s0_3, *phi_s1_3, 0, 1.0f, 1.0f);
            temp_v1_2 = D_8018EDEC;
            temp_a0_2 = temp_v1_2 - 0x1E;
            phi_a0_2 = temp_a0_2;
            phi_s1_3 += 4;
            phi_v1_4 = temp_v1_2;
            if (phi_s2_2 == temp_a0_2) {
                spE0 = 0x84;
                spE2 = phi_s0_3;
            }
            temp_s2_2 = phi_s2_2 + 1;
            phi_s2_2 = temp_s2_2;
            phi_s0_3 += 0x19;
        } while (temp_s2_2 != 2);
        break;
    case 0x20:                                      /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_s0_4 = 0x55;
        phi_s1_4 = D_800E7884;
        do {
            func_80093324(0x32, phi_s0_4, *phi_s1_4, 0, 1.0f, 1.0f);
            temp_s1_2 = phi_s1_4 + 4;
            phi_s0_4 += 0x14;
            phi_s1_4 = temp_s1_2;
        } while (temp_s1_2 != &D_800E7890);
        goto block_98;
    case 0x2A:                                      /* switch 1 */
    case 0x2B:                                      /* switch 1 */
    case 0x2C:                                      /* switch 1 */
    case 0x2D:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s0_5 = 0x55;
        phi_s1_5 = ((D_8018EDEC - 0x2A) * 0xC) + &D_800E78D0;
        do {
            func_80093324(0x32, phi_s0_5, *phi_s1_5, 0, 0.9f, 0.9f);
            temp_s0 = phi_s0_5 + 0x14;
            phi_s0_5 = temp_s0;
            phi_s1_5 += 4;
        } while (temp_s0 != 0x91);
        goto block_98;
    case 0x34:                                      /* switch 1 */
    case 0x35:                                      /* switch 1 */
    case 0x36:                                      /* switch 1 */
    case 0x37:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s0_6 = 0x55;
        phi_s1_6 = ((D_8018EDEC - 0x34) * 0x10) + &D_800E7890;
        do {
            func_80093324(0x23, phi_s0_6, *phi_s1_6, 0, 0.8f, 0.8f);
            temp_s0_2 = phi_s0_6 + 0x14;
            phi_s0_6 = temp_s0_2;
            phi_s1_6 += 4;
        } while (temp_s0_2 != 0xA5);
        goto block_98;
    case 0x41:                                      /* switch 1 */
    case 0x42:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s0_7 = 0x55;
        phi_s1_7 = ((D_8018EDEC - 0x41) * 0xC) + &D_800E7900;
        do {
            func_80093324(0x41, phi_s0_7, *phi_s1_7, 0, 0.9f, 0.9f);
            temp_s0_3 = phi_s0_7 + 0x14;
            phi_s0_7 = temp_s0_3;
            phi_s1_7 += 4;
        } while (temp_s0_3 != 0x91);
        goto block_98;
    case 0x46:                                      /* switch 1 */
    case 0x47:                                      /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_s0_8 = 0x55;
        phi_s1_8 = D_800E7A48;
        do {
            func_80093324(0x50, phi_s0_8, *phi_s1_8, 0, 1.0f, 1.0f);
            temp_s1_3 = phi_s1_8 + 4;
            phi_s0_8 += 0x14;
            phi_s1_8 = temp_s1_3;
        } while (temp_s1_3 != &D_800E7A54);
        goto block_98;
    case 0x28:                                      /* switch 1 */
    case 0x29:                                      /* switch 1 */
    case 0x32:                                      /* switch 1 */
    case 0x33:                                      /* switch 1 */
        phi_s5 = 0x28;
        if ((temp_v1 != 0x28) && (temp_v1 != 0x29)) {
            phi_s5 = 0x32;
            if ((temp_v1 != 0x32) && (phi_s4 = spC0, (temp_v1 != 0x33))) {
                phi_s5 = spC4;
            } else {
                phi_s4 = 1;
            }
        } else {
            phi_s4 = 0;
        }
        set_text_color(phi_s4 + 1);
        draw_text(0xA0, 0x55, *(&D_800E7920 + (phi_s4 * 4)), 0, 0.6f, 0.6f);
        sp88 = 0x5C;
        sp78 = (phi_s4 * 0x89) + 0x2A;
        sp84 = D_800E7918;
        phi_s3 = 0x2A;
        phi_s6 = 0x20;
        do {
            set_text_color(TEXT_YELLOW);
            draw_text(sp88, 0x7D, *sp84, 0, 0.75f, 0.75f);
            phi_s0_9 = 0;
            phi_s2_3 = 0x96;
loop_38:
            if (phi_s3 != sp78) {
                func_800921C0(D_8018EDEC - phi_s5, phi_s0_9, TEXT_GREEN);
                if (phi_s0_9 == (D_8018EDEC - phi_s5)) {
                    spE0 = phi_s6;
                    spE2 = phi_s2_3;
                }
            } else if ((phi_s4 != 0) && (phi_s0_9 == arg0->unk20)) {
                set_text_color(gGlobalTimer % 3);
            } else {
                set_text_color(TEXT_GREEN);
            }
            temp_s1_4 = phi_s0_9 + 1;
            convert_number_to_ascii(temp_s1_4, &spB8);
            func_80093324(phi_s6, phi_s2_3, &spB9, 0, 0.6f, 0.6f);
            if (phi_s3 == 0x2A) {
                phi_v1 = (phi_s0_9 << 7) + &D_8018EE10;
            } else {
                phi_v1 = D_8018D9C0 + (phi_s0_9 << 7);
            }
            if (phi_v1->unk4 == 0) {
                func_80093324(phi_s3, phi_s2_3, D_800E7A44, 0, 0.5f, 0.5f);
            } else {
                temp_v0 = phi_v1->unk5;
                func_80093324(phi_s3, phi_s2_3, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0 / 4) * 8) + ((temp_v0 % 4) * 2))) * 4)), 0, 0.5f, 0.5f);
            }
            phi_s0_9 = temp_s1_4;
            phi_s2_3 += 0x1E;
            if (temp_s1_4 != 2) {
                goto loop_38;
            }
            temp_s3 = phi_s3 + 0x89;
            sp84 += 4;
            sp88 += 0x82;
            phi_s3 = temp_s3;
            phi_s6 += 0x89;
        } while (temp_s3 != 0x13C);
        goto block_98;
    case 0x38:                                      /* switch 1 */
    case 0x39:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s1_9 = 0x4D;
        phi_s0_10 = D_800E7928;
        do {
            draw_text(0xA0, phi_s1_9, *phi_s0_10, 0, 0.8f, 0.8f);
            temp_s0_4 = phi_s0_10 + 4;
            phi_s1_9 += 0x14;
            phi_s0_10 = temp_s0_4;
        } while (temp_s0_4 < D_800E7930);
        sp88 = 0x5C;
        sp84 = D_800E7918;
        phi_s3_2 = 0x2A;
        phi_s6_2 = 0x20;
        do {
            set_text_color(TEXT_YELLOW);
            draw_text(sp88, 0x7D, *sp84, 0, 0.75f, 0.75f);
            phi_s0_11 = 0;
            phi_s2_4 = 0x96;
loop_58:
            if (phi_s3_2 == 0x2A) {
                if (phi_s0_11 == arg0->unk1C) {
                    set_text_color(gGlobalTimer % 3);
                } else {
                    set_text_color(TEXT_GREEN);
                }
            } else if (phi_s0_11 == arg0->unk20) {
                set_text_color(gGlobalTimer % 3);
            } else {
                set_text_color(TEXT_GREEN);
            }
            temp_s1_5 = phi_s0_11 + 1;
            convert_number_to_ascii(temp_s1_5, &spA8);
            func_80093324(phi_s6_2, phi_s2_4, &spA9, 0, 0.6f, 0.6f);
            if (phi_s3_2 == 0x2A) {
                phi_v1_2 = (phi_s0_11 << 7) + &D_8018EE10;
            } else {
                phi_v1_2 = D_8018D9C0 + (phi_s0_11 << 7);
            }
            if (phi_v1_2->unk4 == 0) {
                func_80093324(phi_s3_2, phi_s2_4, D_800E7A44, 0, 0.5f, 0.5f);
            } else {
                temp_v0_2 = phi_v1_2->unk5;
                func_80093324(phi_s3_2, phi_s2_4, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_2 / 4) * 8) + ((temp_v0_2 % 4) * 2))) * 4)), 0, 0.5f, 0.5f);
            }
            phi_s0_11 = temp_s1_5;
            phi_s2_4 += 0x1E;
            if (temp_s1_5 != 2) {
                goto loop_58;
            }
            temp_s3_2 = phi_s3_2 + 0x89;
            sp84 += 4;
            sp88 += 0x82;
            phi_s3_2 = temp_s3_2;
            phi_s6_2 += 0x89;
        } while (temp_s3_2 < 0x13C);
        phi_s2_5 = 0;
        phi_s1_10 = 0x6E;
        phi_s3_3 = D_800E7930;
        do {
            temp_a0_3 = D_8018EDEC - 0x38;
            if (phi_s2_5 == temp_a0_3) {
                spE0 = phi_s1_10;
                spE2 = 0xD2;
            }
            func_800921C0(temp_a0_3, temp_s1_5, TEXT_YELLOW);
            func_80093324(phi_s1_10, 0xD2, *phi_s3_3, 0, 0.75f, 0.75f);
            temp_s2_3 = phi_s2_5 + 1;
            phi_s2_5 = temp_s2_3;
            phi_s1_10 += 0x32;
            phi_s3_3 += 4;
        } while (temp_s2_3 != 2);
        goto block_98;
    case 0x3A:                                      /* switch 1 */
    case 0x3B:                                      /* switch 1 */
    case 0x3C:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        temp_v0_3 = (((temp_v1 - 0x3A) / 2) * 4) + &D_800E7938;
        sp78 = temp_v0_3;
        draw_text(0xA0, 0x55, *temp_v0_3, 0, 1.0f, 1.0f);
        sp88 = 0x5C;
        sp84 = D_800E7918;
        phi_s3_4 = 0x2A;
        phi_s6_3 = 0x20;
        do {
            set_text_color(TEXT_YELLOW);
            draw_text(sp88, 0x7D, *sp84, 0, 0.75f, 0.75f);
            phi_s0_12 = 0;
            phi_s2_6 = 0x96;
loop_80:
            if (phi_s3_4 == 0x2A) {
                if (phi_s0_12 == arg0->unk1C) {
                    if (sp78 == &D_800E7938) {
                        set_text_color(TEXT_RED);
                    } else {
                        set_text_color(gGlobalTimer % 3);
                    }
                } else {
                    set_text_color(TEXT_GREEN);
                }
            } else if (phi_s0_12 == arg0->unk20) {
                set_text_color(TEXT_RED);
            } else {
                set_text_color(TEXT_GREEN);
            }
            temp_s1_6 = phi_s0_12 + 1;
            convert_number_to_ascii(temp_s1_6, &sp98);
            func_80093324(phi_s6_3, phi_s2_6, &sp99, 0, 0.6f, 0.6f);
            if (phi_s3_4 == 0x2A) {
                phi_v1_3 = (phi_s0_12 << 7) + &D_8018EE10;
            } else {
                phi_v1_3 = D_8018D9C0 + (phi_s0_12 << 7);
            }
            if (phi_v1_3->unk4 == 0) {
                func_80093324(phi_s3_4, phi_s2_6, D_800E7A44, 0, 0.5f, 0.5f);
            } else {
                temp_v0_4 = phi_v1_3->unk5;
                func_80093324(phi_s3_4, phi_s2_6, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_4 / 4) * 8) + ((temp_v0_4 % 4) * 2))) * 4)), 0, 0.5f, 0.5f);
            }
            phi_s0_12 = temp_s1_6;
            phi_s2_6 += 0x1E;
            if (temp_s1_6 != 2) {
                goto loop_80;
            }
            temp_s3_3 = phi_s3_4 + 0x89;
            sp84 += 4;
            sp88 += 0x82;
            phi_s3_4 = temp_s3_3;
            phi_s6_3 += 0x89;
        } while (temp_s3_3 != 0x13C);
        goto block_98;
    }
    switch (phi_v1_4) {                             /* switch 2 */
    case 0x28:                                      /* switch 2 */
    case 0x29:                                      /* switch 2 */
    case 0x32:                                      /* switch 2 */
    case 0x33:                                      /* switch 2 */
    case 0x38:                                      /* switch 2 */
    case 0x39:                                      /* switch 2 */
        spE0 += -5;
        spE2 += -6;
        break;
    default:                                        /* switch 2 */
        spE0 += -0xA;
        spE2 += -8;
        break;
    }
    func_800A66A8(arg0, &spE0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1FB0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80098FC8(s32, ?, s32, ?, s32); // extern
extern s8 D_8018EE08;
extern s32 gDisplayListHead;

void func_800A2D1C(void *arg0) {
    s32 temp_t0;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;

    temp_v0 = D_80164A28;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
                goto block_13;
            }
            temp_t8 = arg0->unk1C - 2;
            arg0->unk1C = temp_t8;
            if (temp_t8 > 0) {
                temp_v0_2 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, temp_t8);
                gDisplayListHead = temp_v0_2;
                gDisplayListHead = func_80098FC8(temp_v0_2, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
                return;
            }
            goto block_13;
        }
        temp_t0 = arg0->unk1C - 2;
        arg0->unk1C = temp_t0;
        if (temp_t0 > 0) {
            temp_v0_3 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, temp_t0);
            gDisplayListHead = temp_v0_3;
            gDisplayListHead = func_80098FC8(temp_v0_3, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
            return;
        }
block_13:
        arg0->unk0 = 0;
        return;
    }
    temp_v0_4 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, 0x28);
    gDisplayListHead = temp_v0_4;
    gDisplayListHead = func_80098FC8(temp_v0_4, 0, 0xC7, 0x13F, 0xEF);
    arg0->unk1C = 0x28;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A2D1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
s32 get_string_width(s32); // extern
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800A32B4(s32, s32, s8, s32); // extern
? convert_number_to_ascii(s32, ? *); // extern
? set_text_color(s32); // extern
extern s32 D_800DC540;
extern ? D_800E7500;
extern ? D_800E76CC;
extern ? gGameModeRowSelectionForNumPlayers;
extern ? gGameModeSubMenuRowSelectionForNumPlayers;
extern ? D_800F0C1C;
extern ? D_800F0C24;
extern f32 D_800F1C90;
extern f32 D_800F1C94;
extern f32 D_800F1C98;
extern f32 D_800F1C9C;
extern f32 D_800F1CA0;
extern s16 D_80164360;
extern s16 D_80164368;
extern ? D_80164370;
extern s8 gCupSelection;
extern s32 gGlobalTimer;
extern ? gPlayers;

void func_800A2EB8(void *arg0) {
    s8 sp74;
    s8 sp70;
    ? sp69;
    ? sp68;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    s16 *temp_s0;
    s32 temp_s0_2;
    s32 temp_s2;
    s32 temp_s2_2;
    s8 *temp_s1;
    s8 temp_v0;
    s16 *phi_s0;
    s8 *phi_s1;
    s16 *phi_s0_2;
    s32 phi_a0;
    s32 phi_s3;
    s8 *phi_s1_2;
    s32 phi_s2;
    s16 *phi_s0_3;
    s32 phi_a0_2;
    s32 phi_s3_2;
    s8 *phi_s1_3;
    s32 phi_s2_2;

    phi_s0 = &D_80164360;
    phi_s1 = &sp70;
    do {
        temp_s0 = phi_s0 + 2;
        temp_s1 = phi_s1 + 1;
        temp_s1->unk-1 = (&gPlayers + (*phi_s0 * 0xDD8))->unk254;
        phi_s0 = temp_s0;
        phi_s1 = temp_s1;
    } while (temp_s0 < &D_80164370);
    // "Results"
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    func_80093324(arg0->unkC + 0x1E, arg0->unk10 + 0x19, &D_800F0C1C, 0, 1.0f, 1.0f);
    // "Round"
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
    temp_f0 = D_800F1C90;
    func_80093324(arg0->unkC + 0x2C, arg0->unk10 + 0x28, &D_800F0C24, 0, temp_f0, temp_f0);
    // Convert index of current course in the cup order into a round number
    convert_number_to_ascii(gCupCourseSelection + 1, &sp68);
    // Print previously converted round number
    temp_f0_2 = D_800F1C94;
    func_80093324(arg0->unkC + 0x57, arg0->unk10 + 0x28, &sp69, 0, temp_f0_2, temp_f0_2);
    phi_s0_2 = &D_80164360;
    phi_s3 = 0;
    phi_s1_2 = &sp70;
    phi_s2 = 0;
    // Print rank 1, 2, 3 and 4  3-lap times
    do {
        if (*phi_s0_2 < D_8018EDF3) {
            phi_a0 = gGlobalTimer % 3;
        } else {
            phi_a0 = TEXT_YELLOW;
        }
        set_text_color(phi_a0);
        func_800A32B4(arg0->unkC + 7, arg0->unk10 + phi_s3 + 0x38, *phi_s1_2, phi_s2);
        temp_s2 = phi_s2 + 1;
        phi_s0_2 += 2;
        phi_s3 += 0x10;
        phi_s1_2 += 1;
        phi_s2 = temp_s2;
    } while (temp_s2 < 4);
    phi_s0_3 = &D_80164368;
    phi_s3_2 = 0x40;
    phi_s1_3 = &sp74;
    phi_s2_2 = 4;
    // Print rank 5, 6, 7 and 8  3-lap times
    do {
        if (*phi_s0_3 < D_8018EDF3) {
            phi_a0_2 = gGlobalTimer % 3;
        } else {
            phi_a0_2 = TEXT_YELLOW;
        }
        set_text_color(phi_a0_2);
        func_800A32B4(0xBE - arg0->unkC, arg0->unk10 + phi_s3_2 + 0x5A, *phi_s1_3, phi_s2_2);
        temp_s2_2 = phi_s2_2 + 1;
        phi_s0_3 += 2;
        phi_s3_2 += 0x10;
        phi_s1_3 += 1;
        phi_s2_2 = temp_s2_2;
    } while (temp_s2_2 != 8);
    // Print Cup name
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
    temp_s0_2 = ((get_string_width(*(&D_800E7500 + (gCupSelection * 4))) + 8) * D_800F1C98) / 2.0f;
    temp_f0_3 = D_800F1C9C;
    // Some very complicated way to print the cup name and CC mode
    draw_text((-(((get_string_width(*(&D_800E76CC + (gCCSelection * 4))) + 8) * temp_f0_3) / 2.0f) - arg0->unkC) + 0xF5, arg0->unk10 + 0xE1, *(&D_800E7500 + (D_800DC540 * 4)), 0, temp_f0_3, temp_f0_3);
    temp_v0 = D_8018EDF3;
    temp_f0_4 = D_800F1CA0;
    // Print CC mode again?
    draw_text((temp_s0_2 - arg0->unkC) + 0xF5, arg0->unk10 + 0xE1, *(&D_800E76CC + (*(&gGameModeSubMenuRowSelectionForNumPlayers + ((temp_v0 * 3) + *(&gGameModeRowSelectionForNumPlayers + temp_v0))) * 4)), 0, temp_f0_4, temp_f0_4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A2EB8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, ?, ? *, ?, f32, f32); // extern
? func_800939C8(s32, ?, ? *, ?, f32, f32); // extern
? convert_number_to_ascii(s32, ? *); // extern
extern ? D_800E76A8;
extern ? D_800F0C2C;
extern ? D_800F0C30;
extern f32 D_800F1CA4;
extern f32 D_800F1CA8;
extern ? gTimePlayerLastTouchedFinishLine;
extern ? D_80164360;

void func_800A32B4(s32 arg0, ? arg1, s32 arg2, s32 arg3) {
    f32 sp50;
    s8 sp3F;
    s8 sp3E;
    ? sp3D;
    ? sp3C;
    f32 temp_f20;
    f32 temp_f4;

    temp_f4 = *(&gTimePlayerLastTouchedFinishLine + (*(&D_80164360 + (arg3 * 2)) * 4));
    sp50 = temp_f4;
    // Convert arg3 (some index) into a rank string
    // This is a little wonky.
    // sp3c becomes "0x30, rank#, \0"
    convert_number_to_ascii(arg3 + 1, &sp3C);
    temp_f20 = D_800F1CA4;
    // change the \0 to a "."
    sp3E = 0x2E;
    // add a new termnitator
    sp3F = 0;
    // Print rank string
    func_800939C8(arg0 - 1, arg1, &sp3D, -4, temp_f20, temp_f20);
    // Print character name (arg2 is almost certainly characterId)
    func_80093324(arg0 + 0xA, arg1, *(&D_800E76A8 + (arg2 * 4)), 0, D_800F1CA8, temp_f20);
    // Get minutes
    convert_number_to_ascii(sp50 / 60.0f, &sp3C);
    // Print minutes
    func_800939C8(arg0 + 0x42, arg1, &sp3C, 0, temp_f20, temp_f20);
    // Get seconds
    convert_number_to_ascii(temp_f4 % 0x3C, &sp3C);
    // Print '
    func_80093324(arg0 + 0x4E, arg1, &D_800F0C2C, 0, temp_f20, temp_f20);
    // Print seconds
    func_800939C8(arg0 + 0x56, arg1, &sp3C, 0, temp_f20, temp_f20);
    // Get centiseconds
    convert_number_to_ascii((sp50 * 100.0) % 0x64, &sp3C);
    // Print "
    func_80093324(arg0 + 0x62, arg1, &D_800F0C30, 0, temp_f20, temp_f20);
    // Print centiseconds
    func_800939C8(arg0 + 0x6A, arg1, &sp3C, 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A32B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? draw_text(s32, s32, s32, ?, f32, f32);            /* extern */
s32 get_string_width(s32);                             /* extern */
? func_80093324(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_800A3A10(s8 *);                              /* extern */
? func_800A3ADC(void *, s32, s32, s8, s32, s8 *);   /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? set_text_color(s32);                              /* extern */
extern s32 D_800DC540;
extern ? D_80164360;
extern ? D_80164370;
extern ? D_80164478;
extern s8 D_8018EDF3;
static ? D_800E7500;                                /* unable to generate initializer; const */
static ? D_800E76CC;                                /* unable to generate initializer; const */
static ? gGameModeRowSelectionForNumPlayers;                                /* unable to generate initializer; const */
static ? gGameModeSubMenuRowSelectionForNumPlayers;                                /* unable to generate initializer; const */

void func_800A34A8(void *arg0) {
    s8 sp80;
    ? sp79;
    ? sp78;
    s32 sp68;
    ? *temp_a0;
    s32 temp_s0_2;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s8 *temp_s0;
    s8 temp_v0;
    ? *phi_a0;
    s8 *phi_s0;
    s32 phi_s1;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v1;
    s32 phi_a0_2;
    s32 phi_s1_2;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_a0_3;

    temp_v1 = arg0->unk4;
    if (temp_v1 != 0) {
        if (temp_v1 < 9) {
            phi_a0 = &D_80164360;
            phi_s0 = &sp80;
            do {
                temp_a0 = phi_a0 + 8;
                temp_s0 = phi_s0 + 4;
                temp_s0->unk-4 = gPlayers[phi_a0->unk0].characterId;
                temp_s0->unk-3 = gPlayers[phi_a0->unk2].characterId;
                temp_s0->unk-2 = gPlayers[phi_a0->unk4].characterId;
                temp_s0->unk-1 = gPlayers[temp_a0->unk-2].characterId;
                phi_a0 = temp_a0;
                phi_s0 = temp_s0;
            } while (temp_a0 != &D_80164370);
        } else {
            func_800A3A10(&sp80);
            func_800A3A10(gCharacterIdByGPOverallRank);
        }
        // "Driver's Points"
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
        func_80093324(arg0->unkC + 0x19, 0x19 - arg0->unk10, "driver's points", 0, 0.8f, 0.8f);
        // "Round"
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        func_80093324(arg0->unkC + 0x36, 0x28 - arg0->unk10, "round", 0, 0.7f, 0.7f);
        // Convert course index to a round number
        convert_number_to_ascii(gCupCourseSelection + 1, &sp78);
        // Print round number
        func_80093324(arg0->unkC + 0x61, 0x28 - arg0->unk10, &sp79, 0, 0.7f, 0.7f);
        phi_s1 = 0;
        // Print rank 1, 2, 3 and 4 lines
        do {
            temp_v1_2 = arg0->unk4;
            if ((temp_v1_2 != 8) && (temp_v1_2 != 9)) {
                phi_v0 = 0;
            } else {
                phi_v0 = 0;
                if ((phi_s1 * 5) < arg0->unk1C) {
                    phi_v0 = 1;
                }
            }
            if (phi_v0 == 0) {
                if (temp_v1_2 < 9) {
                    phi_v0_2 = *(&D_80164360 + (phi_s1 * 2));
                    phi_v1 = 0;
                } else {
                    phi_v0_2 = *(&D_80164478 + ((&sp80)[phi_s1] * 2));
                    phi_v1 = 0xD;
                }
                if (phi_v0_2 < D_8018EDF3) {
                    phi_a0_2 = gGlobalTimer % 3;
                } else {
                    phi_a0_2 = TEXT_YELLOW;
                }
                sp68 = phi_v1;
                set_text_color(phi_a0_2);
                func_800A3ADC(arg0, arg0->unkC + phi_v1 + 0x1C, ((phi_s1 * 0x10) - arg0->unk10) + 0x38, (&sp80)[phi_s1], phi_s1, &sp80);
            }
            temp_s1 = phi_s1 + 1;
            phi_s1 = temp_s1;
        } while (temp_s1 < 4);
        phi_s1_2 = 4;
        // Print rank 5, 6, 7 and 8 lines
        do {
            temp_v1_3 = arg0->unk4;
            if ((temp_v1_3 != 8) && (temp_v1_3 != 9)) {
                phi_v0_3 = 0;
            } else {
                phi_v0_3 = 0;
                if ((phi_s1_2 * 5) < arg0->unk1C) {
                    phi_v0_3 = 1;
                }
            }
            if (phi_v0_3 == 0) {
                if (temp_v1_3 < 9) {
                    phi_v0_4 = *(&D_80164360 + (phi_s1_2 * 2));
                } else {
                    phi_v0_4 = *(&D_80164478 + ((&sp80)[phi_s1_2] * 2));
                }
                if (phi_v0_4 < D_8018EDF3) {
                    phi_a0_3 = gGlobalTimer % 3;
                } else {
                    phi_a0_3 = TEXT_YELLOW;
                }
                set_text_color(phi_a0_3);
                func_800A3ADC(arg0, 0xBE - arg0->unkC, arg0->unk10 + (phi_s1_2 * 0x10) + 0x5A, (&sp80)[phi_s1_2], phi_s1_2, &sp80);
            }
            temp_s1_2 = phi_s1_2 + 1;
            phi_s1_2 = temp_s1_2;
        } while (temp_s1_2 != 8);
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        temp_s0_2 = ((get_string_width(*(&D_800E7500 + (gCupSelection * 4))) + 8) * 0.6f) / 2.0f;
        draw_text((-(((get_string_width(*(&D_800E76CC + (gCCSelection * 4))) + 8) * 0.6f) / 2.0f) - arg0->unkC) + 0xE6, arg0->unk10 + 0xE1, *(&D_800E7500 + (D_800DC540 * 4)), 0, 0.6f, 0.6f);
        temp_v0 = D_8018EDF3;
        draw_text((temp_s0_2 - arg0->unkC) + 0xE6, arg0->unk10 + 0xE1, *(&D_800E76CC + (*(&gGameModeSubMenuRowSelectionForNumPlayers + ((temp_v0 * 3) + *(&gGameModeRowSelectionForNumPlayers + temp_v0))) * 4)), 0, 0.6f, 0.6f);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A34A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
extern ? D_80164478;
extern s8 D_8018EDF3;

void func_800A3A10(s8 *arg0) {
    s16 temp_t0_2;
    s8 temp_a1;
    s8 temp_a3;
    s8 temp_t0;
    s8 temp_t1;
    s8 temp_t2;
    s8 temp_v0;
    s8 phi_v0;
    s8 *phi_v1;
    s8 *phi_a2;
    s8 phi_a1;

    phi_v0 = 0;
    phi_v1 = arg0;
    do {
        *phi_v1 = phi_v0;
        phi_a1 = phi_v0;
        if (phi_v0 > 0) {
            phi_a2 = &arg0[phi_v0];
loop_3:
            temp_a3 = phi_a2->unk-1;
            temp_t1 = phi_a2->unk0;
            temp_a1 = phi_a1 - 1;
            temp_t2 = gGPPointsByCharacterId[temp_t1];
            temp_t0 = gGPPointsByCharacterId[temp_a3];
            phi_a1 = temp_a1;
            if (temp_t0 < temp_t2) {
                phi_a2->unk0 = temp_a3;
                goto block_9;
            }
            if (temp_t2 == temp_t0) {
                temp_t0_2 = *(&D_80164478 + (temp_t1 * 2));
                if ((temp_t0_2 < D_8018EDF3) && (temp_t0_2 < *(&D_80164478 + (temp_a3 * 2)))) {
                    phi_a2->unk0 = temp_a3;
block_9:
                    phi_a2->unk-1 = temp_t1;
                    phi_a2 += -1;
                    if (temp_a1 != 0) {
                        goto loop_3;
                    }
                }
            }
        }
        temp_v0 = phi_v0 + 1;
        phi_v0 = temp_v0;
        phi_v1 += 1;
    } while (temp_v0 != 8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3A10.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80093324(s32, s32, s8 *, ?, f32, f32);       /* extern */
? func_800939C8(s32, s32, s8 *, ?, f32, f32);       /* extern */
? convert_number_to_ascii(s8, s8 *);                          /* extern */
extern s32 D_8018D9BC;
static ? D_800E76A8;                                /* unable to generate initializer; const */

void func_800A3ADC(void *arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s8 sp37;
    s8 sp36;
    s8 sp35;
    s8 sp34;
    s32 temp_v1;
    void *phi_v0;
    s32 phi_v1;
    s32 phi_v1_2;

    if (arg0->unk4 < 9) {
        convert_number_to_ascii(arg4 + 1, &sp34);
    } else {
        phi_v1 = arg4;
        phi_v1_2 = arg4;
        if (arg4 > 0) {
            phi_v0 = arg5 + arg4;
loop_4:
            phi_v1_2 = phi_v1;
            if (gGPPointsByCharacterId[phi_v0->unk0] == gGPPointsByCharacterId[phi_v0->unk-1]) {
                temp_v1 = phi_v1 - 1;
                phi_v0 += -1;
                phi_v1 = temp_v1;
                phi_v1_2 = temp_v1;
                if (temp_v1 != 0) {
                    goto loop_4;
                }
            }
        }
        convert_number_to_ascii(phi_v1_2 + 1, &sp34);
    }
    sp36 = 0x2E;
    sp37 = 0;
    // Print rank # + "."
    func_800939C8(arg1, arg2, &sp35, -4, 0.7f, 0.7f);
    // Print character name
    func_80093324(arg1 + 0xA, arg2, *(&D_800E76A8 + (arg3 * 4)), 0, 0.7f, 0.7f);
    // Print character's current point count
    convert_number_to_ascii(gGPPointsByCharacterId[arg3], &sp34);
    func_800939C8(arg1 + 0x47, arg2, &sp34, 0, 0.7f, 0.7f);
    // Print "+" + points left to be allocated
    // Only done for rank 1, 2, 3 and 4
    // arg4 is almost certainly rank
    if ((arg4 < 4) && (arg0->unk4 < 9)) {
        convert_number_to_ascii(*(D_8018D9BC + arg4), &sp34);
        sp34 = 0x2B;
        func_80093324(arg1 + 0x5A, arg2, &sp34, 0, 0.7f, 0.7f);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3ADC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
? func_80093324(s32, s32, s32, ?, f32, f32); // extern
? func_800A4550(s32, s32, s32); // extern
? func_800A474C(s32, s32, s32); // extern
? set_text_color(?); // extern
extern ? D_800E7574;
extern s32 D_800E7728;
extern s32 D_800E772C;
extern s32 D_800E7730;
extern f32 D_800F1CC8;
extern s8 gCupSelection;
extern ? gCupCourseOrder;

void func_800A3C84(void *arg0) {
    f32 temp_f0;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s0_2;
    s32 phi_s1_2;

    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    temp_f0 = D_800F1CC8;
    draw_text(arg0->unkC + 0x43, arg0->unk10 + 0x19, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, temp_f0, temp_f0);
    set_text_color(TEXT_YELLOW);
    draw_text(arg0->unkC + 0x46, arg0->unk10 + 0x28, D_800E7730, 0, 0.75f, 0.75f);
    phi_s0 = 0;
    phi_s1 = 0;
    phi_s0_2 = 0;
    phi_s1_2 = 0;
    do {
        func_800A4550(phi_s0, arg0->unkC + 0x17, arg0->unk10 + phi_s1 + 0x37);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
        phi_s1 += 0xF;
    } while (temp_s0 < 4);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xB4 - arg0->unkC, arg0->unk10 + 0x86, D_800E7728, 0, 0.75f, 0.75f);
    do {
        set_text_color(TEXT_RED);
        func_800A474C(phi_s0_2, 0xAA - arg0->unkC, arg0->unk10 + phi_s1_2 + 0x92);
        temp_s0_2 = phi_s0_2 + 1;
        phi_s0_2 = temp_s0_2;
        phi_s1_2 += 0xD;
    } while (temp_s0_2 != 5);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xB4 - arg0->unkC, arg0->unk10 + 0xD5, D_800E772C, 0, 0.75f, 0.75f);
    func_800A474C(5, 0xAA - arg0->unkC, arg0->unk10 + 0xE1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3C84.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? draw_text(s32, s32, ? *, ?, f32, f32);            /* extern */
? func_800921C0(s32, s32, ?);                       /* extern */
? func_80093324(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_80093358(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_800A4550(s32, s32, s32);                     /* extern */
? func_800A66A8(void *, s16 *);                     /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? set_text_color(?);                                /* extern */
extern ? D_8018EE10;
static ? D_800E7390;                                /* unable to generate initializer; const */
static ? D_800E73C0;                                /* unable to generate initializer; const */
static ? D_800E73D0;                                /* unable to generate initializer; const */
static ? D_800E7574;                                /* unable to generate initializer; const */
static ? D_800E75C4;                                /* unable to generate initializer; const */
static ? *D_800E7730 = "LAP TIME";                  /* const */
static ? D_800E775C;                                /* unable to generate initializer; const */
static ? D_800E798C;                                /* unable to generate initializer; const */
static ? *D_800E7A3C[2] = { "SELECT THE FILE ", "YOU WANT TO SAVE" }; /* const */
static ? *D_800E7A44 = "NO DATA";                   /* const */
static ? *D_800E7A48[3] = { "CREATING ", "MARIO KART 64 ", "GAME DATA" }; /* const */
static ? D_800E7A54;                                /* unable to generate initializer; const */
static ? *D_800E7A60[3] = { "THE PREVIOUS DATA ", "WILL BE ERASED, ", "IS THIS OK?" }; /* const */
static ? *D_800E7A6C[2] = { "QUIT", "SAVE" };       /* const */
static ? *D_800E7A74[3] = { "SAVING GHOST DATA", "", "PLEASE WAIT" }; /* const */
static ? *D_800E7A80[2] = { "UNABLE TO SAVE ", "THE GHOST" }; /* const */
static ? D_800E7A88;                                /* unable to generate initializer; const */
static ? gCupCourseOrder;                            /* unable to generate initializer; const */

void func_800A3E60(void *arg0) {
    s16 sp86;
    s16 sp84;
    s32 sp6C;
    ? sp61;
    ? sp60;
    s32 sp54;
    ? **sp50;
    ? **temp_s0_2;
    ? **temp_s0_3;
    ? **temp_v0_3;
    ? **temp_v0_4;
    ? **temp_v0_5;
    Gfx *temp_v1_2;
    s16 *temp_a1;
    s32 temp_a0;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s1_3;
    s32 temp_v0;
    s32 temp_v1;
    s8 temp_v0_2;
    s32 phi_s1;
    s32 phi_s0;
    s32 phi_s1_2;
    s32 phi_v1;
    s32 phi_s2;
    ? *phi_s0_2;
    ? **phi_v0;
    s32 phi_s0_3;
    s32 phi_s2_2;
    ? **phi_s0_4;
    s32 phi_s1_3;
    s32 phi_s0_5;
    ? *phi_s2_3;
    ? **phi_v0_2;
    s32 phi_s0_6;
    s32 phi_s2_4;
    ? **phi_s0_7;
    s32 phi_s1_4;
    s32 phi_s0_8;
    ? **phi_s2_5;
    ? **phi_v0_3;
    s32 phi_s0_9;
    ? **phi_v0_4;
    s32 phi_s0_10;
    void *phi_v0_5;

    temp_v0 = arg0->unk4;
    if ((temp_v0 != 0) && (temp_v0 != 0x1F)) {
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
        draw_text(arg0->unkC + 0x55, 0x19 - arg0->unk10, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 0.6f, 0.6f);
        set_text_color(TEXT_YELLOW);
        draw_text(arg0->unkC + 0x55, 0x28 - arg0->unk10, D_800E7730, 0, 0.75f, 0.75f);
        phi_s1 = 0;
        phi_s0 = 0;
        phi_s1_2 = 0;
        phi_s1_3 = 0;
        phi_s1_4 = 0;
        do {
            func_800A4550(phi_s1, arg0->unkC + 0x26, (phi_s0 - arg0->unk10) + 0x37);
            temp_s1 = phi_s1 + 1;
            phi_s1 = temp_s1;
            phi_s0 += 0xF;
        } while (temp_s1 < 4);
        temp_v1 = arg0->unk4;
        switch (temp_v1) {                          /* switch 1 */
        case 1:                                     /* switch 1 */
        case 5:                                     /* switch 1 */
        case 6:                                     /* switch 1 */
        case 7:                                     /* switch 1 */
        case 8:                                     /* switch 1 */
        case 9:                                     /* switch 1 */
        case 10:                                    /* switch 1 */
        case 30:                                    /* switch 1 */
            phi_s2 = 0;
            phi_s0_2 = &D_800E775C;
            do {
                sp6C = 0;
                func_800921C0(arg0->unk4 - 5, phi_s1_2, TEXT_GREEN);
                phi_v1 = sp6C;
                if (phi_s1_2 != 4) {
                    if (phi_s1_2 != 5) {

                    } else if (D_80162DD4 != 0) {
                        phi_v1 = 2;
                    }
                } else if (D_80162DF8 == 1) {
                    phi_v1 = 1;
                }
                if (phi_v1 != 0) {
                    set_text_color(TEXT_BLUE);
                    temp_v1_2 = gDisplayListHead;
                    gDisplayListHead = temp_v1_2 + 8;
                    temp_v1_2->words.w1 = 0x96;
                    temp_v1_2->words.w0 = 0xFA000000;
                    func_80093358(0xB2 - arg0->unkC, arg0->unk10 + phi_s2 + 0x93, phi_s0_2->unk4, 0, 0.75f, 0.75f);
                } else {
                    func_80093324(0xB2 - arg0->unkC, arg0->unk10 + phi_s2 + 0x93, phi_s0_2->unk4, 0, 0.75f, 0.75f);
                }
                temp_s1_2 = phi_s1_2 + 1;
                phi_s1_2 = temp_s1_2;
                phi_s2 += 0xD;
                phi_s0_2 += 4;
            } while (temp_s1_2 != 6);
block_43:
            break;
        case 11:                                    /* switch 1 */
        case 12:                                    /* switch 1 */
        case 13:                                    /* switch 1 */
        case 14:                                    /* switch 1 */
        case 15:                                    /* switch 1 */
        case 16:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0 = ((arg0->unk4 - 0xB) * 0x1C) + &D_800E798C;
            phi_s0_3 = 0x8C;
            do {
                sp50 = phi_v0;
                func_80093324(0xA2, phi_s0_3, *phi_v0, 0, 0.6f, 0.6f);
                temp_s0 = phi_s0_3 + 0xD;
                phi_v0 += 4;
                phi_s0_3 = temp_s0;
            } while (temp_s0 != 0xE7);
            goto block_43;
        case 17:                                    /* switch 1 */
        case 18:                                    /* switch 1 */
            set_text_color(TEXT_GREEN);
            phi_s2_2 = 0;
            phi_s0_4 = D_800E7A3C;
            do {
                func_80093324(0xA5, arg0->unk10 + phi_s2_2 + 0x8C, *phi_s0_4, 0, 0.7f, 0.7f);
                temp_s0_2 = phi_s0_4 + 4;
                phi_s2_2 += 0xD;
                phi_s0_4 = temp_s0_2;
            } while (temp_s0_2 < &D_800E7A44);
            phi_s0_5 = 0xAA;
            phi_s2_3 = &D_8018EE10;
            do {
                func_800921C0(arg0->unk4 - 0x11, phi_s1_3, TEXT_GREEN);
                temp_a0 = phi_s1_3 + 1;
                sp54 = temp_a0;
                convert_number_to_ascii(temp_a0, &sp60);
                func_80093324(0xB1 - arg0->unkC, phi_s0_5, &sp61, 0, 0.6f, 0.6f);
                if (phi_s2_3->unk4 == 0) {
                    func_80093324(0xBB - arg0->unkC, phi_s0_5, D_800E7A44, 0, 0.45f, 0.45f);
                } else {
                    temp_v0_2 = phi_s2_3->unk5;
                    func_80093324(0xBB - arg0->unkC, phi_s0_5, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_2 / 4) * 8) + ((temp_v0_2 % 4) * 2))) * 4)), 0, 0.45f, 0.45f);
                }
                phi_s1_3 = sp54;
                phi_s0_5 += 0x1E;
                phi_s2_3 += 0x80;
            } while (sp54 != 2);
            goto block_43;
        case 19:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0_2 = D_800E7A48;
            phi_s0_6 = 0x93;
            do {
                sp50 = phi_v0_2;
                func_80093324(0xAA, phi_s0_6, *phi_v0_2, 0, 0.8f, 0.8f);
                temp_v0_3 = phi_v0_2 + 4;
                phi_v0_2 = temp_v0_3;
                phi_s0_6 += 0xD;
            } while (temp_v0_3 != &D_800E7A54);
            goto block_43;
        case 20:                                    /* switch 1 */
        case 21:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_s2_4 = 0;
            phi_s0_7 = D_800E7A60;
            do {
                func_80093324(0xA3, arg0->unk10 + phi_s2_4 + 0x8C, *phi_s0_7, 0, 0.67f, 0.67f);
                temp_s0_3 = phi_s0_7 + 4;
                phi_s2_4 += 0xD;
                phi_s0_7 = temp_s0_3;
            } while (temp_s0_3 < D_800E7A6C);
            phi_s0_8 = 0xB9;
            phi_s2_5 = D_800E7A6C;
            do {
                func_800921C0(arg0->unk4 - 0x14, phi_s1_4, TEXT_GREEN);
                func_80093324(0xC8 - arg0->unkC, phi_s0_8, *phi_s2_5, 0, 0.75f, 0.75f);
                temp_s1_3 = phi_s1_4 + 1;
                phi_s1_4 = temp_s1_3;
                phi_s0_8 += 0xF;
                phi_s2_5 += 4;
            } while (temp_s1_3 != 2);
            goto block_43;
        case 25:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0_3 = D_800E7A74;
            phi_s0_9 = 0x93;
            do {
                sp50 = phi_v0_3;
                func_80093324(0xA3, phi_s0_9, *phi_v0_3, 0, 0.67f, 0.67f);
                temp_v0_4 = phi_v0_3 + 4;
                phi_v0_3 = temp_v0_4;
                phi_s0_9 += 0xD;
            } while (temp_v0_4 != D_800E7A80);
            goto block_43;
        case 26:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0_4 = D_800E7A80;
            phi_s0_10 = 0x93;
            do {
                sp50 = phi_v0_4;
                func_80093324(0xAA, phi_s0_10, *phi_v0_4, 0, 0.75f, 0.75f);
                temp_v0_5 = phi_v0_4 + 4;
                phi_v0_4 = temp_v0_5;
                phi_s0_10 += 0xD;
            } while (temp_v0_5 != &D_800E7A88);
            goto block_43;
        }
        switch (arg0->unk4) {                       /* switch 2 */
        case 5:                                     /* switch 2 */
        case 6:                                     /* switch 2 */
        case 7:                                     /* switch 2 */
        case 8:                                     /* switch 2 */
        case 9:                                     /* switch 2 */
        case 10:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk4 * 8) - 0x28 + &D_800E7390;
block_50:
            temp_a1 = &sp84;
            sp84 = phi_v0_5->unk0 - arg0->unkC;
            sp86 = phi_v0_5->unk2 + arg0->unk10;
            func_800A66A8(arg0, temp_a1);
            break;
        case 17:                                    /* switch 2 */
        case 18:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk4 * 8) - 0x88 + &D_800E73C0;
            goto block_50;
        case 20:                                    /* switch 2 */
        case 21:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk4 * 8) - 0xA0 + &D_800E73D0;
            goto block_50;
        case 30:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk1C * 8) - 0x28 + &D_800E7390;
            goto block_50;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3E60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800936B8(s32, s32, s32, ?, f32, f32); // extern
? func_800939C8(s32, s32, ? *, ?, f32, f32); // extern
? get_time_record_minutes(s32, ? *); // extern
? get_time_record_seconds(s32, ? *); // extern
? get_time_record_centiseconds(s32, ? *); // extern
void *func_800AAEF4(?); // extern
? set_text_color(s32); // extern
extern ? D_800E7734;
extern ? D_800F0C4C;
extern ? D_800F0C50;
extern f32 D_800F1DC4;
extern s32 D_8018CA78;
extern ? D_8018CA90;
extern s32 gGlobalTimer;

void func_800A4550(s32 arg0, s32 arg1, s32 arg2) {
    s32 sp40;
    ? sp34;
    s32 sp2C;
    f32 temp_f20;
    s32 temp_v0;
    void *temp_v0_2;
    s32 phi_v0;
    s32 phi_a0;

    if (arg0 < 3) {
        temp_v0 = arg0 * 4;
        sp2C = temp_v0;
        sp40 = *(&D_8018CA90 + temp_v0);
        set_text_color(TEXT_RED);
        phi_v0 = temp_v0;
    } else {
        sp40 = D_8018CA78;
        set_text_color(TEXT_GREEN);
        phi_v0 = arg0 * 4;
    }
    temp_f20 = D_800F1DC4;
    func_800936B8(arg1 + 0x21, arg2, *(&D_800E7734 + phi_v0), 0, temp_f20, temp_f20);
    temp_v0_2 = func_800AAEF4(0xBB);
    if (arg0 < 3) {
        if ((temp_v0_2->unk20 & (1 << arg0)) != 0) {
            phi_a0 = gGlobalTimer % 3;
        } else {
            phi_a0 = TEXT_YELLOW;
        }
    } else {
        phi_a0 = TEXT_YELLOW;
        // If 3 lap time is in top 5 times
        if (temp_v0_2->unk1C >= 0) {
            phi_a0 = gGlobalTimer % 3;
        }
    }
    set_text_color(phi_a0);
    // Get minutes
    get_time_record_minutes(sp40, &sp34);
    // Print minute
    func_800939C8(arg1 + 0x2C, arg2, &sp34, 0, temp_f20, temp_f20);
    // '
    func_80093324(arg1 + 0x37, arg2, &D_800F0C4C, 0, temp_f20, temp_f20);
    // Get seconds
    get_time_record_seconds(sp40, &sp34);
    // Print seconds
    func_800939C8(arg1 + 0x40, arg2, &sp34, 0, temp_f20, temp_f20);
    // "
    func_80093324(arg1 + 0x4B, arg2, &D_800F0C50, 0, temp_f20, temp_f20);
    // Get milliseconds
    get_time_record_centiseconds(sp40, &sp34);
    // Print millisecond
    func_800939C8(arg1 + 0x55, arg2, &sp34, 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4550.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800939C8(s32, s32, ? *, ?, f32, f32); // extern
? get_time_record_minutes(u32, ? *); // extern
? get_time_record_seconds(u32, ? *); // extern
? get_time_record_centiseconds(u32, ? *); // extern
void *func_800AAEF4(?); // extern
u32 func_800B4E24(s32, s8 *); // extern
u32 func_800B4EB4(s32, s8); // extern
u32 func_800B4F2C(s8 *); // extern
u32 func_800B4FB0(s8); // extern
? set_text_color(s32); // extern
extern ? D_800E76A8;
extern ? D_800E7744;
extern ? D_800F0C54;
extern ? D_800F0C58;
extern f32 D_800F1DC8;
extern s8 gTimeTrialDataCourseIndex;
extern s32 gGlobalTimer;

void func_800A474C(s32 arg0, s32 arg1, s32 arg2) {
    u32 sp48;
    s32 sp40;
    ? sp38;
    s32 sp30;
    u32 sp2C;
    f32 temp_f20;
    u32 temp_t0;
    void *temp_v0;
    u32 phi_v0;
    u32 phi_v0_2;
    u32 phi_v0_3;

    if (D_800DC50C == RACING) {
        sp30 = 0;
    } else {
        sp30 = 1;
    }
    if (arg0 < 5) {
        if (sp30 == 0) {
            phi_v0 = func_800B4E24(arg0, &gTimeTrialDataCourseIndex);
        } else {
            phi_v0 = func_800B4EB4(arg0, gTimeTrialDataCourseIndex);
        }
        sp48 = phi_v0;
        set_text_color(TEXT_GREEN);
    } else {
        if (sp30 == 0) {
            phi_v0_2 = func_800B4F2C(&gTimeTrialDataCourseIndex);
        } else {
            phi_v0_2 = func_800B4FB0(gTimeTrialDataCourseIndex);
        }
        sp48 = phi_v0_2;
    }
    temp_f20 = D_800F1DC8;
    func_800939C8(arg1 + 0x14, arg2, *(&D_800E7744 + (arg0 * 4)), 2, temp_f20, temp_f20);
    if (sp30 == 0) {
        temp_v0 = func_800AAEF4(0xBB);
        if (arg0 < 5) {
            if (arg0 == temp_v0->unk1C) {
                sp40 = gGlobalTimer % 3;
            } else {
                goto block_21;
            }
        } else if (temp_v0->unk20 != 0) {
            sp40 = gGlobalTimer % 3;
        } else {
            goto block_21;
        }
    } else {
block_21:
        sp40 = 3;
    }
    set_text_color(sp40);
    temp_t0 = sp48 & 0xFFFFF;
    sp2C = temp_t0;
    get_time_record_minutes(temp_t0, &sp38);
    // Print minute
    func_800939C8(arg1 + 0x27, arg2, &sp38, 0, temp_f20, temp_f20);
    // '
    func_80093324(arg1 + 0x32, arg2, &D_800F0C54, 0, temp_f20, temp_f20);
    get_time_record_seconds(sp2C, &sp38);
    // Print second
    func_800939C8(arg1 + 0x3B, arg2, &sp38, 0, temp_f20, temp_f20);
    // "
    func_80093324(arg1 + 0x46, arg2, &D_800F0C58, 0, temp_f20, temp_f20);
    get_time_record_centiseconds(sp2C, &sp38);
    // Print millisecond
    func_800939C8(arg1 + 0x50, arg2, &sp38, 0, temp_f20, temp_f20);
    if (sp2C < MAX_TIME) {
        phi_v0_3 = sp48 >> 0x14;
    } else {
        phi_v0_3 = 8;
    }
    draw_text(arg1 + 0x78, arg2, *(&D_800E76A8 + (phi_v0_3 * 4)), 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A474C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? draw_text(s32, s32, ? *, ?, f32, f32); // extern
s32 get_string_width(? *, void *); // extern
? set_text_color(?); // extern
extern ? D_800E7780;
extern f32 D_800F1DCC;
extern f32 D_800F1DD0;
extern s32 gDisplayListHead;

void func_800A4A24(void *arg0) {
    s32 sp38;
    s32 sp34;
    f32 temp_f0;
    f32 temp_f0_2;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_t2;
    void *temp_a1;

    temp_t1 = arg0->unk10;
    temp_a1 = arg0;
    temp_t0 = 0x140 - arg0->unkC;
    sp38 = temp_t0;
    arg0 = temp_a1;
    sp34 = temp_t1;
    temp_f0 = D_800F1DCC;
    temp_t2 = ((get_string_width(&D_800E7780, temp_a1) + 8) * temp_f0) / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_t0 - temp_t2, (temp_t1 - (24.0f * temp_f0)) + 4, temp_t2 + temp_t0, temp_t1 + 4, 0, 0, 0, 0x64);
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    temp_f0_2 = D_800F1DD0;
    draw_text(arg0->unkC - 3, arg0->unk10, &D_800E7780, 0, temp_f0_2, temp_f0_2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4A24.s")
#endif

void func_800A4B38(struct_8018D9E0_entry *arg0) {
    if (D_800DC5FC != 0) {
        switch (gModeSelection) {
            case TIME_TRIALS:
                func_800A4BC8(arg0);
                break;
            case VERSUS:
                func_800A4EF8(arg0);
                break;
            case GRAND_PRIX:
                func_800A5084(arg0);
                break;
            case BATTLE:
                func_800A5360(arg0);
                break;
        }
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, ?, ?, ?, s32, s32, s32, s32, s32); // extern
? draw_text(?, ?, s32, ?, f32, f32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(s16, s32, ? *, ?, f32, f32); // extern
? func_800939C8(?, ?, ? *, ?, f32, f32); // extern
? get_time_record_minutes(s32, ? *); // extern
? get_time_record_seconds(s32, ? *); // extern
? get_time_record_centiseconds(s32, ? *); // extern
s32 func_800B4E24(?); // extern
s32 func_800B4F2C(); // extern
? set_text_color(?); // extern
extern ? D_800E7574;
extern ? D_800E7728;
extern ? *D_800E775C;
extern s16 D_800E8538;
extern s16 D_800E853A;
extern ? D_800F0C5C;
extern ? D_800F0C60;
extern ? D_800F0C64;
extern ? D_800F0C68;
extern f32 D_800F1DD4;
extern s8 gCupSelection;
extern ? gCupCourseOrder;
extern s32 gDisplayListHead;

void func_800A4BC8(void *arg0) {
    ? sp68;
    f32 temp_f20;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 phi_s0;
    s32 phi_s1;
    ? **phi_s2;

    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x8C);
    set_text_color(TEXT_YELLOW);
    draw_text(0xA0, 0x50, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 1.0f, 1.0f);
    set_text_color(TEXT_RED);
    temp_f20 = D_800F1DD4;
    // "Best Records"
    draw_text(0x9D, 0x60, D_800E7728.unk0, 0, temp_f20, temp_f20);
    temp_a0 = func_800B4E24(0) & 0xFFFFF;
    temp_s1 = temp_a0;
    // Print minutes
    get_time_record_minutes(temp_a0, &sp68);
    func_800939C8(0x7F, 0x6D, &sp68, 0, temp_f20, temp_f20);
    // '
    func_80093324(0x8E, 0x6D, &D_800F0C5C, 0, temp_f20, temp_f20);
    // Print seconds
    get_time_record_seconds(temp_s1, &sp68);
    func_800939C8(0x98, 0x6D, &sp68, 0, temp_f20, temp_f20);
    // "
    func_80093324(0xA7, 0x6D, &D_800F0C60, 0, temp_f20, temp_f20);
    // Print centiseconds
    get_time_record_centiseconds(temp_s1, &sp68);
    func_800939C8(0xB3, 0x6D, &sp68, 0, temp_f20, temp_f20);
    // "Best Lap"
    draw_text(0x9D, 0x7C, D_800E7728.unk4, 0, temp_f20, temp_f20);
    temp_a0_2 = func_800B4F2C() & 0xFFFFF;
    temp_s1_2 = temp_a0_2;
    // Print minutes
    get_time_record_minutes(temp_a0_2, &sp68);
    func_800939C8(0x7F, 0x89, &sp68, 0, temp_f20, temp_f20);
    // '
    func_80093324(0x8E, 0x89, &D_800F0C64, 0, temp_f20, temp_f20);
    // Print seconds
    get_time_record_seconds(temp_s1_2, &sp68);
    func_800939C8(0x98, 0x89, &sp68, 0, temp_f20, temp_f20);
    // "
    func_80093324(0xA7, 0x89, &D_800F0C68, 0, temp_f20, temp_f20);
    // Print centiseconds
    get_time_record_centiseconds(temp_s1_2, &sp68);
    func_800939C8(0xB3, 0x89, &sp68, 0, temp_f20, temp_f20);
    phi_s0 = 0;
    phi_s1 = 0;
    phi_s2 = &D_800E775C;
    do {
        func_800921C0(arg0->unk4 - 0xB, phi_s0, TEXT_GREEN);
        func_80093324(D_800E8538, D_800E853A + phi_s1, *phi_s2, 0, 0.75f, 0.75f);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
        phi_s1 += 0xD;
        phi_s2 += 4;
    } while (temp_s0 != 5);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4BC8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(s32, s32, s32, ?, f32, f32); // extern
extern u16 D_800DC5FC;
extern ? D_800E775C;
extern ? D_800E8540;
extern ? D_8015F480;
extern s32 gDisplayListHead;

void func_800A4EF8(void *arg0) {
    s16 temp_t0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_t3;
    s32 temp_t4;
    void *temp_s3;
    void *temp_v0;
    s32 phi_a1;
    s32 phi_s2;
    s32 phi_s1;
    s32 phi_s0;

    temp_v0 = (D_800DC5FC << 6) - 0x40 + &D_8015F480;
    temp_v1 = temp_v0->unk30;
    temp_t0 = temp_v0->unk32;
    temp_t3 = temp_v0->unk2C / 2;
    temp_t4 = temp_v0->unk2E / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_v1 - temp_t3, temp_t0 - temp_t4, temp_v1 + temp_t3, temp_t0 + temp_t4, 0, 0, 0, 0x8C);
    temp_s3 = ((gScreenModeSelection << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8540;
    phi_a1 = 0;
    phi_s2 = 0;
    do {
        phi_s1 = phi_a1;
        if (phi_a1 > 0) {
            temp_s0 = phi_a1 + 1;
            phi_s1 = temp_s0;
            phi_s0 = temp_s0;
        } else {
            phi_s0 = phi_a1 + 1;
        }
        func_800921C0(arg0->unk4 - 0x15, phi_a1, TEXT_YELLOW);
        func_80093324(temp_s3->unk0 - 2, temp_s3->unk2 + phi_s2, *(&D_800E775C + (phi_s1 * 4)), 0, 0.75f, 0.75f);
        phi_a1 = phi_s0;
        phi_s2 += 0xD;
    } while (phi_s0 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4EF8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? draw_text(s32, s32, s32, ?, f32, f32); // extern
? func_800921C0(s32, s32, ?); // extern
s32 get_string_width(s32); // extern
? func_80093324(s16, s32, s32, ?, f32, f32); // extern
? set_text_color(?); // extern
extern u16 D_800DC5FC;
extern ? D_800E7500;
extern ? D_800E7574;
extern ? D_800E76CC;
extern s32 D_800E775C;
extern ? D_800E85C0;
extern ? D_8015F480;
extern s8 gCupSelection;
extern ? gCupCourseOrder;
extern s32 gDisplayListHead;

void func_800A5084(void *arg0) {
    s16 temp_t0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s1;
    s32 temp_t3;
    s32 temp_t4;
    void *temp_s3;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_s1;
    s32 *phi_s2;

    temp_v0 = (D_800DC5FC << 6) - 0x40 + &D_8015F480;
    temp_v1 = temp_v0->unk30;
    temp_t0 = temp_v0->unk32;
    temp_t3 = temp_v0->unk2C / 2;
    temp_t4 = temp_v0->unk2E / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_v1 - temp_t3, temp_t0 - temp_t4, temp_v1 + temp_t3, temp_t0 + temp_t4, 0, 0, 0, 0x8C);
    temp_s3 = ((gScreenModeSelection << 5) + (D_800DC5FC * 8)) - 8 + &D_800E85C0;
    temp_s0 = ((get_string_width(*(&D_800E7500 + (gCupSelection * 4))) * 1.0f) + 10.0f) / 2.0f;
    temp_s1 = ((get_string_width(*(&D_800E76CC + (gCCSelection * 4))) * 1.0f) + 10.0f) / 2.0f;
    set_text_color(TEXT_YELLOW);
    draw_text(0xA0 - temp_s1, temp_s3->unk2 - 0x32, *(&D_800E7500 + (gCupSelection * 4)), 0, 1.0f, 1.0f);
    set_text_color(TEXT_YELLOW);
    draw_text(temp_s0 + 0xA0, temp_s3->unk2 - 0x32, *(&D_800E76CC + (gCCSelection * 4)), 0, 1.0f, 1.0f);
    set_text_color(TEXT_YELLOW);
    draw_text(0xA0, temp_s3->unk2 - 0x1E, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 1.0f, 1.0f);
    phi_s0 = 0;
    phi_s1 = 0;
    phi_s2 = &D_800E775C;
    do {
        func_800921C0(arg0->unk4 - 0x1F, phi_s0, TEXT_YELLOW);
        func_80093324(temp_s3->unk0, temp_s3->unk2 + phi_s1, *phi_s2, 0, 0.75f, 0.75f);
        temp_s0_2 = phi_s0 + 1;
        phi_s0 = temp_s0_2;
        phi_s1 += 0xD;
        phi_s2 += 0x10;
    } while (temp_s0_2 != 2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A5084.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(s32, s32, s32, ?, f32, f32); // extern
extern u16 D_800DC5FC;
extern ? D_800E775C;
extern ? D_800E8600;
extern ? D_8015F480;
extern s32 gDisplayListHead;

void func_800A5360(void *arg0) {
    s16 temp_t0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_t3;
    s32 temp_t4;
    void *temp_s3;
    void *temp_v0;
    s32 phi_a1;
    s32 phi_s2;
    s32 phi_s1;
    s32 phi_s0;

    temp_v0 = (D_800DC5FC << 6) - 0x40 + &D_8015F480;
    temp_v1 = temp_v0->unk30;
    temp_t0 = temp_v0->unk32;
    temp_t3 = temp_v0->unk2C / 2;
    temp_t4 = temp_v0->unk2E / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_v1 - temp_t3, temp_t0 - temp_t4, temp_v1 + temp_t3, temp_t0 + temp_t4, 0, 0, 0, 0x8C);
    temp_s3 = ((gScreenModeSelection << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8600;
    phi_a1 = 0;
    phi_s2 = 0;
    do {
        phi_s1 = phi_a1;
        if (phi_a1 > 0) {
            temp_s0 = phi_a1 + 1;
            phi_s1 = temp_s0;
            phi_s0 = temp_s0;
        } else {
            phi_s0 = phi_a1 + 1;
        }
        func_800921C0(arg0->unk4 - 0x29, phi_a1, TEXT_YELLOW);
        func_80093324(temp_s3->unk0 - 2, temp_s3->unk2 + phi_s2, *(&D_800E775C + (phi_s1 * 4)), 0, 0.75f, 0.75f);
        phi_a1 = phi_s0;
        phi_s2 += 0xD;
    } while (phi_s0 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A5360.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A66A8(void *, s16 *); // extern
void *func_800AAF30(?); // extern
extern u16 D_800DC5FC;
extern ? D_800E8538;
extern ? D_800E8540;
extern ? D_800E85C0;
extern ? D_800E8600;
extern ? D_800F0B50;
extern s16 D_80164AF0;
extern ? D_802B8880;
extern void *gDisplayListHead;

void func_800A54EC(void) {
    s16 sp52;
    s16 sp50;
    void *sp48;
    s32 sp40;
    s32 temp_t2;
    void *temp_v1;
    void *temp_v1_2;
    ? *phi_v1;

    if (D_800DC5FC != 0) {
        temp_t2 = gModeSelection;
        sp40 = temp_t2;
        temp_v1 = gDisplayListHead;
        sp48 = func_800AAF30(0xC7);
        gDisplayListHead = temp_v1 + 8;
        temp_v1->unk4 = &D_802B8880 & 0x1FFFFFFF;
        temp_v1->unk0 = 0x3800010;
        sp40 = temp_t2;
        guOrtho(gGfxPool + (D_80164AF0 << 6) + 0xFAC0, 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
        temp_v1_2 = gDisplayListHead;
        gDisplayListHead = temp_v1_2 + 8;
        temp_v1_2->unk0 = 0x1030040;
        temp_v1_2->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
        D_80164AF0 = D_80164AF0 + 1;
        if (temp_t2 != GRAND_PRIX) {
            if (temp_t2 != TIME_TRIALS) {
                if (temp_t2 != VERSUS) {
                    if (temp_t2 != BATTLE) {
                        phi_v1 = sp4C;
                    } else {
                        phi_v1 = ((gScreenModeSelection << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8600;
                    }
                } else {
                    phi_v1 = ((gScreenModeSelection << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8540;
                }
            } else {
                phi_v1 = &D_800E8538;
            }
        } else {
            phi_v1 = ((gScreenModeSelection << 5) + (D_800DC5FC * 8)) - 8 + &D_800E85C0;
        }
        sp50 = phi_v1->unk0 - 8;
        sp52 = (phi_v1->unk2 + ((sp48->unk4 - *(&D_800F0B50 + temp_t2)) * 0xD)) - 8;
        func_800A66A8(sp48, &sp50);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A54EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
Gfx *draw_box(Gfx *, ?, ?, s32, s32, s32, s32, s32, s32); /* extern */
? func_800921C0(s32, s32, ?);                       /* extern */
s32 get_string_width(? *);                             /* extern */
? func_80093324(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_80093358(s16, s32, ? *, ?, f32, f32);        /* extern */
? func_80093754(?, ?, s32, ?, f32, f32);            /* extern */
? func_800A66A8(void *, s16 *);                     /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? get_time_record_minutes(s32, ? *);                          /* extern */
? get_time_record_seconds(s32, ? *);                          /* extern */
? get_time_record_centiseconds(s32, ? *);                          /* extern */
s32 func_800B4E24(?);                               /* extern */
? set_text_color(?);                                /* extern */
? text_draw(?, ?, ? *, ?, f32, f32);                /* extern */
extern ? D_8018EE10;
static ? D_800E73E0;                                /* unable to generate initializer; const */
static ? D_800E7410;                                /* unable to generate initializer; const */
static ? D_800E7420;                                /* unable to generate initializer; const */
static ? D_800E7574;                                /* unable to generate initializer; const */
static ? D_800E75C4;                                /* unable to generate initializer; const */
static ? D_800E7728;                                /* unable to generate initializer; const */
static ? *D_800E775C[7] = {
    "CONTINUE GAME",
    "RETRY",
    "COURSE CHANGE",
    "DRIVER CHANGE",
    "QUIT",
    "REPLAY",
    "SAVE GHOST",
}; /* const */
static ? D_800E798C;                                /* unable to generate initializer; const */
static ? *D_800E7A3C[2] = { "SELECT THE FILE ", "YOU WANT TO SAVE" }; /* const */
static ? *D_800E7A44 = "NO DATA";                   /* const */
static ? *D_800E7A48[3] = { "CREATING ", "MARIO KART 64 ", "GAME DATA" }; /* const */
static ? D_800E7A54;                                /* unable to generate initializer; const */
static ? *D_800E7A60[3] = { "THE PREVIOUS DATA ", "WILL BE ERASED, ", "IS THIS OK?" }; /* const */
static ? *D_800E7A6C[2] = { "QUIT", "SAVE" };       /* const */
static ? *D_800E7A74[3] = { "SAVING GHOST DATA", "", "PLEASE WAIT" }; /* const */
static ? *D_800E7A80[2] = { "UNABLE TO SAVE ", "THE GHOST" }; /* const */
static ? D_800E7A88;                                /* unable to generate initializer; const */
static s16 D_800E8538;                              /* type too large by 2; unable to generate initializer; const */
static s16 D_800E853A;                              /* type too large by 2; unable to generate initializer; const */
static ? gCupCourseOrder;                            /* unable to generate initializer; const */

void func_800A5738(void *arg0) {
    s16 sp9A;
    s16 sp98;
    ? sp84;
    ? sp5D;
    ? sp5C;
    s32 sp54;
    ? **sp50;
    ? **temp_v0_2;
    ? **temp_v0_4;
    ? **temp_v0_5;
    ? **temp_v0_6;
    ? **temp_v0_7;
    Gfx *temp_v0;
    s16 *temp_a1;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s1_3;
    s32 temp_s1_4;
    s32 temp_s1_5;
    s32 temp_v1;
    s32 temp_v1_2;
    s8 temp_v0_3;
    s32 phi_s1;
    s32 phi_s2;
    ? **phi_v0;
    s32 phi_s1_2;
    s32 phi_s0;
    ? **phi_v0_2;
    s32 phi_s0_2;
    ? **phi_v0_3;
    s32 phi_s0_3;
    s32 phi_s1_3;
    s32 phi_s0_4;
    ? *phi_s2_2;
    ? **phi_v0_4;
    s32 phi_s0_5;
    ? **phi_v0_5;
    s32 phi_s0_6;
    ? **phi_v0_6;
    s32 phi_s1_4;
    s32 phi_s0_7;
    ? **phi_v0_7;
    s32 phi_s0_8;
    ? **phi_v0_8;
    s32 phi_s0_9;
    void *phi_v0_9;

    temp_v1 = arg0->unk4;
    if (temp_v1 == 0) {
        if ((arg0->unk1C >= 0x1E) && (((gGlobalTimer / 16) % 2) != 0)) {
            gDisplayListHead = draw_box(gDisplayListHead, 0xC0, 0x21, (get_string_width(D_800E775C->unk14) * 0.8f) + 0xC6, 0x32, 0, 0, 0, 0x96);
            set_text_color(TEXT_GREEN);
            func_80093324(0xBF, 0x30, D_800E775C->unk14, 0, 0.8f, 0.8f);
            return;
        }
        /* Duplicate return node #43. Try simplifying control flow for better match */
        return;
    }
    if (temp_v1 == 1) {
        temp_s1 = arg0->unk1C;
        phi_s1 = temp_s1;
        phi_s2 = (temp_s1 * 0xFF) / 140;
    } else {
        phi_s1 = 0x8C;
        phi_s2 = 0xFF;
    }
    temp_v0 = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, phi_s1);
    gDisplayListHead = temp_v0;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->words.w1 = phi_s2 & 0xFF;
    temp_v0->words.w0 = 0xFA000000;
    set_text_color(TEXT_YELLOW);
    func_80093754(0xA0, 0x50, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 1.0f, 1.0f);
    temp_v1_2 = arg0->unk4;
    switch (temp_v1_2) {                            /* switch 1 */
    case 1:                                         /* switch 1 */
    case 11:                                        /* switch 1 */
    case 12:                                        /* switch 1 */
    case 13:                                        /* switch 1 */
    case 14:                                        /* switch 1 */
    case 15:                                        /* switch 1 */
    case 16:                                        /* switch 1 */
        set_text_color(TEXT_RED);
        func_80093754(0x9D, 0x60, D_800E7728.unk0, 0, 0.8f, 0.8f);
        temp_a0 = func_800B4E24(0) & 0xFFFFF;
        temp_s1_2 = temp_a0;
        get_time_record_minutes(temp_a0, &sp84);
        text_draw(0x7F, 0x6D, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0x8E, 0x6D, "'", 0, 0.8f, 0.8f);
        get_time_record_seconds(temp_s1_2, &sp84);
        text_draw(0x98, 0x6D, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0xA7, 0x6D, "\"", 0, 0.8f, 0.8f);
        get_time_record_centiseconds(temp_s1_2, &sp84);
        text_draw(0xB3, 0x6D, &sp84, 0, 0.8f, 0.8f);
        func_80093754(0x9D, 0x7C, D_800E7728.unk4, 0, 0.8f, 0.8f);
        temp_a0_2 = func_800B4F2C() & 0xFFFFF;
        temp_s1_3 = temp_a0_2;
        get_time_record_minutes(temp_a0_2, &sp84);
        text_draw(0x7F, 0x89, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0x8E, 0x89, "'", 0, 0.8f, 0.8f);
        get_time_record_seconds(temp_s1_3, &sp84);
        text_draw(0x98, 0x89, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0xA7, 0x89, "\"", 0, 0.8f, 0.8f);
        get_time_record_centiseconds(temp_s1_3, &sp84);
        text_draw(0xB3, 0x89, &sp84, 0, 0.8f, 0.8f);
        phi_v0 = D_800E775C;
        phi_s1_2 = 0;
        phi_s0 = 0;
        do {
            sp50 = phi_v0;
            func_800921C0(arg0->unk4 - 0xB, phi_s1_2, TEXT_GREEN);
            func_80093358(D_800E8538, D_800E853A + phi_s0, phi_v0->unk4, 0, 0.75f, 0.75f);
            temp_s1_4 = phi_s1_2 + 1;
            phi_v0 += 4;
            phi_s1_2 = temp_s1_4;
            phi_s0 += 0xD;
        } while (temp_s1_4 != 6);
block_36:
        break;
    case 21:                                        /* switch 1 */
    case 22:                                        /* switch 1 */
    case 23:                                        /* switch 1 */
    case 24:                                        /* switch 1 */
    case 25:                                        /* switch 1 */
    case 26:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_2 = ((arg0->unk4 - 0x15) * 0x1C) + &D_800E798C;
        phi_s0_2 = 0x6E;
        do {
            sp50 = phi_v0_2;
            func_80093324(0x4D, phi_s0_2, *phi_v0_2, 0, 0.8f, 0.8f);
            temp_s0 = phi_s0_2 + 0xD;
            phi_v0_2 += 4;
            phi_s0_2 = temp_s0;
        } while (temp_s0 != 0xC9);
        goto block_36;
    case 30:                                        /* switch 1 */
    case 31:                                        /* switch 1 */
        set_text_color(TEXT_GREEN);
        phi_v0_3 = D_800E7A3C;
        phi_s0_3 = 0;
        do {
            sp50 = phi_v0_3;
            func_80093324(0x5A, arg0->unk10 + phi_s0_3 + 0x6E, *phi_v0_3, 0, 0.8f, 0.8f);
            temp_v0_2 = phi_v0_3 + 4;
            phi_v0_3 = temp_v0_2;
            phi_s0_3 += 0xD;
        } while (temp_v0_2 < &D_800E7A44);
        phi_s1_3 = 0;
        phi_s0_4 = 0x96;
        phi_s2_2 = &D_8018EE10;
        do {
            func_800921C0(arg0->unk4 - 0x1E, phi_s1_3, TEXT_GREEN);
            temp_a0_3 = phi_s1_3 + 1;
            sp54 = temp_a0_3;
            convert_number_to_ascii(temp_a0_3, &sp5C);
            func_80093324(0x5A - arg0->unkC, phi_s0_4, &sp5D, 0, 0.75f, 0.75f);
            if (phi_s2_2->unk4 == 0) {
                func_80093324(0x69 - arg0->unkC, phi_s0_4, D_800E7A44, 0, 0.75f, 0.75f);
            } else {
                temp_v0_3 = phi_s2_2->unk5;
                func_80093324(0x69 - arg0->unkC, phi_s0_4, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_3 / 4) * 8) + ((temp_v0_3 % 4) * 2))) * 4)), 0, 0.75f, 0.75f);
            }
            phi_s1_3 = sp54;
            phi_s0_4 += 0x14;
            phi_s2_2 += 0x80;
        } while (sp54 != 2);
        goto block_36;
    case 32:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_4 = D_800E7A48;
        phi_s0_5 = 0x6E;
        do {
            sp50 = phi_v0_4;
            func_80093324(0x64, phi_s0_5, *phi_v0_4, 0, 0.8f, 0.8f);
            temp_v0_4 = phi_v0_4 + 4;
            phi_v0_4 = temp_v0_4;
            phi_s0_5 += 0xD;
        } while (temp_v0_4 != &D_800E7A54);
        goto block_36;
    case 35:                                        /* switch 1 */
    case 36:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_5 = D_800E7A60;
        phi_s0_6 = 0;
        do {
            sp50 = phi_v0_5;
            func_80093324(0x55, arg0->unk10 + phi_s0_6 + 0x6E, *phi_v0_5, 0, 0.8f, 0.8f);
            temp_v0_5 = phi_v0_5 + 4;
            phi_v0_5 = temp_v0_5;
            phi_s0_6 += 0xD;
        } while (temp_v0_5 < D_800E7A6C);
        phi_v0_6 = D_800E7A6C;
        phi_s1_4 = 0;
        phi_s0_7 = 0x9B;
        do {
            sp50 = phi_v0_6;
            func_800921C0(arg0->unk4 - 0x23, phi_s1_4, TEXT_GREEN);
            func_80093324(0x7D - arg0->unkC, phi_s0_7, *phi_v0_6, 0, 0.8f, 0.8f);
            temp_s1_5 = phi_s1_4 + 1;
            phi_v0_6 += 4;
            phi_s1_4 = temp_s1_5;
            phi_s0_7 += 0xF;
        } while (temp_s1_5 != 2);
        goto block_36;
    case 40:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_7 = D_800E7A74;
        phi_s0_8 = 0x6E;
        do {
            sp50 = phi_v0_7;
            func_80093324(0x55, phi_s0_8, *phi_v0_7, 0, 0.8f, 0.8f);
            temp_v0_6 = phi_v0_7 + 4;
            phi_v0_7 = temp_v0_6;
            phi_s0_8 += 0xD;
        } while (temp_v0_6 != D_800E7A80);
        goto block_36;
    case 41:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_8 = D_800E7A80;
        phi_s0_9 = 0x6E;
        do {
            sp50 = phi_v0_8;
            func_80093324(0x5D, phi_s0_9, *phi_v0_8, 0, 0.8f, 0.8f);
            temp_v0_7 = phi_v0_8 + 4;
            phi_v0_8 = temp_v0_7;
            phi_s0_9 += 0xD;
        } while (temp_v0_7 != &D_800E7A88);
        goto block_36;
    }
    switch (arg0->unk4) {                           /* switch 2 */
    case 11:                                        /* switch 2 */
    case 12:                                        /* switch 2 */
    case 13:                                        /* switch 2 */
    case 14:                                        /* switch 2 */
    case 15:                                        /* switch 2 */
    case 16:                                        /* switch 2 */
        phi_v0_9 = (arg0->unk4 * 8) - 0x58 + &D_800E73E0;
block_42:
        temp_a1 = &sp98;
        sp98 = phi_v0_9->unk0;
        sp9A = phi_v0_9->unk2;
        func_800A66A8(arg0, temp_a1);
        break;
    case 30:                                        /* switch 2 */
    case 31:                                        /* switch 2 */
        phi_v0_9 = (arg0->unk4 * 8) - 0xF0 + &D_800E7410;
        goto block_42;
    case 35:                                        /* switch 2 */
    case 36:                                        /* switch 2 */
        phi_v0_9 = (arg0->unk4 * 8) - 0x118 + &D_800E7420;
        goto block_42;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A5738.s")
#endif

void func_800A6034(struct_8018D9E0_entry *arg0) {
    char *text;

    if (D_801657E8 != 1) {
        gDPSetPrimColor(gDisplayListHead++, 0, 0, 0x00, 0x00, 0x00, arg0->unk1C);
        text = D_800E7500[D_800DC540];
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        func_80093754(arg0->column + 0x41, arg0->row + 0xA0, text, 0, D_800F1F04, 1.0f);
        text = D_800E7524[gCurrentCourseId];
        set_text_color((s32) gCurrentCourseId % 4);
        func_80093754(arg0->column + 0x41, arg0->row + 0xC3, text, 0, D_800F1F08, D_800F1F0C);
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, s32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_80093358(?, s32, s32, ?, f32, f32); // extern
void *func_80098FC8(void *, ?, s32, ?, s32); // extern
? func_800A66A8(void *, s16 *); // extern
? set_text_color(?); // extern
extern ? D_800E775C;
extern void *gDisplayListHead;

void func_800A6154(void *arg0) {
    s16 sp6E;
    s16 sp6C;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_v0_2;
    void *temp_v0;
    void *temp_v0_3;
    s32 phi_s0;
    ? *phi_s2;
    s32 phi_s1;
    s32 phi_s0_2;
    ? *phi_s2_2;

    if (arg0->unk4 == 0) {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, arg0->unk1C);
        set_text_color(TEXT_YELLOW);
        temp_v0 = gDisplayListHead;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xFA000000;
        temp_v0->unk4 = ((arg0->unk1C * 0xFF) / 0x64) & 0xFF;
        phi_s0 = 0x96;
        phi_s2 = &D_800E775C;
        do {
            func_80093358(0x8C, phi_s0, phi_s2->unk4, 0, 1.0f, 1.0f);
            temp_s0 = phi_s0 + 0x14;
            phi_s0 = temp_s0;
            phi_s2 += 0xC;
        } while (temp_s0 != 0xBE);
    } else {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x64);
        phi_s1 = 0;
        phi_s0_2 = 0x96;
        phi_s2_2 = &D_800E775C;
        do {
            func_800921C0(arg0->unk4 - 0xB, phi_s1, TEXT_YELLOW);
            func_80093324(0x8C, phi_s0_2, phi_s2_2->unk4, 0, 1.0f, 1.0f);
            temp_s1 = phi_s1 + 1;
            phi_s1 = temp_s1;
            phi_s0_2 += 0x14;
            phi_s2_2 += 0xC;
        } while (temp_s1 != 2);
    }
    if (arg0->unk4 >= 0xB) {
        sp6C = 0x84;
        sp6E = (arg0->unk4 * 0x14) - 0x4E;
        func_800A66A8(arg0, &sp6C);
    }
    temp_v0_2 = arg0->unk20;
    if (temp_v0_2 > 0) {
        temp_v0_3 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, temp_v0_2);
        gDisplayListHead = temp_v0_3;
        gDisplayListHead = func_80098FC8(temp_v0_3, 0, 0xEF - arg0->unk20, 0x13F, 0xEF);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6154.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, s32); // extern
? draw_text(?, s32, s32, ?, f32, f32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_80093754(?, s32, s32, ?, f32, f32); // extern
? func_800A66A8(void *, void *); // extern
? func_800A69C8(void *, s32); // extern
? func_800A6BEC(void *, s32); // extern
? func_800A6CC0(void *, s32); // extern
? set_text_color(?); // extern
extern ? D_800E7360;
extern ? D_800E775C;
extern ? D_800E7778;
extern f32 D_800F1F10;
extern void *gDisplayListHead;

void func_800A638C(void *arg0) {
    f32 temp_f20;
    s32 temp_a0;
    s32 temp_s0;
    s8 temp_a0_2;
    void *temp_v0;
    void *temp_v0_2;
    s32 phi_a1;
    s32 phi_s0;
    s32 phi_s1;
    ? *phi_s2;

    if (arg0->unk4 == 0) {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, arg0->unk1C);
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        temp_v0 = gDisplayListHead;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xFA000000;
        temp_v0->unk4 = ((arg0->unk1C * 0xFF) / 0x64) & 0xFF;
        func_80093754(0xA0, arg0->unk10 + 0x1E, *(&D_800E7778 + ((gModeSelection / 3) * 4)), 0, 1.0f, 1.0f);
    } else {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x64);
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        draw_text(0xA0, arg0->unk10 + 0x1E, *(&D_800E7778 + ((gModeSelection / 3) * 4)), 0, 1.0f, 1.0f);
    }
    temp_a0 = arg0->unk4;
    if ((temp_a0 != 0) && (temp_a0 != 1)) {
        if (temp_a0 != 2) {
            phi_a1 = 0xFF;
        } else {
            phi_a1 = arg0->unk1C;
        }
    } else {
        phi_a1 = 0;
    }
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk4 = phi_a1 & 0xFF;
    temp_v0_2->unk0 = 0xFA000000;
    temp_a0_2 = D_8018EDF3;
    if (temp_a0_2 != TWO_PLAYERS_SELECTED) {
        if (temp_a0_2 != THREE_PLAYERS_SELECTED) {
            if (temp_a0_2 != FOUR_PLAYERS_SELECTED) {

            } else {
                func_800A6CC0(arg0, phi_a1);
            }
        } else {
            func_800A6BEC(arg0, phi_a1);
        }
    } else {
        func_800A69C8(arg0, phi_a1);
    }
    phi_s0 = 0;
    phi_s1 = 0xAE;
    if (arg0->unk4 >= 0xA) {
        temp_f20 = D_800F1F10;
        phi_s2 = &D_800E775C;
        do {
            func_800921C0(arg0->unk4 - 0xA, phi_s0, TEXT_GREEN);
            func_80093324(0x69, phi_s1, phi_s2->unk4, 0, temp_f20, temp_f20);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
            phi_s1 += 0xF;
            phi_s2 += 4;
        } while (temp_s0 != 4);
        func_800A66A8(arg0, (arg0->unk4 * 8) - 0x50 + &D_800E7360);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A638C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? guMtxCatL(Mtx *, Mtx *, Mtx *); // extern
extern ? D_0D003090;
extern f64 D_800F1F18;
extern f32 D_800F1F20;
extern s16 D_80164AF0;
extern f32 D_8018ED98;
extern f32 D_8018ED9C;
extern f32 D_8018EDA0;
extern f32 D_8018EDA4;
extern f32 D_8018EDA8;
extern f32 D_8018EDAC;
extern void *gDisplayListHead;

void func_800A66A8(void *arg0, void *arg1) {
    Mtx *temp_s0;
    Mtx *temp_s1;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;
    f64 temp_f0;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;

    temp_s1 = gGfxPool + (D_80164AF0 << 6) + 0xFAC0;
    temp_f0 = arg0->unk24;
    if (temp_f0 > 1.5) {
        arg0->unk24 = temp_f0 * D_800F1F18;
    } else {
        arg0->unk24 = 1.5f;
    }
    temp_f0_2 = arg0->unk24;
    temp_f2 = temp_f0_2 * 3.0f * arg0->unk8;
    temp_f12 = temp_f0_2 * 4.0f;
    temp_f14 = temp_f0_2 * 2.0f;
    D_8018EDA0 = D_8018EDA0 + temp_f14;
    D_8018EDA4 = temp_f2;
    D_8018EDA8 = temp_f12;
    D_8018EDAC = temp_f14;
    D_8018ED98 = D_8018ED98 + temp_f2;
    D_8018ED9C = D_8018ED9C + temp_f12;
    temp_f0_3 = D_800F1F20;
    guScale(temp_s1, temp_f0_3, temp_f0_3, temp_f0_3);
    temp_s0 = temp_s1 + 0x40;
    guRotate(temp_s0, D_8018ED9C, 0.0f, 1.0f, 0.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    guRotate(temp_s0, D_8018EDA0, 0.0f, 0.0f, 1.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    guRotate(temp_s0, D_8018ED98, 1.0f, 0.0f, 0.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    guTranslate(temp_s0, arg1->unk0, arg1->unk2, 0.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk0 = 0x1020040;
    temp_v0->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
    temp_v0_2 = gDisplayListHead;
    D_80164AF0 = D_80164AF0 + 1;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xB6000000;
    temp_v0_2->unk4 = 0x20000;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = 0xFF33FFFF;
    temp_v0_3->unk0 = 0xFC121824;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = 0;
    temp_v0_4->unk0 = 0xC0000000;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk4 = 0x504340;
    temp_v0_5->unk0 = 0xB900031D;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk0 = 0x6000000;
    temp_v0_6->unk4 = &D_0D003090;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A66A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093754(s16, s16, s32, ?, f32, f32); // extern
? func_800A79F4(u8, ? *); // extern
? set_text_color(s32); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern s32 gPlayerWinningIndex;
extern ? D_800E7300;
extern s16 D_800E7302;
extern ? D_800E7380;
extern ? D_800E7720;
extern ? D_800F0C7C;
extern f32 D_800F1F24;
extern s32 D_8015F8B8;
extern s32 D_8015F8C4;
extern s32 gGlobalTimer;

void func_800A69C8(s32 arg0) {
    ? sp74;
    u8 *sp68;
    f32 temp_f22;
    s32 temp_s0;
    s32 temp_s3;
    s32 temp_v0;
    s32 phi_s0;
    s32 phi_v1;
    u8 *phi_s4;
    ? *phi_s1;
    ? *phi_s2;

    phi_s0 = 0;
    if (D_8018EDF3 > ZERO_PLAYERS_SELECTED) {
        temp_f22 = D_800F1F24;
        phi_s1 = &D_800E7300;
        phi_s2 = &D_800E7380;
        phi_s4 = sp68;
        do {
            temp_v0 = gModeSelection;
            phi_v1 = 0;
            phi_v1 = 0;
            phi_v1 = 0;
            if (temp_v0 != VERSUS) {
                if (temp_v0 != BATTLE) {

                } else {
                    if (phi_s0 != gPlayerWinningIndex) {
                        phi_v1 = 1;
                    }
                    phi_s4 = D_8015F8C4 + phi_s0;
                }
            } else {
                if (gPlayerPositions[phi_s0] != 0) {
                    phi_v1 = 1;
                }
                phi_s4 = D_8015F8B8 + phi_s0;
            }
            temp_s3 = *(&D_800E7720 + (phi_v1 * 4));
            if (phi_v1 != 0) {
                set_text_color(TEXT_BLUE);
            } else {
                set_text_color(gGlobalTimer % 3);
            }
            func_800A79F4(*phi_s4, &sp74);
            text_draw(phi_s1->unk0 + 0x10, phi_s1->unk2 + 0x75, &sp74, 0, 1.0f, 1.0f);
            func_80093754(phi_s2->unk0, phi_s2->unk2, temp_s3, 0, temp_f22, 1.0f);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
            phi_s1 += 8;
            phi_s2 += 8;
        } while (temp_s0 < D_8018EDF3);
        sp68 = phi_s4;
    }
    set_text_color(TEXT_BLUE);
    text_draw(0x9E, D_800E7302 + 0x6D, &D_800F0C7C, 0, 1.0f, 1.0f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A69C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A6D94(s32, s32, s32); // extern
? func_800A6E94(s32, s32, s32); // extern
extern s32 D_8015F8BC;
extern s32 D_8015F8C8;

void func_800A6BEC(s32 arg0) {
    s32 temp_s0;
    s32 temp_v0;
    s8 temp_v1;
    s32 phi_s0;
    s32 phi_v1;

    temp_v1 = D_8018EDF3;
    phi_s0 = 0;
    phi_v1 = temp_v1;
    if (temp_v1 > ZERO_PLAYERS_SELECTED) {
        do {
            temp_v0 = gModeSelection;
            if (temp_v0 != VERSUS) {
                if (temp_v0 != BATTLE) {

                } else {
                    func_800A6D94(3, phi_s0, D_8015F8C8);
                    goto block_7;
                }
            } else {
                func_800A6E94(3, phi_s0, D_8015F8BC);
block_7:
                phi_v1 = D_8018EDF3;
            }
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < phi_v1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6BEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A6D94(?, s32, s32); // extern
? func_800A6E94(?, s32, s32); // extern
extern s32 D_8015F8C0;
extern s32 D_8015F8CC;

void func_800A6CC0(s32 arg0) {
    s32 temp_s0;
    s32 temp_v0;
    s8 temp_v1;
    s32 phi_s0;
    s32 phi_v1;

    temp_v1 = D_8018EDF3;
    phi_s0 = 0;
    phi_v1 = temp_v1;
    if (temp_v1 > ZERO_PLAYERS_SELECTED) {
        do {
            temp_v0 = gModeSelection;
            if (temp_v0 != VERSUS) {
                if (temp_v0 != BATTLE) {

                } else {
                    func_800A6D94(4, phi_s0, D_8015F8CC);
                    goto block_7;
                }
            } else {
                func_800A6E94(4, phi_s0, D_8015F8C0);
block_7:
                phi_v1 = D_8018EDF3;
            }
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < phi_v1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6CC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A79F4(s32, ? *); // extern
? set_text_color(s32); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern s32 gPlayerWinningIndex;
extern ? D_800E7300;

void func_800A6D94(s32 arg0, s32 arg1, s32 arg2) {
    ? sp30;
    s32 sp24;
    void *temp_v0;
    s32 phi_v0;

    phi_v0 = 0;
    if (arg1 != gPlayerWinningIndex) {
        phi_v0 = 1;
    }
    sp24 = *(arg2 + arg1);
    if (phi_v0 != 0) {
        set_text_color(TEXT_BLUE);
    } else {
        set_text_color(gModeSelection % 3);
    }
    func_800A79F4(sp24, &sp30);
    temp_v0 = ((arg0 << 5) + (arg1 * 8)) - 0x40 + &D_800E7300;
    text_draw((temp_v0->unk0 + 0x20) - ((32.0f * 0.75f) / 2.0f), temp_v0->unk2 + 0x75, &sp30, 0, 0.75f, 0.75f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6D94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? convert_number_to_ascii(u8, ? *); // extern
? set_text_color(s32); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern ? D_800E7300;
extern ? D_800F0C80;
extern ? D_800F0C88;
extern ? D_800F0C90;
extern f32 D_800F1F28;
extern s32 gGlobalTimer;

void func_800A6E94(s32 arg0, s32 arg1, s32 arg2) {
    ? sp40;
    s32 sp3C;
    s32 sp38;
    u8 *sp30;
    f32 temp_f20;
    s32 temp_t8;
    u8 *temp_v0;
    void *temp_s0;

    temp_t8 = gPlayerPositions[arg1];
    sp3C = temp_t8;
    if (temp_t8 == 0) {
        set_text_color(gGlobalTimer % 3);
    } else {
        set_text_color(TEXT_YELLOW);
    }
    temp_s0 = ((arg0 << 5) + (arg1 * 8)) - 0x40 + &D_800E7300;
    temp_f20 = D_800F1F28;
    text_draw(temp_s0->unk0 + 4, temp_s0->unk2 + 0x5A, &D_800F0C80, 0, temp_f20, temp_f20);
    temp_v0 = (arg1 * 3) + arg2;
    sp30 = temp_v0;
    convert_number_to_ascii(*temp_v0, &sp40);
    text_draw(temp_s0->unk0 + 0x2D, temp_s0->unk2 + 0x5A, &sp40, 0, temp_f20, temp_f20);
    if (sp3C == 1) {
        sp38 = 1;
        set_text_color(gGlobalTimer % 3);
    } else {
        sp38 = 1;
        set_text_color(TEXT_BLUE);
    }
    sp38 = sp38;
    text_draw(temp_s0->unk0 + 4, temp_s0->unk2 + 0x69, &D_800F0C88, 0, temp_f20, temp_f20);
    convert_number_to_ascii(sp30->unk1, &sp40);
    text_draw(temp_s0->unk0 + 0x2D, temp_s0->unk2 + 0x69, &sp40, 0, temp_f20, temp_f20);
    if ((sp38 + 1) == sp3C) {
        set_text_color(gGlobalTimer % 3);
    } else {
        set_text_color(TEXT_RED);
    }
    text_draw(temp_s0->unk0 + 4, temp_s0->unk2 + 0x78, &D_800F0C90, 0, temp_f20, temp_f20);
    convert_number_to_ascii(sp30->unk2, &sp40);
    text_draw(temp_s0->unk0 + 0x2D, temp_s0->unk2 + 0x78, &sp40, 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6E94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, s32, s32, s32, s32, s32, s32); // extern
s32 get_string_width(s32); // extern
? func_80093358(?, s32, s32, ?, f32, f32); // extern
? set_text_color(?, s32); // extern
extern s32 D_800E7A34;
extern f32 D_800F1F2C;
extern void *gDisplayListHead;

void func_800A70E8(void *arg0) {
    f32 temp_f20;
    s32 temp_a1;
    s32 temp_f6;
    s32 temp_s0;
    s32 temp_s0_2;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_a1;
    s32 phi_s0_2;
    s32 *phi_s1;

    if (arg0->unk4 == 1) {
        temp_f20 = D_800F1F2C;
        temp_s0 = get_string_width(D_800E7A34.unk0) * temp_f20;
        temp_f6 = get_string_width(D_800E7A34.unk4) * temp_f20;
        phi_s0 = temp_s0;
        if (temp_s0 < temp_f6) {
            phi_s0 = temp_f6;
        }
        gDisplayListHead = draw_box(gDisplayListHead, 0xC0, 0x22, phi_s0 + 0xC6, 0x39, 0, 0, 0, 0x96);
        temp_a1 = 0x180 - ((arg0->unk1C % 0x20) * 8);
        phi_a1 = temp_a1;
        if (temp_a1 >= 0x100) {
            phi_a1 = 0xFF;
        }
        temp_v0 = gDisplayListHead;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk4 = phi_a1 & 0xFF;
        temp_v0->unk0 = 0xFA000000;
        set_text_color(TEXT_RED);
        phi_s0_2 = 0x2C;
        phi_s1 = &D_800E7A34;
        do {
            func_80093358(0xC0, phi_s0_2, *phi_s1, 0, temp_f20, temp_f20);
            temp_s0_2 = phi_s0_2 + 0xA;
            phi_s0_2 = temp_s0_2;
            phi_s1 += 4;
        } while (temp_s0_2 != 0x40);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A70E8.s")
#endif

// Shading layer of the grand prix podium result screen
void func_800A7258(struct_8018D9E0_entry *arg0) {
    if (arg0->unk4 == 0) {
    // If shading layer is fading in
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, arg0->unk1C);
    } else {
    // All other stages of the podium scene
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x64);
    }
}

// Podium scene, top line
void func_800A72FC(struct_8018D9E0_entry *arg0) {
    UNUSED s32 pad;
    s32 cupNameLength = (((f32) get_string_width(D_800E7500[gCupSelection]) * 1) + 10) / 2;
    s32 ccNameLength = (((f32) get_string_width(D_800E76CC[gCCSelection]) * 1) + 10) / 2;

    set_text_color(TEXT_YELLOW);
    draw_text(arg0->column - ccNameLength, arg0->row, D_800E7500[gCupSelection], 0, 1, 1);
    set_text_color(TEXT_YELLOW);
    draw_text(arg0->column + cupNameLength, arg0->row, D_800E76DC[gCCSelection], 0, 1, 1);
}

void func_800A7448(struct_8018D9E0_entry *arg0) {
    UNUSED s32 pad;
    s32 sp40;
    s32 sp3C;
    s32 thing = D_802874F5;
    if (thing >= 3) {
        set_text_color(TEXT_YELLOW);
        draw_text(arg0->column, arg0->row, D_800E7A98, 0, 0.75f, 0.75f);
    } else {
        sp40 = (s32) (((f32) (get_string_width(D_800E7A88[0]) + 5) * 0.75f) / 2);
        sp3C = (s32) (((f32) (get_string_width(D_800E7A88[thing + 1]) + 5) * 0.75f) / 2);
        set_text_color(TEXT_YELLOW);
        draw_text(arg0->column - sp3C, arg0->row, D_800E7A88[0], 0, 0.75f, 0.75f);
        set_text_color(TEXT_YELLOW);
        draw_text(arg0->column + sp40, arg0->row, D_800E7A88[thing + 1], 0, 0.75f, 0.75f);
    }
}

void func_800A75A0(struct_8018D9E0_entry *arg0) {
    UNUSED s32 pad;
    s32 topThree;

    if (D_802874F5 < 3) {
        topThree = 0;
    } else {
        topThree = 1;
    }

    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    draw_text(arg0->column, arg0->row, D_800E7A9C[topThree], 0, D_800F1F30, D_800F1F30);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit dacbf209f1bb5d4acaecaf1fefff331d60ffd80c
? convert_number_to_ascii(s32, s8 *);               /* extern */
? draw_text(s32, s32, s8 *, ?, f32, f32);           /* extern */
s32 get_string_width(s8 *);                         /* extern */
? set_text_color(s32);                              /* extern */
extern s8 D_802874F5;
static s8 *D_800E7AA4[9] = {
    "YOU PLACED",
    "    st",
    "    nd",
    "    rd",
    "    th",
    "    th",
    "    th",
    "    th",
    "    th",
}; /* const */

void func_800A761C(struct_8018D9E0_entry *arg0) {
    s32 sp48;
    s32 sp44;
    s8 sp3D;
    s8 sp3C;
    s8 sp38;
    s8 **sp34;
    f32 temp_f8;
    s32 temp_a0;
    s8 **temp_v1;

    temp_a0 = D_802874F5 + 1;
    sp38 = temp_a0;
    func_800A79F4(temp_a0, &sp3C);
    temp_f8 = (f32) (get_string_width(*D_800E7AA4) + 5) * 1.2f;
    temp_v1 = &D_800E7AA4[(s32) sp38];
    sp34 = temp_v1;
    sp48 = (s32) (temp_f8 / 2.0f);
    sp44 = (s32) (((f32) (get_string_width(*temp_v1) + 5) * 1.2f) / 2.0f);
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
    draw_text(arg0->column - sp44, arg0->row, *D_800E7AA4, 0, 1.2f, 1.2f);
    set_text_color((s32) gGlobalTimer % 3);
    draw_text(arg0->column + sp48, arg0->row, *sp34, 0, 1.2f, 1.2f);
    convert_number_to_ascii((s32) sp38, &sp3C);
    func_800939C8((arg0->column + sp48) - 0x18, arg0->row, &sp3D, 0, 2.0f, 2.0f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A761C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, s32, s32, s32, f32, f32); // extern
? func_800936B8(s32, s32, s32, s32, f32, f32); // extern
? set_text_color(s8); // extern
extern ? D_802850C0;
extern ? D_802854B0;

void func_800A7790(void *arg0) {
    s32 sp38;
    void *sp2C;
    f32 temp_f0;
    f32 temp_f0_2;
    s32 temp_t0;
    s8 temp_v1;
    void *temp_v0;

    temp_t0 = arg0->unk0 - 0x190;
    temp_v0 = (temp_t0 * 0x10) + &D_802850C0;
    sp2C = temp_v0;
    sp38 = temp_t0;
    set_text_color(temp_v0->unkD);
    temp_v1 = temp_v0->unkC;
    if ((temp_v1 == 0) || (temp_v1 != 1)) {
        temp_f0_2 = temp_v0->unk0;
        func_800936B8(arg0->unkC, arg0->unk10, *(&D_802854B0 + (temp_t0 * 4)), arg0->unk1C * temp_f0_2, arg0->unk24 * temp_f0_2, temp_f0_2);
        return;
    }
    temp_f0 = temp_v0->unk0;
    func_80093324(arg0->unkC, arg0->unk10, *(&D_802854B0 + (temp_t0 * 4)), arg0->unk1C * temp_f0, arg0->unk24 * temp_f0, temp_f0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A7790.s")
#endif

// Originally func_800A7894
// Presumes that "number" is a 2 digit number. Convert it to a string
void convert_number_to_ascii(s32 number, char *buffer) {
    buffer[0] = (number / 0xA) + 0x30;
    buffer[1] = (number % 0xA) + 0x30;
    // Terminator
    buffer[2] = 0;
}

// Originally func_800A78E0
// MK 64 doesn't show more then 2 digits for any given time
// (minute, second, centisecond)
// So, if timeRecord is greater than 10 minutes, just use '-'s
void write_dashes(char *buffer) {
    buffer[0] = 0x2D;
    buffer[1] = 0x2D;
    // Terminator
    buffer[2] = 0;
}

// Originally func_800A78F4
// timeRecord is assumed to be measured in centiseconds
void get_time_record_minutes(s32 timeRecord, char *buffer) {
    // If timeRecord is greater than 100 minutes, put '-'
    // in buffer
    if (timeRecord >= MAX_TIME) {
        write_dashes(buffer);
        return;
    }
    convert_number_to_ascii(timeRecord / 0x1770, buffer);
}

// Originally func_800A7944
// timeRecord is assumed to be measured in centiseconds
void get_time_record_seconds(s32 timeRecord, char *buffer) {
    // If timeRecord is greater than 100 minutes, put '-'
    // in buffer
    if (timeRecord >= MAX_TIME) {
        write_dashes(buffer);
        return;
    }
    convert_number_to_ascii((timeRecord / 0x64) % 0x3C, buffer);
}

// Originally func_800A79A4
// timeRecord is assumed to be measured in centiseconds
void get_time_record_centiseconds(s32 timeRecord, char *buffer) {
    // If timeRecord is greater than 100 minutes, put '-'
    // in buffer
    if (timeRecord >= MAX_TIME) {
        write_dashes(buffer);
        return;
    }
    convert_number_to_ascii(timeRecord % 0x64, buffer);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A79F4(s32 arg0, void *arg1) {
    arg1->unk0 = -0x5D;
    arg1->unk1 = (arg0 / 0xA) - 0x50;
    arg1->unk2 = -0x5D;
    arg1->unk3 = (arg0 % 0xA) - 0x50;
    arg1->unk4 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A79F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009E000(?);                                 /* extern */
? func_8009F5E0(? *);                               /* extern */
? func_800A954C(? *);                               /* extern */
? func_800A9710(? *);                               /* extern */
? func_800A97BC(? *);                               /* extern */
? func_800A9A98(? *);                               /* extern */
? func_800A9B9C(? *);                               /* extern */
? func_800A9C40(? *);                               /* extern */
? func_800A9D5C(? *);                               /* extern */
? func_800A9E58(? *);                               /* extern */
? func_800AA280(? *);                               /* extern */
? func_800AA2EC(? *);                               /* extern */
? func_800AA69C(? *);                               /* extern */
? func_800AAA9C(? *);                               /* extern */
? func_800AAB90(? *);                               /* extern */
? func_800AAC18(? *);                               /* extern */
? func_800AADD4(? *);                               /* extern */
? func_800AAE18(? *);                               /* extern */
? func_800AB020(? *);                               /* extern */
? func_800AB098(? *);                               /* extern */
? func_800AB164(? *);                               /* extern */
? func_800AB260(? *);                               /* extern */
? func_800AB290(? *);                               /* extern */
? func_800AB314(? *);                               /* extern */
? func_800AB904(? *);                               /* extern */
? func_800AB9B0(? *);                               /* extern */
? func_800ABAE8(? *);                               /* extern */
? func_800ABB24(? *);                               /* extern */
? func_800ABBCC(? *);                               /* extern */
? func_800ABC38(? *);                               /* extern */
? func_800ABEAC(? *);                               /* extern */
? func_800AC300(? *);                               /* extern */
? func_800AC324(? *);                               /* extern */
? func_800AC458(? *);                               /* extern */
? func_800AC978(? *);                               /* extern */
? func_800ACA14(? *);                               /* extern */
? func_800ACC50(? *);                               /* extern */
? func_800ACF40(? *);                               /* extern */
? func_800AD1A4(? *);                               /* extern */
? func_800AD2E8(? *);                               /* extern */
? func_800ADF48(? *);                               /* extern */
? func_800AE218(? *);                               /* extern */
? func_800AEC54(? *);                               /* extern */
? func_800AEDBC(? *);                               /* extern */
? func_800AEE90(? *);                               /* extern */
? func_800AEEBC(? *);                               /* extern */
? func_800AEEE8(? *);                               /* extern */
? func_800AEF14(? *);                               /* extern */
? func_800AEF74(? *);                               /* extern */
? func_800AF004(? *);                               /* extern */
? func_800AF1AC(? *);                               /* extern */
? func_800AF270(? *);                               /* extern */
? func_800AF480(? *);                               /* extern */
? func_800CA388(?);                                 /* extern */
? play_sound2(?);                                   /* extern */
extern ? D_8018D9E0;
extern ? D_8018DEE0;

void func_800A7A4C(s32 arg0) {
    ? *temp_s1;
    ? *temp_s1_2;
    f32 temp_f18;
    f64 temp_f0;
    s32 temp_s0;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_6;
    s8 temp_t1;
    s8 temp_t9;
    s8 temp_v0_3;
    s8 temp_v0_5;
    ? *phi_s1;
    s8 phi_v1;
    ? *phi_s1_2;
    s8 phi_v1_2;
    s32 phi_s0;

    phi_s1 = &D_8018D9E0;
    do {
        temp_v0 = phi_s1->unk0;
        phi_v1 = 0;
        phi_v1_2 = 0;
        if ((temp_v0 == 4) || (temp_v0 == 5) || (temp_v0 == 0xC7)) {
            if (arg0 != 0) {
                goto block_7;
            }
        } else if (arg0 == 0) {
block_7:
            phi_v1 = 1;
        }
        if (phi_v1 != 0) {
            if (temp_v0 >= 0x10F) {
                if (temp_v0 >= 0x131) {
                    switch (temp_v0) {              /* switch 1 */
                        func_800AF480(phi_s1);
                        break;
                    }
                } else {
                    switch (temp_v0) {              /* switch 2 */
                    case 0x12B:                     /* switch 2 */
                        func_800AF004(phi_s1);
                        break;
                    case 0x12C:                     /* switch 2 */
                    case 0x12D:                     /* switch 2 */
                    case 0x12E:                     /* switch 2 */
                    case 0x12F:                     /* switch 2 */
                        func_800AF1AC(phi_s1);
                        break;
                    case 0x130:                     /* switch 2 */
                        func_800AF270(phi_s1);
                        break;
                    }
                }
            } else if (temp_v0 >= 0x38) {
                switch (temp_v0) {                  /* switch 3 */
                case 0xFA:                          /* switch 3 */
                    temp_v0_2 = D_8018ED94;
                    if (temp_v0_2 < 0x50) {
                        D_800E8534 = 3.0f;
                    } else if (temp_v0_2 < 0x5A) {
                        temp_f0 = 0.0f;
                        if (temp_f0 < 1.0) {
                            D_800E8530 = temp_f0 + 0.1;
                        }
                        D_800E8534 = 3.0f + 0.1;
                    } else if (temp_v0_2 < 0xA0) {
                        D_800E8534 = 3.0f + 0.1;
                    } else if (temp_v0_2 < 0x190) {
                        D_800E8534 = 3.0f + 0.3;
                    }
                    temp_f18 = D_8018EDCC - 3.0f;
                    D_8018EDCC = temp_f18;
                    D_8018ED94 = temp_v0_2 + 1;
                    if (temp_f18 < -360.0f) {
                        D_8018EDCC = temp_f18 + 360.0f;
                    }
                    temp_t2 = phi_s1->unk1C + 1;
                    phi_s1->unk1C = temp_t2;
                    if (temp_t2 == 0xB4) {
                        func_8009E000(0x28);
                        func_800CA388(0x64);
                        D_8018EDE0 = 0;
                    }
                    if ((phi_s1->unk20 != 0) && (phi_s1->unk1C >= 3)) {
                        phi_s1->unk20 = 0;
                        play_sound2(0x49018008);
                    }
                    break;
                case 0xDA:                          /* switch 3 */
                    func_800A954C(phi_s1);
                    break;
                case 0xD6:                          /* switch 3 */
                    func_800A9710(phi_s1);
                    break;
                case 0xD4:                          /* switch 3 */
                    func_800A97BC(phi_s1);
                    break;
                case 0x53:                          /* switch 3 */
                case 0x54:                          /* switch 3 */
                case 0x55:                          /* switch 3 */
                case 0x56:                          /* switch 3 */
                    func_800AB164(phi_s1);
                    temp_v0_3 = D_8018EDEC;
                    if (temp_v0_3 != 1) {
                        if ((temp_v0_3 != 2) && (temp_v0_3 != 3)) {

                        } else {
                            func_800AB098(phi_s1);
                        }
                    } else {
                        func_800AB020(phi_s1);
                    }
                    break;
                case 0x58:                          /* switch 3 */
                case 0x59:                          /* switch 3 */
                case 0x5A:                          /* switch 3 */
                case 0x5B:                          /* switch 3 */
                    func_800AB260(phi_s1);
                    break;
                case 0x64:                          /* switch 3 */
                    func_800AB314(phi_s1);
                    break;
                case 0x5F:                          /* switch 3 */
                case 0x60:                          /* switch 3 */
                case 0x61:                          /* switch 3 */
                case 0x62:                          /* switch 3 */
                    func_800AB290(phi_s1);
                    break;
                case 0x65:                          /* switch 3 */
                case 0x66:                          /* switch 3 */
                    func_800AB904(phi_s1);
                    break;
                case 0x67:                          /* switch 3 */
                    func_800AB9B0(phi_s1);
                    break;
                case 0x78:                          /* switch 3 */
                case 0x79:                          /* switch 3 */
                case 0x7A:                          /* switch 3 */
                case 0x7B:                          /* switch 3 */
                case 0x8C:                          /* switch 3 */
                    func_800ABAE8(phi_s1);
                    break;
                case 0x8D:                          /* switch 3 */
                    func_800ABB24(phi_s1);
                    break;
                case 0x7C:                          /* switch 3 */
                case 0x7D:                          /* switch 3 */
                case 0x7E:                          /* switch 3 */
                case 0x7F:                          /* switch 3 */
                case 0x80:                          /* switch 3 */
                case 0x81:                          /* switch 3 */
                case 0x82:                          /* switch 3 */
                case 0x83:                          /* switch 3 */
                case 0x84:                          /* switch 3 */
                case 0x85:                          /* switch 3 */
                case 0x86:                          /* switch 3 */
                case 0x87:                          /* switch 3 */
                case 0x88:                          /* switch 3 */
                case 0x89:                          /* switch 3 */
                case 0x8A:                          /* switch 3 */
                case 0x8B:                          /* switch 3 */
                    func_800ABBCC(phi_s1);
                    break;
                case 0x96:                          /* switch 3 */
                    func_800ABC38(phi_s1);
                    break;
                case 0x97:                          /* switch 3 */
                    func_800ABEAC(phi_s1);
                    break;
                case 0x5E:                          /* switch 3 */
                    func_800AC300(phi_s1);
                    break;
                case 0xAA:                          /* switch 3 */
                    func_800AC324(phi_s1);
                    break;
                case 0xAB:                          /* switch 3 */
                    func_800AC458(phi_s1);
                    break;
                case 0xAC:                          /* switch 3 */
                    func_800ACA14(phi_s1);
                    break;
                case 0xAF:                          /* switch 3 */
                    func_800AC978(phi_s1);
                    break;
                case 0xB0:                          /* switch 3 */
                    func_800ACC50(phi_s1);
                    break;
                case 0xB1:                          /* switch 3 */
                case 0xB2:                          /* switch 3 */
                case 0xB3:                          /* switch 3 */
                case 0xB4:                          /* switch 3 */
                    func_800ACF40(phi_s1);
                    break;
                case 0xB9:                          /* switch 3 */
                    func_800AD1A4(phi_s1);
                    break;
                case 0xBA:                          /* switch 3 */
                    func_800AD2E8(phi_s1);
                    break;
                case 0xBC:                          /* switch 3 */
                    func_800AEC54(phi_s1);
                    break;
                case 0xC7:                          /* switch 3 */
                    func_800ADF48(phi_s1);
                    break;
                case 0xBD:                          /* switch 3 */
                    func_800AE218(phi_s1);
                    break;
                case 0xE6:                          /* switch 3 */
                    func_800AEDBC(phi_s1);
                    break;
                case 0xE8:                          /* switch 3 */
                    func_800AEE90(phi_s1);
                    break;
                case 0xE9:                          /* switch 3 */
                    func_800AEEBC(phi_s1);
                    break;
                case 0xEA:                          /* switch 3 */
                    func_800AEEE8(phi_s1);
                    break;
                case 0xBE:                          /* switch 3 */
                    func_800AEF14(phi_s1);
                    break;
                case 0x10E:                         /* switch 3 */
                    func_800AEF74(phi_s1);
                    break;
                }
            } else {
                switch (temp_v0) {                  /* switch 4 */
                case 0x5:                           /* switch 4 */
                    temp_v0_4 = phi_s1->unk4;
                    if (temp_v0_4 != 0) {
                        if (temp_v0_4 != 1) {

                        }
                        phi_s1->unk15 = 1;
                    } else if ((gControllerFive->button & 0x10) != 0) {
                        phi_s1->unk4 = 1;
                        play_sound2(0x4900801C);
                    } else {
                        phi_s1->unk15 = 0;
                    }
                    break;
                case 0xA:                           /* switch 4 */
                    func_800AA280(phi_s1);
                    break;
                case 0x10:                          /* switch 4 */
                case 0x11:                          /* switch 4 */
                    temp_t9 = gMainMenuSelectionDepth;
                    switch (temp_t9) {                                   /* switch 5 */
                    case OPTIONS_SELECTION:                              /* switch 5 */
                    case DATA_SELECTION:                                 /* switch 5 */
                    case PLAYER_NUM_SELECTION:                        /* switch 5 */
                        func_800A9B9C(phi_s1);
                        break;
                    case GAME_MODE_SELECTION:                            /* switch 5 */
                    case GAME_MODE_CC_OR_TIME_TRIALS_OPTIONS_SELECTION:  /* switch 5 */
                    case CONFIRM_OK_SELECTION:                         /* switch 5 */
                    case CONFIRM_OK_SELECTION_FROM_BACK_OUT:           /* switch 5 */
                    case TIME_TRAILS_DATA_SELECTION_FROM_BACK_OUT:       /* switch 5 */
                        func_800A9C40(phi_s1);
                        break;
                    }
                    break;
                case 0xF:                           /* switch 4 */
                    func_800AA280(phi_s1);
                    func_800A9A98(phi_s1);
                    break;
                case 0xB:                           /* switch 4 */
                case 0xC:                           /* switch 4 */
                case 0xD:                           /* switch 4 */
                case 0xE:                           /* switch 4 */
                    temp_t1 = gMainMenuSelectionDepth;
                    switch (temp_t1) {                                   /* switch 6 */
                    case OPTIONS_SELECTION:                              /* switch 6 */
                    case DATA_SELECTION:                                 /* switch 6 */
                    case PLAYER_NUM_SELECTION:                        /* switch 6 */
                        func_800A9B9C(phi_s1);
                        break;
                    case GAME_MODE_SELECTION:                            /* switch 6 */
                    case GAME_MODE_CC_OR_TIME_TRIALS_OPTIONS_SELECTION:  /* switch 6 */
                    case CONFIRM_OK_SELECTION:                         /* switch 6 */
                    case CONFIRM_OK_SELECTION_FROM_BACK_OUT:           /* switch 6 */
                    case TIME_TRAILS_DATA_SELECTION_FROM_BACK_OUT:       /* switch 6 */
                        func_800A9C40(phi_s1);
                        break;
                    }
                    func_800A9D5C(phi_s1);
                    break;
                case 0x12:                          /* switch 4 */
                case 0x13:                          /* switch 4 */
                case 0x14:                          /* switch 4 */
                case 0x15:                          /* switch 4 */
                case 0x16:                          /* switch 4 */
                case 0x17:                          /* switch 4 */
                case 0x18:                          /* switch 4 */
                case 0x19:                          /* switch 4 */
                    func_800A9E58(phi_s1);
                    break;
                case 0x1B:                          /* switch 4 */
                    func_800AA2EC(phi_s1);
                    break;
                case 0x34:                          /* switch 4 */
                case 0x35:                          /* switch 4 */
                case 0x36:                          /* switch 4 */
                case 0x37:                          /* switch 4 */
                    func_800AADD4(phi_s1);
                    break;
                case 0x2B:                          /* switch 4 */
                case 0x2C:                          /* switch 4 */
                case 0x2D:                          /* switch 4 */
                case 0x2E:                          /* switch 4 */
                case 0x2F:                          /* switch 4 */
                case 0x30:                          /* switch 4 */
                case 0x31:                          /* switch 4 */
                case 0x32:                          /* switch 4 */
                    func_800AAC18(phi_s1);
                    temp_t3 = phi_s1->unk0;
                    switch (temp_t3) {              /* switch 7 */
                        func_800AA69C(phi_s1);
                        break;
                    }
                    temp_v0_5 = D_8018EDEE;
                    if (temp_v0_5 != 1) {
                        if ((temp_v0_5 != 2) && (temp_v0_5 != 3)) {

                        } else {
                            func_800AAA9C(phi_s1);
                        }
                    } else {
                        func_800AAB90(phi_s1);
                    }
                    func_800AAE18(phi_s1);
                    break;
                case 0x33:                          /* switch 4 */
                case 0x5D:                          /* switch 3 */
                    func_800A9A98(phi_s1);
                    break;
                }
            }
        }
        temp_s1 = phi_s1 + 0x28;
        phi_s1 = temp_s1;
    } while (temp_s1 != &D_8018DEE0);
    phi_s0 = 0;
    do {
        phi_s1_2 = &D_8018D9E0;
loop_113:
        temp_v0_6 = phi_s1_2->unk0;
        if ((temp_v0_6 == 4) || (temp_v0_6 == 5) || (temp_v0_6 == 0xC7)) {
            if (arg0 != 0) {
                goto block_119;
            }
        } else if (arg0 == 0) {
block_119:
            phi_v1_2 = 1;
        }
        if ((phi_v1_2 != 0) && (phi_s0 == phi_s1_2->unk14)) {
            func_8009F5E0(phi_s1_2);
        }
        temp_s1_2 = phi_s1_2 + 0x28;
        phi_s1_2 = temp_s1_2;
        if (temp_s1_2 != &D_8018DEE0) {
            goto loop_113;
        }
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 != 0x10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A7A4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A7A4C(?); // extern

void func_800A8230(void) {
    func_800A7A4C(0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8230.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A7A4C(?); // extern

void func_800A8250(void) {
    func_800A7A4C(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8250.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959A0(void *, s32, s32, s32, s32); // extern
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80098FC8(void *, s32, s32, s32, s32); // extern
extern ? D_800E86AC;
extern ? D_800F2B60;
extern s8 gMainMenuSelectionDepth;
extern void *gDisplayListHead;

void func_800A8270(s32 arg0, void *arg1) {
    s32 temp_a3;
    s32 temp_s0;
    s32 temp_s2;
    s32 temp_s3;
    s32 temp_s3_2;
    s32 temp_s3_3;
    s32 temp_s4;
    s32 temp_s4_2;
    s32 temp_s4_3;
    s32 temp_t1;
    s32 temp_t6;
    s8 *temp_s7;
    s8 temp_v0_4;
    s8 temp_v0_5;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *phi_v0;
    s32 phi_s2;
    s32 phi_s3;
    s32 phi_s0;
    s32 phi_s4;
    void *phi_v0_2;

    temp_a3 = arg1->unk1C;
    if (temp_a3 < 0x20) {
        temp_v0 = gDisplayListHead;
        temp_t1 = arg1->unkC;
        temp_s0 = arg1->unk10;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xE7000000;
        temp_v0->unk4 = 0;
        temp_v0_2 = gDisplayListHead;
        gDisplayListHead = temp_v0_2 + 8;
        temp_v0_2->unk0 = 0xB900031D;
        temp_v0_2->unk4 = 0xF0A4000;
        temp_v0_3 = gDisplayListHead;
        temp_t6 = (temp_a3 << 6) / 0x40;
        gDisplayListHead = temp_v0_3 + 8;
        temp_v0_3->unk4 = 0xFFFCF279;
        temp_v0_3->unk0 = 0xFCFFFFFF;
        temp_s3 = temp_t1 + temp_t6;
        phi_s3 = temp_s3;
        if ((arg0 + 1) == D_8018EDF3) {
            temp_v0_4 = gMainMenuSelectionDepth;
            temp_s3_2 = temp_t1 + temp_t6;
            phi_s3 = temp_s3_2;
            if ((temp_v0_4 == OPTIONS_SELECTION) || (temp_v0_4 == DATA_SELECTION) || (temp_v0_4 == PLAYER_NUM_SELECTION)) {
                temp_s4_2 = (temp_t1 - temp_t6) + 0x3F;
                phi_v0 = func_800959A0(gDisplayListHead, temp_s3_2, temp_s0, temp_s4_2, temp_s0 + 0x35);
                phi_s4 = temp_s4_2;
            } else {
                temp_s4 = (temp_t1 - temp_t6) + 0x3F;
                temp_s3_3 = temp_t1 + temp_t6;
                phi_v0 = func_80098C18(gDisplayListHead, temp_s3_3, temp_s0, temp_s4, temp_s0 + 0x35, 0xFF, 0xF9, 0xDC, 0xFF);
                phi_s3 = temp_s3_3;
                phi_s4 = temp_s4;
            }
        } else {
            temp_s4_3 = (temp_t1 - temp_t6) + 0x3F;
            phi_v0 = func_80098FC8(gDisplayListHead, temp_s3, temp_s0, temp_s4_3, temp_s0 + 0x35);
            phi_s4 = temp_s4_3;
        }
        gDisplayListHead = phi_v0;
        temp_s7 = arg0 + &D_800F2B60;
        phi_s2 = 0;
        phi_s0 = temp_s0 + 0x41;
        if (*temp_s7 >= 0) {
            do {
                if ((phi_s2 == *(arg0 + &D_800E86AC)) && ((arg0 + 1) == D_8018EDF3) && (temp_v0_5 = gMainMenuSelectionDepth, ((temp_v0_5 < GAME_MODE_SELECTION) == 0))) {
                    if (temp_v0_5 == 4) {
                        phi_v0_2 = func_800959A0(gDisplayListHead, phi_s3, phi_s0, phi_s4, phi_s0 + 0x11);
                    } else {
                        phi_v0_2 = func_80098C18(gDisplayListHead, phi_s3, phi_s0, phi_s4, phi_s0 + 0x11, 0xFF, 0xF9, 0xDC, 0xFF);
                    }
                } else {
                    phi_v0_2 = func_80098C18(gDisplayListHead, phi_s3, phi_s0, phi_s4, phi_s0 + 0x11, 1, 1, 1, 0xFF);
                }
                gDisplayListHead = phi_v0_2;
                temp_s2 = phi_s2 + 1;
                phi_s2 = temp_s2;
                phi_s0 += 0x12;
            } while (*temp_s7 >= temp_s2);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8270.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800959A0(s32, s32, s32, s32, s32); // extern
s32 func_80098C18(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_0200487C;
extern ? D_02004B74;
extern ? D_02004E80;
extern s8 D_8018EDEC;
extern s8 gMainMenuSelectionDepth;
extern s8 D_8018EDEE;
extern s32 gDisplayListHead;

void func_800A8564(void *arg0) {
    s32 sp34;
    s32 sp30;
    s32 temp_a2;
    s32 temp_t0;
    s32 temp_v0;
    s32 temp_v0_4;
    s8 temp_v0_2;
    s8 temp_v0_3;
    void *temp_a3;
    void *temp_v0_5;
    s32 phi_a1;
    ? *phi_a0;
    s32 phi_v0;

    temp_v0 = arg0->unk0;
    temp_a3 = arg0;
    phi_a1 = 0;
    if (temp_v0 != 0xF) {
        if (temp_v0 != 0x33) {
            if (temp_v0 != 0x5D) {
                return;
            }
            phi_a0 = &D_02004E80;
            phi_a0 = &D_02004E80;
            if (D_8018EDEC == 3) {
                goto block_11;
            }
            goto block_12;
        }
        temp_v0_2 = D_8018EDEE;
        phi_a0 = &D_02004B74;
        phi_a0 = &D_02004B74;
        if ((temp_v0_2 == 2) || (temp_v0_2 == 3)) {
            goto block_11;
        }
        goto block_12;
    }
    temp_v0_3 = gMainMenuSelectionDepth;
    phi_a0 = &D_0200487C;
    phi_a0 = &D_0200487C;
    if ((temp_v0_3 == CONFIRM_OK_SELECTION) || (temp_v0_3 == CONFIRM_OK_SELECTION_FROM_BACK_OUT)) {
block_11:
        phi_a1 = 1;
    }
block_12:
    temp_v0_4 = temp_a3->unk1C;
    if (temp_v0_4 < 0x20) {
        sp34 = (temp_v0_4 << 5) / 0x40;
        sp30 = phi_a1;
        arg0 = temp_a3;
        temp_v0_5 = segmented_to_virtual(phi_a0);
        temp_t0 = arg0->unkC + temp_v0_5->unkC;
        temp_a2 = arg0->unk10 + temp_v0_5->unkE;
        if (phi_a1 != 0) {
            phi_v0 = func_800959A0(gDisplayListHead, temp_t0 + sp34, temp_a2, (temp_t0 - sp34) + 0x1E, temp_a2 + 0x12);
        } else {
            phi_v0 = func_80098C18(gDisplayListHead, temp_t0 + sp34, temp_a2, (temp_t0 - sp34) + 0x1E, temp_a2 + 0x12, 1, 1, 1, 0xFF);
        }
        gDisplayListHead = phi_v0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8564.s")
#endif

void func_800A86E8(struct_8018D9E0_entry *arg0) {
    gDisplayListHead = func_80098C18(gDisplayListHead, arg0->column, arg0->row, arg0->column + 0x64, arg0->row + 0x27, 1, 1, 1, 0xFF);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800936B8(s32, s32, s32, ?, f32, f32); // extern
? get_time_record_minutes(u32, ? *); // extern
? get_time_record_seconds(u32, ? *); // extern
? get_time_record_centiseconds(u32, ? *); // extern
u32 func_800B4E24(?); // extern
u32 func_800B4F2C(); // extern
? set_text_color(?); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern ? D_800E76A8;
extern ? D_800F0C98;
extern ? D_800F0C9C;
extern f32 D_800F24A0;
extern f32 D_800F24A4;

void func_800A874C(void *arg0) {
    ? sp58;
    f32 temp_f20;
    f32 temp_f22;
    u32 temp_s1;
    u32 phi_v0;
    u32 phi_s2;

    set_text_color(TEXT_GREEN);
    if (arg0->unk0 == 0x65) {
        phi_v0 = func_800B4E24(0);
    } else {
        phi_v0 = func_800B4F2C();
    }
    temp_s1 = phi_v0 & 0xFFFFF;
    get_time_record_minutes(temp_s1, &sp58);
    temp_f20 = D_800F24A0;
    temp_f22 = D_800F24A4;
    text_draw(arg0->unkC + 5, arg0->unk10 + 0x21, &sp58, 0, temp_f20, temp_f22);
    func_80093324(arg0->unkC + 0xE, arg0->unk10 + 0x21, &D_800F0C98, 0, temp_f20, temp_f22);
    get_time_record_seconds(temp_s1, &sp58);
    text_draw(arg0->unkC + 0x16, arg0->unk10 + 0x21, &sp58, 0, temp_f20, temp_f22);
    func_80093324(arg0->unkC + 0x20, arg0->unk10 + 0x21, &D_800F0C9C, 0, temp_f20, temp_f22);
    get_time_record_centiseconds(temp_s1, &sp58);
    text_draw(arg0->unkC + 0x29, arg0->unk10 + 0x21, &sp58, 0, temp_f20, temp_f22);
    if (temp_s1 < MAX_TIME) {
        phi_s2 = phi_v0 >> 0x14;
    } else {
        phi_s2 = 8;
    }
    func_800936B8(arg0->unkC + 0x60, arg0->unk10 + 0x21, *(&D_800E76A8 + (phi_s2 * 4)), 0, temp_f20, temp_f22);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A874C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959A0(void *, s32, s32, s32, s32); // extern
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern s8 D_8018EDEC;
extern s8 gCupSelection;
extern void *gDisplayListHead;

void func_800A890C(s32 arg0, void *arg1) {
    s32 temp_a2;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_t7;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *phi_v0;

    temp_t1 = arg1->unk1C;
    if (temp_t1 < 0x20) {
        temp_v0 = gDisplayListHead;
        temp_t0 = arg1->unkC;
        temp_a2 = arg1->unk10;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk4 = 0;
        temp_v0->unk0 = 0xE7000000;
        temp_v0_2 = gDisplayListHead;
        gDisplayListHead = temp_v0_2 + 8;
        temp_v0_2->unk0 = 0xB900031D;
        temp_v0_2->unk4 = 0xF0A4000;
        temp_v0_3 = gDisplayListHead;
        temp_t7 = (temp_t1 * 0x41) / 0x40;
        gDisplayListHead = temp_v0_3 + 8;
        temp_v0_3->unk0 = 0xFCFFFFFF;
        temp_v0_3->unk4 = 0xFFFCF279;
        if (arg0 == gCupSelection) {
            if (D_8018EDEC == 1) {
                phi_v0 = func_800959A0(gDisplayListHead, temp_t0 + temp_t7, temp_a2, (temp_t0 - temp_t7) + 0x40, temp_a2 + 0x27);
            } else {
                phi_v0 = func_80098C18(gDisplayListHead, temp_t0 + temp_t7, temp_a2, (temp_t0 - temp_t7) + 0x40, temp_a2 + 0x27, 0xFF, 0xF9, 0xDC, 0xFF);
            }
        } else {
            phi_v0 = func_80098C18(gDisplayListHead, temp_t0 + temp_t7, temp_a2, (temp_t0 - temp_t7) + 0x40, temp_a2 + 0x27, 1, 1, 1, 0xFF);
        }
        gDisplayListHead = phi_v0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A890C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959A0(void *, s32, s32, s32, s32); // extern
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern ? D_800E7208;
extern s8 D_8018EDEC;
extern void *gDisplayListHead;

void func_800A8A98(void *arg0) {
    s32 temp_s2;
    s32 temp_s3;
    s32 temp_s4;
    s8 temp_v0_4;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    s32 phi_s4;
    ? *phi_s0;
    void *phi_v0;

    temp_v0 = gDisplayListHead;
    temp_s2 = arg0->unkC;
    temp_s3 = arg0->unk10;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk0 = 0xE7000000;
    temp_v0->unk4 = 0;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xB900031D;
    temp_v0_2->unk4 = 0xF0A4000;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0xFCFFFFFF;
    temp_v0_3->unk4 = 0xFFFCF279;
    phi_s4 = 0;
    phi_s0 = &D_800E7208;
    do {
        if ((phi_s4 == gCupCourseSelection) && (temp_v0_4 = D_8018EDEC, ((temp_v0_4 < 2) == 0)) && (gModeSelection != GRAND_PRIX)) {
            if ((temp_v0_4 == 2) || (temp_v0_4 == 4)) {
                phi_v0 = func_800959A0(gDisplayListHead, phi_s0->unk0 + temp_s2, phi_s0->unk2 + temp_s3, phi_s0->unk8 + temp_s2, phi_s0->unkA + temp_s3);
            } else {
                phi_v0 = func_80098C18(gDisplayListHead, phi_s0->unk0 + temp_s2, phi_s0->unk2 + temp_s3, phi_s0->unk8 + temp_s2, phi_s0->unkA + temp_s3, 0xFF, 0xF9, 0xDC, 0xFF);
            }
        } else {
            phi_v0 = func_80098C18(gDisplayListHead, phi_s0->unk0 + temp_s2, phi_s0->unk2 + temp_s3, phi_s0->unk8 + temp_s2, phi_s0->unkA + temp_s3, 1, 1, 1, 0xFF);
        }
        gDisplayListHead = phi_v0;
        temp_s4 = phi_s4 + 1;
        phi_s4 = temp_s4;
        phi_s0 += 0x10;
    } while (temp_s4 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8A98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_800AAEF4(?); // extern
extern ? D_800E7208;
extern s8 D_8018EDEC;
extern ? D_E6FFFFFC;
extern void *gDisplayListHead;

void func_800A8CA4(void *arg0) {
    s32 temp_s0;
    s32 temp_s2;
    s32 temp_s3;
    s32 temp_t6;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v1;
    void *temp_v1_2;
    void *temp_v1_3;
    s32 phi_s0;

    temp_v0 = func_800AAEF4(0x64);
    temp_v1 = gDisplayListHead;
    temp_s2 = arg0->unkC;
    temp_s3 = arg0->unk10;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk0 = &D_E6FFFFFC;
    temp_v1->unk4 = 0;
    temp_v1_2 = gDisplayListHead;
    gDisplayListHead = temp_v1_2 + 8;
    temp_v1_2->unk0 = 0xB900031D;
    temp_v1_2->unk4 = 0xF0A4000;
    temp_v1_3 = gDisplayListHead;
    gDisplayListHead = temp_v1_3 + 8;
    temp_v1_3->unk0 = 0xFCFFFFFF;
    temp_v1_3->unk4 = 0xFFFCF279;
    if (gModeSelection == GRAND_PRIX) {
        phi_s0 = 0;
        if (D_8018EDEC != 3) {
            do {
                temp_t6 = temp_v0->unk1C;
                temp_v0_2 = &D_800E7208 + (phi_s0 * 0x10);
                if ((temp_t6 < 0) && ((temp_t6 & 3) != 0)) {

                }
                if (phi_s0 != (temp_t6 & 3)) {
                    gDisplayListHead = draw_box(gDisplayListHead, temp_v0_2->unk0 + temp_s2, temp_v0_2->unk2 + temp_s3, temp_v0_2->unk8 + temp_s2, temp_v0_2->unkA + temp_s3, 0, 0, 0, 0x64);
                }
                temp_s0 = phi_s0 + 1;
                phi_s0 = temp_s0;
            } while (temp_s0 != 4);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8CA4.s")
#endif

void func_800A8E14(UNUSED struct_8018D9E0_entry *unused) {
    set_text_color(TEXT_YELLOW);
    draw_text(0x98, 0x44, D_800E77A8, 0, 1.0f, 1.0f);
    func_80093324(0x17, 0x58, D_800E77AC, 0, D_800F24A8, D_800F24AC);
    func_80093324(0x17, 0x6A, D_800E77B0, 0, D_800F24B0, D_800F24B4);
}

void func_800A8EC0(struct_8018D9E0_entry *arg0) {
    if (arg0->unk20 != 0) {
        func_8009A76C(arg0->D_8018DEE0_index, arg0->column, arg0->row, -1);
        set_text_color(TEXT_YELLOW);
        func_80093324(arg0->column + 0x20, arg0->row + 0x28, D_800E7678[arg0->unk20], 0, D_800F24B8, D_800F24B8);
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80098FC8(s32, s32, s16, s32, s32); // extern
s32 func_8009BA74(s32, ?, ?, ?); // extern
s32 func_8009C204(s32, s32, s32, s16, s32); // extern
s32 func_800B639C(s32); // extern
void *segmented_to_virtual(segment_address_t); // extern
extern ? D_02004A0C;
extern ? D_800E7168;
extern s8 D_8018EDEC;
extern s8 gCupSelection;
extern s32 gDisplayListHead;

void func_800A8F48(s32 arg0) {
    s16 temp_s0;
    s16 temp_v1;
    s32 temp_s1;
    s32 temp_s2;
    s32 temp_v0_2;
    s8 temp_v0;
    void *temp_v0_3;
    s32 phi_s1;

    temp_v0 = D_8018EDEC;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {

        }
        if (func_800B639C((gCupSelection * 4) + gCupCourseSelection) >= 0) {
            temp_v0_2 = func_80098FC8(gDisplayListHead, 0x57, 0x70, 0x96, 0x81);
            gDisplayListHead = temp_v0_2;
            gDisplayListHead = func_8009BA74(temp_v0_2, 0x2004A0C, 0x57, 0x70);
        }
        return;
    }
    phi_s1 = 0;
    do {
        if (func_800B639C((gCupSelection * 4) + phi_s1) >= 0) {
            temp_v0_3 = &D_800E7168 + (phi_s1 * 8);
            temp_v1 = temp_v0_3->unk0;
            temp_s0 = temp_v0_3->unk2;
            temp_s2 = temp_v1 + 0x20;
            gDisplayListHead = func_80098FC8(gDisplayListHead, temp_s2, temp_s0, temp_v1 + 0x3F, temp_s0 + 9);
            gDisplayListHead = func_8009C204(gDisplayListHead, segmented_to_virtual(&D_02004A0C), temp_s2, temp_s0, 2);
        }
        temp_s1 = phi_s1 + 1;
        phi_s1 = temp_s1;
    } while (temp_s1 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8F48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern void *gDisplayListHead;

void func_800A90D4(s32 arg0, void *arg1) {
    s32 temp_a2;
    s32 temp_t1;
    s32 temp_t5;
    s32 temp_t7;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;

    temp_t5 = arg1->unk1C;
    if (temp_t5 < 0x20) {
        temp_v0 = gDisplayListHead;
        temp_t1 = arg1->unkC;
        temp_a2 = arg1->unk10;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xE7000000;
        temp_v0->unk4 = 0;
        temp_v0_2 = gDisplayListHead;
        temp_t7 = (temp_t5 * 0x41) / 0x40;
        gDisplayListHead = temp_v0_2 + 8;
        temp_v0_2->unk4 = 0xF0A4000;
        temp_v0_2->unk0 = 0xB900031D;
        temp_v0_3 = gDisplayListHead;
        gDisplayListHead = temp_v0_3 + 8;
        temp_v0_3->unk4 = 0xFFFCF279;
        temp_v0_3->unk0 = 0xFCFFFFFF;
        gDisplayListHead = func_80098C18(gDisplayListHead, temp_t1 + temp_t7, temp_a2, (temp_t1 - temp_t7) + 0x40, temp_a2 + 0x27, 1, 1, 1, 0xFF);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A90D4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A9208(); // extern
? func_800A9278(s32, s32); // extern

void func_800A91D8(s32 arg0, s32 arg2) {
    func_800A9208();
    func_800A9278(arg0, arg2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A91D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A9208(void *arg0, s32 arg1) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 phi_v0;

    temp_v1 = arg0->unkC;
    temp_v0 = arg1 - temp_v1;
    phi_v0 = temp_v0;
    if (temp_v0 != 0) {
        if (temp_v0 > 0) {
            temp_v0_2 = (temp_v0 / 4) + 1;
            phi_v0 = temp_v0_2;
            if (temp_v0_2 >= 0x11) {
                phi_v0 = 0x10;
            }
        } else {
            temp_v0_3 = (temp_v0 / 4) - 1;
            phi_v0 = temp_v0_3;
            if (temp_v0_3 < -0x10) {
                phi_v0 = -0x10;
            }
        }
    }
    arg0->unkC = temp_v1 + phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9208.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A9278(void *arg0, s32 arg1) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 phi_v0;

    temp_v1 = arg0->unk10;
    temp_v0 = arg1 - temp_v1;
    phi_v0 = temp_v0;
    if (temp_v0 != 0) {
        if (temp_v0 > 0) {
            temp_v0_2 = (temp_v0 / 4) + 1;
            phi_v0 = temp_v0_2;
            if (temp_v0_2 >= 0x11) {
                phi_v0 = 0x10;
            }
        } else {
            temp_v0_3 = (temp_v0 / 4) - 1;
            phi_v0 = temp_v0_3;
            if (temp_v0_3 < -0x10) {
                phi_v0 = -0x10;
            }
        }
    }
    arg0->unk10 = temp_v1 + phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9278.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A92E8(void *arg0, s32 arg1) {
    s32 temp_t0;
    s32 temp_t7;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v0_3;
    s32 phi_v0_4;

    temp_v1 = arg0->unkC;
    temp_v0 = arg1 - temp_v1;
    if (temp_v0 != 0) {
        if (temp_v0 > 0) {
            temp_v0_2 = (temp_v0 / 4) + 1;
            phi_v0 = temp_v0_2;
            if (temp_v0_2 >= 0x11) {
                phi_v0 = 0x10;
            }
            phi_v0_2 = phi_v0;
            if (phi_v0 < 8) {
                phi_v0_2 = 8;
            }
            temp_t7 = temp_v1 + phi_v0_2;
            arg0->unkC = temp_t7;
            if (arg1 < temp_t7) {
                arg0->unkC = arg1;
                return;
            }
            // Duplicate return node #14. Try simplifying control flow for better match
            return;
        }
        temp_v0_3 = (temp_v0 / 4) - 1;
        phi_v0_3 = temp_v0_3;
        if (temp_v0_3 < -0x10) {
            phi_v0_3 = -0x10;
        }
        phi_v0_4 = phi_v0_3;
        if (phi_v0_3 < -8) {
            phi_v0_4 = -8;
        }
        temp_t0 = temp_v1 + phi_v0_4;
        arg0->unkC = temp_t0;
        if (temp_t0 < arg1) {
            arg0->unkC = arg1;
        }
        // Duplicate return node #14. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A92E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A940C(void *arg0, s32 arg1) {
    s32 temp_lo;
    s32 temp_t7;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v1;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v0_3;
    s32 phi_v0_4;

    temp_v1 = arg0->unkC;
    temp_v0 = arg1 - temp_v1;
    if (temp_v0 != 0) {
        temp_lo = 0xC8 / temp_v0;
        phi_v0 = temp_lo;
        phi_v0_3 = temp_lo;
        if (temp_lo > 0) {
            if (temp_lo >= 0x19) {
                phi_v0 = 0x18;
            }
            phi_v0_2 = phi_v0;
            if (phi_v0 < 0x10) {
                phi_v0_2 = 0x10;
            }
            temp_t7 = temp_v1 + phi_v0_2;
            arg0->unkC = temp_t7;
            if (arg1 < temp_t7) {
                arg0->unkC = arg1;
                return;
            }
            // Duplicate return node #14. Try simplifying control flow for better match
            return;
        }
        if (temp_lo < -0x18) {
            phi_v0_3 = -0x18;
        }
        phi_v0_4 = phi_v0_3;
        if (phi_v0_3 >= -0xF) {
            phi_v0_4 = -0x10;
        }
        temp_t9 = temp_v1 + phi_v0_4;
        arg0->unkC = temp_t9;
        if (temp_t9 < arg1) {
            arg0->unkC = arg1;
        }
        // Duplicate return node #14. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A940C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A94C8(void *arg0, s32 arg1, s32 arg2) {
    s32 temp_v0;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 phi_v1;

    temp_v0 = arg0->unkC;
    temp_v1 = arg1 - temp_v0;
    phi_v1 = temp_v1;
    if (arg1 == temp_v0) {
        arg0->unkC = temp_v0 + arg2;
        return;
    }
    if (temp_v1 != 0) {
        if (temp_v1 > 0) {
            temp_v1_2 = (temp_v1 / 4) + 1;
            phi_v1 = temp_v1_2;
            if (temp_v1_2 >= 0x11) {
                phi_v1 = 0x10;
            }
        } else {
            temp_v1_3 = (temp_v1 / 4) - 1;
            phi_v1 = temp_v1_3;
            if (temp_v1_3 < -0x10) {
                phi_v1 = -0x10;
            }
        }
    }
    arg0->unkC = temp_v0 - phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A94C8.s")
#endif

void func_800A954C(struct_8018D9E0_entry *arg0) {
    // Cycle lasts 26 (0x1A) frames
    if (arg0->unk4 == 0) {
    // Move highlight from yellow to red
        arg0->unk20 = (s32) (u32) ((((f32) (0xC - arg0->unk1C) * 127.0f) / 12.0f) + 128.0f);
    } else {
    // Move highlight from red to  yellow
        arg0->unk20 = (s32) (u32) ((((f64) (f32) arg0->unk1C * D_800F24C0) / 12.0) + 128.0);
    }
    arg0->unk1C++;
    if (arg0->unk1C >= 0xC) {
    // Every 13 (0xC) frames reverse direction
        arg0->unk1C = 0;
        arg0->unk4 ^= 1;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A594(s32, ?, s32, void *);               /* extern */
static ? D_800E7D34;                                /* unable to generate initializer; const */

void func_800A9710(void *arg0) {
    s8 temp_t6;
    s32 phi_v0;

    switch (gControllerPakMenuSelection) {
    case CONTROLLER_PAK_MENU_ERASE:
    case CONTROLLER_PAK_MENU_QUIT:
        phi_v0 = 1;
        break;
    case CONTROLLER_PAK_MENU_GO_TO_ERASING:
    case CONTROLLER_PAK_MENU_ERASING:
        phi_v0 = 5;
        break;
    case CONTROLLER_PAK_MENU_ERASE_ERROR_NOT_ERASED:
        phi_v0 = 2;
        break;
    case CONTROLLER_PAK_MENU_ERASE_ERROR_NO_PAK:
        phi_v0 = 3;
        break;
    case CONTROLLER_PAK_MENU_ERASE_ERROR_PAK_CHANGED:
        phi_v0 = 4;
        break;
    default:
        phi_v0 = 0;
        break;
    }
    if (phi_v0 != arg0->unk4) {
        arg0->unk4 = phi_v0;
        arg0 = arg0;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7D34 + (phi_v0 * 4)), MIPS2C_ERROR(Read from unset register $a1)), arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9710.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E86C4;
extern ? D_800E86C6;
extern ? D_800E86C7;
extern ? D_800E86C8;
extern ? D_800E86C9;
extern ? D_800E86CA;
extern ? D_800E86CB;
extern ? D_800E86CC;
extern s8 D_800E86D0;

void func_800A97BC(void *arg0) {
    s32 temp_t4;
    s32 temp_t7;
    s8 temp_v0;
    s8 temp_v0_2;
    s8 temp_v0_3;
    s8 temp_v0_4;
    s8 temp_v0_5;
    s8 temp_v0_6;
    s8 temp_v0_7;
    s8 temp_v0_8;
    s8 temp_v0_9;
    u32 temp_v1;
    u32 temp_v1_2;
    u32 phi_v1;
    u32 phi_v1_2;

    temp_v0 = D_800E86D0;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            D_800E86D0 = 0;
            return;
        }
        temp_t4 = arg0->unk10 + 2;
        arg0->unk10 = temp_t4;
        if (temp_t4 >= 0x73) {
            arg0->unk10 = 0x69;
            D_800E86D0 = 0;
            phi_v1 = &D_800E86CC;
            do {
                if (phi_v1 >= &D_800E86C6) {
                    phi_v1->unk0 = phi_v1->unk-1;
                } else {
                    temp_v0_2 = phi_v1->unk1;
                    if ((temp_v0_2 == 1) || (temp_v0_2 == 0)) {
                        phi_v1->unk0 = 0;
                    } else {
                        phi_v1->unk0 = temp_v0_2 - 1;
                    }
                }
                if (phi_v1 >= &D_800E86C7) {
                    phi_v1->unk-1 = phi_v1->unk-2;
                } else {
                    temp_v0_3 = phi_v1->unk0;
                    if ((temp_v0_3 == 1) || (temp_v0_3 == 0)) {
                        phi_v1->unk-1 = 0;
                    } else {
                        phi_v1->unk-1 = temp_v0_3 - 1;
                    }
                }
                if (phi_v1 >= &D_800E86C8) {
                    phi_v1->unk-2 = phi_v1->unk-3;
                } else {
                    temp_v0_4 = phi_v1->unk-1;
                    if ((temp_v0_4 == 1) || (temp_v0_4 == 0)) {
                        phi_v1->unk-2 = 0;
                    } else {
                        phi_v1->unk-2 = temp_v0_4 - 1;
                    }
                }
                if (phi_v1 >= &D_800E86C9) {
                    phi_v1->unk-3 = phi_v1->unk-4;
                } else {
                    temp_v0_5 = phi_v1->unk-2;
                    if ((temp_v0_5 == 1) || (temp_v0_5 == 0)) {
                        phi_v1->unk-3 = 0;
                    } else {
                        phi_v1->unk-3 = temp_v0_5 - 1;
                    }
                }
                temp_v1 = phi_v1 - 4;
                phi_v1 = temp_v1;
            } while (temp_v1 != &D_800E86C4);
            D_800E86C4.unk8 = 0;
            D_800E86C4.unk0 = D_800E86C4.unk8;
        }
        // Duplicate return node #59. Try simplifying control flow for better match
        return;
    }
    temp_t7 = arg0->unk10 - 2;
    arg0->unk10 = temp_t7;
    if (temp_t7 < 0x60) {
        arg0->unk10 = 0x69;
        D_800E86D0 = 0;
        phi_v1_2 = &D_800E86C4;
        do {
            if (phi_v1_2 < &D_800E86CB) {
                phi_v1_2->unk0 = phi_v1_2->unk1;
            } else {
                temp_v0_6 = phi_v1_2->unk-1;
                if ((temp_v0_6 == 0x10) || (temp_v0_6 == 0)) {
                    phi_v1_2->unk0 = 0;
                } else {
                    phi_v1_2->unk0 = temp_v0_6 + 1;
                }
            }
            if (phi_v1_2 < &D_800E86CA) {
                phi_v1_2->unk1 = phi_v1_2->unk2;
            } else {
                temp_v0_7 = phi_v1_2->unk0;
                if ((temp_v0_7 == 0x10) || (temp_v0_7 == 0)) {
                    phi_v1_2->unk1 = 0;
                } else {
                    phi_v1_2->unk1 = temp_v0_7 + 1;
                }
            }
            if (phi_v1_2 < &D_800E86C9) {
                phi_v1_2->unk2 = phi_v1_2->unk3;
            } else {
                temp_v0_8 = phi_v1_2->unk1;
                if ((temp_v0_8 == 0x10) || (temp_v0_8 == 0)) {
                    phi_v1_2->unk2 = 0;
                } else {
                    phi_v1_2->unk2 = temp_v0_8 + 1;
                }
            }
            if (phi_v1_2 < &D_800E86C8) {
                phi_v1_2->unk3 = phi_v1_2->unk4;
            } else {
                temp_v0_9 = phi_v1_2->unk2;
                if ((temp_v0_9 == 0x10) || (temp_v0_9 == 0)) {
                    phi_v1_2->unk3 = 0;
                } else {
                    phi_v1_2->unk3 = temp_v0_9 + 1;
                }
            }
            temp_v1_2 = phi_v1_2 + 4;
            phi_v1_2 = temp_v1_2;
        } while (temp_v1_2 != &D_800E86CC);
        D_800E86C4.unk8 = 0;
        D_800E86C4.unk0 = D_800E86C4.unk8;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A97BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800F0C9C;
extern ? D_800F0CA7;
extern ? D_800F0CAB;
extern s8 D_8018EDEC;
extern s8 gMainMenuSelectionDepth;
extern s8 D_8018EDEE;

void func_800A9A98(void *arg0) {
    s32 temp_t2;
    s32 temp_t4;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 phi_v0;

    temp_v0 = arg0->unk0;
    if (temp_v0 != 0xF) {
        if (temp_v0 != 0x33) {
            if (temp_v0 != 0x5D) {
                phi_v0 = sp4;
            } else {
                phi_v0 = *(&D_800F0CAB + D_8018EDEC);
            }
        } else {
            phi_v0 = *(&D_800F0CA7 + D_8018EDEE);
        }
    } else {
        phi_v0 = *(&D_800F0C9C + 3 + gMainMenuSelectionDepth);
    }
    if (phi_v0 != 0) {
        if (phi_v0 != 1) {
            if (phi_v0 != 2) {
                if (phi_v0 != 3) {
                    return;
                }
                temp_v0_2 = arg0->unk1C;
                temp_t4 = temp_v0_2 + 2;
                if (temp_v0_2 < 0x20) {
                    arg0->unk1C = temp_t4;
                    if (temp_t4 >= 0x20) {
                        arg0->unk1C = 0x20;
                    }
                }
                // Duplicate return node #20. Try simplifying control flow for better match
                return;
            }
            temp_v0_3 = arg0->unk1C;
            if ((temp_v0_3 > 0) && (temp_t2 = (temp_v0_3 - (temp_v0_3 / 0xC)) - 2, arg0->unk1C = temp_t2, (temp_t2 < 0))) {
                arg0->unk1C = 0;
                return;
            }
            return;
        }
        arg0->unk1C = 0x20;
        return;
    }
    arg0->unk1C = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9A98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800AA280();                                  /* extern */

void func_800A9B9C(void *arg0) {
    s32 temp_t0;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        func_800AA280();
        return;
    case 1:
        func_800AA280();
        arg0->unk4 = 4;
        /* fallthrough */
    case 4:
        temp_v0 = arg0->unk1C;
        if (temp_v0 > 0) {
            temp_t0 = (temp_v0 - (temp_v0 / 12)) - 2;
            arg0->unk1C = temp_t0;
            if (temp_t0 < 0) {
                arg0->unk1C = 0;
                return;
            }
        default:
            return;
        }
        arg0->unk1C = 0;
        arg0->unk4 = 0;
        return;
    case 2:
        arg0->unk4 = 3;
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9B9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800AA280();                                  /* extern */

void func_800A9C40(void *arg0) {
    s32 temp_t7;
    s32 temp_v0_2;
    s8 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        func_800AA280();
        if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
            arg0->unk4 = 2;
            return;
        }
        arg0->unk4 = 1;
        return;
    case 4:
        if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
            arg0->unk4 = 2;
            arg0->unk1C = 0;
            return;
        }
        arg0->unk4 = 1;
    case 1:
        func_800AA280();
        temp_v0 = gMainMenuSelectionDepth;
        if ((temp_v0 == CONFIRM_OK_SELECTION_FROM_BACK_OUT) || (temp_v0 == TIME_TRAILS_DATA_SELECTION_FROM_BACK_OUT)) {
            arg0->unk1C = 0x20;
            return;
        }
        temp_v0_2 = arg0->unk1C;
        temp_t7 = temp_v0_2 + 2;
        if ((temp_v0_2 < 0x20) && (arg0->unk1C = temp_t7, ((temp_t7 < 0x20) == 0))) {
            arg0->unk1C = 0x20;
            return;
        }
    default:
        return;
    case 3:
        if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
            arg0->unk4 = 2;
        }
        /* Duplicate return node #16. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9C40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A91D8(s16, s16);                          /* extern */
static ? D_800E70A0;                                /* unable to generate initializer; const */

void func_800A9D5C(void *arg0) {
    void *sp1C;
    s8 temp_v0;
    u32 temp_t1;
    void *temp_v0_2;

    if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
        arg0->unk14 = 0xA;
    } else {
        arg0->unk14 = 6;
    }
    temp_t1 = arg0->unk4;
    switch (temp_t1) {
    case 2:
        temp_v0 = gMainMenuSelectionDepth;
        if ((temp_v0 == CONFIRM_OK_SELECTION_FROM_BACK_OUT) || (temp_v0 == TIME_TRAILS_DATA_SELECTION_FROM_BACK_OUT)) {
            arg0->unkC = 0x80;
            arg0->unk10 = 0x3E;
            return;
        }
        func_800A91D8(0x80, 0x3E);
        return;
    case 3:
        temp_v0_2 = (arg0->unk0 * 8) - 0x50 + &D_800E70A0;
        sp1C = temp_v0_2;
        func_800A91D8(temp_v0_2->unk0, temp_v0_2->unk2);
        if ((temp_v0_2->unk0 == arg0->unkC) && (temp_v0_2->unk2 == arg0->unk10)) {
            arg0->unk4 = 0;
        }
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9D5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A91D8(void *, s32, s32);                  /* extern */
? func_800A92E8(void *, s32);                       /* extern */
static ? D_800E70E8;                                /* unable to generate initializer; const */
static ? gGameModeRowSelectionForNumPlayers;                                /* unable to generate initializer; const */
static ? gGameModeFromNumPlayersAndRowSelection;                                /* unable to generate initializer; const */

void func_800A9E58(void *arg0) {
    void *sp2C;
    s16 *sp28;
    s32 sp24;
    s32 sp20;
    s32 sp1C;
    s16 *temp_v1_3;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_t2_2;
    s32 temp_t5_2;
    s32 temp_t6;
    s32 temp_v1;
    s8 temp_a2;
    s8 temp_t2;
    s8 temp_t5;
    s8 temp_t9;
    s8 temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v1_2;
    void *temp_v1_4;
    s32 phi_a3;

    temp_t6 = arg0->unk0;
    switch (temp_t6) {                              /* switch 1 */
    case 18:                                        /* switch 1 */
    case 19:                                        /* switch 1 */
    case 20:                                        /* switch 1 */
    case 21:                                        /* switch 1 */
        sp24 = 0x12;
        sp1C = 2;
        sp20 = 0;
        break;
    case 22:                                        /* switch 1 */
    case 23:                                        /* switch 1 */
        sp24 = 0x16;
        sp1C = 2;
        phi_a3 = 2;
block_5:
        sp20 = phi_a3;
        break;
    case 24:                                        /* switch 1 */
    case 25:                                        /* switch 1 */
        sp24 = 0x18;
        sp1C = 1;
        phi_a3 = 1;
        goto block_5;
    }
    temp_v0 = D_8018EDF3;
    temp_v1 = arg0->unk4;
    temp_a2 = *(&gGameModeRowSelectionForNumPlayers + temp_v0);
    temp_a1 = *(&gGameModeFromNumPlayersAndRowSelection + ((temp_v0 * 0xC) + (temp_a2 * 4)));
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {
                return;
            }
            temp_t9 = gMainMenuSelectionDepth;
            switch (temp_t9) {                      /* switch 4 */
                if ((temp_a1 != sp20) && (temp_a1 != sp1C)) {
                    arg0->unk15 = 0;
                    goto block_37;
                }
                if (arg0->unk20 != temp_a2) {
                    arg0->unk4 = 0;
                }
                temp_v0_2 = func_800AAE68(arg0, temp_a1, temp_a2);
                temp_v1_2 = (arg0->unk0 * 8) + -(sp24 * 8) + &D_800E70E8;
                temp_a1_2 = temp_v0_2->unkC + temp_v1_2->unk0;
                arg0->unkC = temp_a1_2;
                arg0->unk10 = temp_v0_2->unk10 + arg0->unk1C;
                sp2C = temp_v0_2;
                func_800A91D8(arg0, temp_a1_2, (*(&gGameModeRowSelectionForNumPlayers + D_8018EDF3) * 0x12) + temp_v0_2->unk10 + temp_v1_2->unk2);
                arg0->unk1C = arg0->unk10 - sp2C->unk10;
                return;
            default:                                /* switch 4 */
                arg0->unk15 = 0;
                goto block_37;
            }
        } else {
            temp_t2 = gMainMenuSelectionDepth;
            switch (temp_t2) {                      /* switch 3 */
                if ((temp_a1 != sp20) && (temp_a1 != sp1C)) {
                    arg0->unk15 = 0;
block_37:
                    arg0->unk4 = 0;
                    /* Duplicate return node #38. Try simplifying control flow for better match */
                    return;
                }
                if (arg0->unk20 != temp_a2) {
                    arg0->unk4 = 0;
                }
                temp_v0_3 = func_800AAE68(arg0, temp_a1, temp_a2);
                arg0->unkC = temp_v0_3->unkC + arg0->unk1C;
                temp_v1_3 = (arg0->unk0 * 8) + -(sp24 * 8) + &D_800E70E8;
                sp2C = temp_v0_3;
                sp28 = temp_v1_3;
                func_800A92E8(arg0, temp_v0_3->unkC + *temp_v1_3);
                temp_t2_2 = arg0->unkC - sp2C->unkC;
                arg0->unk1C = temp_t2_2;
                if (*temp_v1_3 == temp_t2_2) {
                    arg0->unk4 = 2;
                    arg0->unk1C = arg0->unk10 - sp2C->unk10;
                    return;
                }
                return;
            default:                                /* switch 3 */
                arg0->unk15 = 0;
                goto block_37;
            }
        }
    } else {
        if ((temp_a1 != sp20) && (temp_a1 != sp1C)) {
            arg0->unk15 = 0;
            return;
        }
        arg0->unk20 = temp_a2;
        temp_t5 = gMainMenuSelectionDepth;
        switch (temp_t5) {                          /* switch 2 */
        case GAME_MODE_SELECTION:                                     /* switch 2 */
        case GAME_MODE_CC_OR_TIME_TRIALS_OPTIONS_SELECTION:                                     /* switch 2 */
        case CONFIRM_OK_SELECTION:                                     /* switch 2 */
            arg0->unk15 = 1;
            temp_v0_4 = func_800AAE68(arg0, temp_a1, temp_a2);
            arg0->unkC = temp_v0_4->unkC;
            arg0->unk1C = 0;
            arg0->unk4 = 1;
            arg0->unk10 = (*(&gGameModeRowSelectionForNumPlayers + D_8018EDF3) * 0x12) + temp_v0_4->unk10 + 0x41;
            return;
        case CONFIRM_OK_SELECTION_FROM_BACK_OUT:                                     /* switch 2 */
        case TIME_TRAILS_DATA_SELECTION_FROM_BACK_OUT:                                     /* switch 2 */
            temp_v0_5 = func_800AAE68(arg0, temp_a1, temp_a2);
            temp_v1_4 = (arg0->unk0 * 8) + -(sp24 * 8) + &D_800E70E8;
            arg0->unkC = temp_v0_5->unkC + temp_v1_4->unk0;
            temp_t5_2 = (*(&gGameModeRowSelectionForNumPlayers + D_8018EDF3) * 0x12) + temp_v0_5->unk10 + temp_v1_4->unk2;
            arg0->unk10 = temp_t5_2;
            arg0->unk1C = temp_t5_2 - temp_v0_5->unk10;
            arg0->unk15 = 1;
            arg0->unk4 = 2;
            return;
        default:                                    /* switch 2 */
            arg0->unk15 = 0;
            return;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9E58.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A91D8(s16, s16); // extern
extern ? D_800E70A0;
extern s8 gMainMenuSelectionDepth;

void func_800AA280(void *arg0) {
    s8 temp_v1;
    void *temp_v0;

    temp_v1 = gMainMenuSelectionDepth;
    temp_v0 = (arg0->unk0 * 8) - 0x50 + &D_800E70A0;
    if ((temp_v1 == CONFIRM_OK_SELECTION_FROM_BACK_OUT) || (temp_v1 == TIME_TRAILS_DATA_SELECTION_FROM_BACK_OUT)) {
        arg0->unkC = temp_v0->unk0;
        arg0->unk10 = temp_v0->unk2;
        return;
    }
    func_800A91D8(temp_v0->unk0, temp_v0->unk2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AA280.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 check_for_controller_pak(?);                               /* extern */
s32 func_800CE720(? *, ? *, ?);                     /* extern */
s32 osPfsFindFile(? *, u16, s32, ? *, ? *, ? *);    /* extern */
s32 osPfsFreeBlocks(? *, s32 *);                    /* extern */
s32 osPfsNumFiles(? *, s32 *, s32 *);               /* extern */
extern ? D_8018E868;
extern ? D_8018EB84;
extern ? gSIEventMesgQueue;
static ? gGameModeRowSelectionForNumPlayers;                                /* unable to generate initializer; const */
static ? D_800F2E64;                                /* unable to generate initializer; const */
static ? D_800F2E74;                                /* unable to generate initializer; const */
u16 D_800E86F0;                                     /* unable to generate initializer; const */

void func_800AA2EC(void *arg0) {
    s32 sp20;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s8 temp_t6;
    s8 temp_v0;
    s32 phi_t1;

    temp_t6 = gMainMenuSelectionDepth;
    phi_t1 = 0;
    switch (temp_t6) {
    case OPTIONS_SELECTION:
    case DATA_SELECTION:
    case PLAYER_NUM_SELECTION:
    case GAME_MODE_SELECTION:
        arg0->unk4 = 0;
        return;
    case GAME_MODE_CC_OR_TIME_TRIALS_OPTIONS_SELECTION:
    case CONFIRM_OK_SELECTION:
    case CONFIRM_OK_SELECTION_FROM_BACK_OUT:
    case TIME_TRAILS_DATA_SELECTION_FROM_BACK_OUT:
        if ((arg0->unk4 == 0) && (temp_v0 = D_8018EDF3, (temp_v0 == 1)) && (*(&gGameModeRowSelectionForNumPlayers + temp_v0) == 1)) {
            if (D_800E86F8 != 0) {
                sp20 = 0;
                temp_v0_2 = osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84);
                if (temp_v0_2 != 0) {
                    if (temp_v0_2 != 2) {
                        if (temp_v0_2 != 5) {
                            goto block_12;
                        }
                    } else {
block_12:
                        D_800E86F8 = 0;
                    }
                } else {
                    arg0->unk4 = 1;
                    phi_t1 = 1;
                }
            }
            if (phi_t1 == 0) {
                if (D_800E86F8 == 0) {
                    if (check_for_controller_pak(0) == 0) {
                        arg0->unk4 = 2;
                        return;
                    }
                    temp_v0_3 = func_800CE720(&gSIEventMesgQueue, &D_8018E868, 0);
                    if (temp_v0_3 != 0) {
                        if (temp_v0_3 != 1) {
                            if (temp_v0_3 != 4) {
                                if (temp_v0_3 != 0xA) {
                                    if (temp_v0_3 == 0xB) {
                                        goto block_22;
                                    }
                                    goto block_24;
                                }
                                arg0->unk4 = 3;
                                return;
                            }
block_24:
                            arg0->unk4 = 3;
                            return;
                        }
block_22:
                        arg0->unk4 = 2;
                        return;
                    }
                    D_800E86F8 = 1;
                    if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) == 0) {
                        arg0->unk4 = 1;
                        return;
                    }
                    if (osPfsNumFiles(&D_8018E868, &D_8018EB78, &D_8018EB7C) != 0) {
                        arg0->unk4 = 3;
                        return;
                    }
                    if (osPfsFreeBlocks(&D_8018E868, &gControllerPakNumPagesFree) != 0) {
                        arg0->unk4 = 3;
                        return;
                    }
                    gControllerPakNumPagesFree = gControllerPakNumPagesFree >> 8;
                    goto block_32;
                }
block_32:
                if (D_8018EB7C >= D_8018EB78) {
                    arg0->unk4 = 5;
                    return;
                }
                if (gControllerPakNumPagesFree >= 0x79) {
                    arg0->unk4 = 1;
                    return;
                }
                arg0->unk4 = 5;
                /* Duplicate return node #37. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #37. Try simplifying control flow for better match */
            return;
        }
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AA2EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A594(s32, s32, s32, s32 *);              /* extern */
s32 random_int(?, s32);                             /* extern */
extern ? D_8018DEE4;
extern ? D_8018EDE8;
static ? D_800E8360;                                /* unable to generate initializer; const */
static ? D_800E8380;                                /* unable to generate initializer; const */
static ? D_800E83A0;                                /* unable to generate initializer; const */
static ? D_800E83C0;                                /* unable to generate initializer; const */
static ? D_800E83E0;                                /* unable to generate initializer; const */
static ? D_800E8400;                                /* unable to generate initializer; const */
static ? D_800E8440;                                /* unable to generate initializer; const */
static ? D_800E8460;                                /* unable to generate initializer; const */
static ? D_800E8480;                                /* unable to generate initializer; const */
static ? D_800E84A0;                                /* unable to generate initializer; const */

void func_800AA69C(void *arg0) {
    s32 sp30;
    s32 sp24;
    s32 *sp20;
    s32 *temp_a3;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a1;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    u32 temp_v1;
    s32 phi_a0;
    s32 phi_v0;
    s32 phi_v1;

    temp_a0 = arg0->unk0 - 0x2B;
    sp30 = temp_a0;
    temp_v0 = func_800AAFCC(temp_a0);
    temp_a1 = sp30;
    if (temp_v0 >= 0) {
        phi_a0 = 1;
    } else {
        phi_a0 = 0;
    }
    temp_v1 = arg0->unk8;
    switch (temp_v1) {
    case 0:
        if ((*(&D_8018EDE8 + temp_v0) != 0) && (phi_a0 != 0)) {
            arg0->unk8 = 1;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_a1 * 4))));
            return;
        }
        sp30 = temp_a1;
        temp_v0_2 = random_int(0xC8, temp_a1);
        if (temp_v0_2 >= 0xC6) {
            arg0->unk8 = 4;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E83E0 + (temp_a1 * 4))));
            return;
        }
        if (temp_v0_2 >= 0xC5) {
            arg0->unk8 = 5;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8400 + (temp_a1 * 4))));
            return;
        }
    default:
        return;
    case 1:
        temp_v1_2 = temp_a1 * 4;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *(&D_800E8440 + temp_v1_2)) {
            arg0->unk8 = 2;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E83A0 + temp_v1_2)));
            return;
        }
        if ((*(&D_8018EDE8 + temp_v0) == 0) && (phi_a0 != 0)) {
            arg0->unk8 = 3;
            sp24 = temp_v1_2;
            temp_a0_2 = arg0->unk18;
            func_8009A594(temp_a0_2, *(&D_800E8460 + temp_v1_2) - *(&D_8018DEE4 + (temp_a0_2 * 0x18)), segmented_to_virtual_dupe(*(&D_800E83C0 + temp_v1_2)));
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 2:
        if ((*(&D_8018EDE8 + temp_v0) == 0) && (phi_a0 != 0)) {
            arg0->unk8 = 3;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E83C0 + (temp_a1 * 4))));
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 3:
        temp_v1_3 = temp_a1 * 4;
        temp_a3 = temp_v1_3 + &D_800E8460;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *temp_a3) {
            arg0->unk8 = 0;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8360 + temp_v1_3)));
            return;
        }
        if ((*(&D_8018EDE8 + temp_v0) != 0) && (phi_a0 != 0)) {
            arg0->unk8 = 1;
            sp20 = temp_a3;
            temp_a0_3 = arg0->unk18;
            func_8009A594(temp_a0_3, *temp_a3 - *(&D_8018DEE4 + (temp_a0_3 * 0x18)), segmented_to_virtual_dupe(*(&D_800E8380 + temp_v1_3)), temp_a3);
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 4:
    case 5:
        if ((*(&D_8018EDE8 + temp_v0) != 0) && (phi_a0 != 0)) {
            arg0->unk8 = 1;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_a1 * 4))));
            return;
        }
        if (temp_v1 == 4) {
            temp_v1_4 = temp_a1 * 4;
            phi_v0 = *(&D_800E8480 + temp_v1_4);
            phi_v1 = temp_v1_4;
        } else {
            temp_v1_5 = temp_a1 * 4;
            phi_v0 = *(&D_800E84A0 + temp_v1_5);
            phi_v1 = temp_v1_5;
        }
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= phi_v0) {
            arg0->unk8 = 0;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8360 + phi_v1)));
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AA69C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AAA9C(s32 *arg0) {
    s32 *temp_a1;
    s32 temp_a0;
    s32 temp_t2;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    temp_a1 = arg0;
    switch (temp_t6) {
    case 3:
        temp_a1->unk4 = 1;
        /* fallthrough */
    case 1:
        if (D_8018EDEE == 3) {
            temp_a1->unk1C = 0x20;
        } else {
            temp_v0 = temp_a1->unk1C;
            if (temp_v0 < 0x20) {
                temp_t2 = temp_v0 + (temp_v0 / 12) + 2;
                temp_a1->unk1C = temp_t2;
                if (temp_t2 >= 0x20) {
                    temp_a1->unk1C = 0x20;
                }
            }
        }
        /* fallthrough */
    case 0:
        temp_a0 = temp_a1->unk0;
        arg0 = temp_a1;
        if (func_800AAFCC(temp_a0 - 0x2B, temp_a1) >= 0) {
            arg0->unk4 = 2;
block_13:
            arg0->unk1C = 0;
        default:
            return;
        }
        arg0->unk4 = 1;
        return;
    case 4:
        arg0 = temp_a1;
        if (func_800AAFCC(temp_a1->unk0 - 0x2B, temp_a1) >= 0) {
            arg0->unk4 = 2;
            goto block_13;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAA9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AAB90(void *arg0) {
    s32 temp_t2;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 1:
        if (arg0->unk1C > 0) {
            arg0->unk4 = 3;
            return;
        }
    default:
        return;
    case 2:
        arg0->unk4 = 4;
        return;
    case 3:
        temp_v0 = arg0->unk1C;
        if (temp_v0 > 0) {
            temp_t2 = (temp_v0 - (temp_v0 / 12)) - 2;
            arg0->unk1C = temp_t2;
            if (temp_t2 < 0) {
                arg0->unk1C = 0;
                return;
            }
            /* Duplicate return node #9. Try simplifying control flow for better match */
            return;
        }
        arg0->unk1C = 0;
        arg0->unk4 = 0;
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAB90.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A594(s32, ?, s32, void *);               /* extern */
? func_800A91D8(void *, s16, s16, void *);          /* extern */
static ? D_800E7108;                                /* unable to generate initializer; const */
static ? D_800E7188;                                /* unable to generate initializer; const */
static ? D_800E8340;                                /* unable to generate initializer; const */

void func_800AAC18(void *arg0) {
    s32 sp24;
    void *sp18;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_v0;
    s32 temp_v0_3;
    u32 temp_v1;
    void *temp_a3;
    void *temp_a3_2;
    void *temp_t0;
    void *temp_v0_2;
    void *temp_v0_4;
    u32 phi_v1;
    void *phi_a3;
    void *phi_t0;

    temp_v1 = arg0->unk4;
    temp_a3 = arg0;
    temp_a1 = arg0->unk0 - 0x2B;
    phi_v1 = temp_v1;
    phi_a3 = temp_a3;
    switch (temp_v1) {
    case 0:
        temp_a0 = temp_a1;
        if (D_8018EDEE == 3) {
            sp24 = temp_a1;
            arg0 = temp_a3;
            temp_v0 = func_800AAFCC(temp_a0, temp_a1, MIPS2C_ERROR(Read from unset register $a2), temp_a3);
            temp_a3_2 = arg0;
            if (temp_v0 >= 0) {
                temp_t0 = (gScreenModeSelection << 5) + (temp_v0 * 8) + &D_800E7188;
                temp_a3_2->unkC = temp_t0->unk0;
                temp_a3_2->unk4 = 2;
                temp_a3_2->unk8 = 2;
                temp_a3_2->unk10 = temp_t0->unk2;
                arg0 = temp_a3_2;
                func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8340 + (temp_a1 * 4))), arg0);
                return;
            }
        default:
            return;
        }
    case 1:
    case 3:
        temp_v0_2 = (temp_a1 * 8) + &D_800E7108;
        temp_a3->unkC = temp_v0_2->unk0;
        temp_a3->unk10 = temp_v0_2->unk2;
        return;
    case 2:
    case 4:
        if (temp_v1 == 2) {
            arg0 = temp_a3;
            temp_v0_3 = func_800AAFCC(temp_a1, temp_a1, 2, temp_a3);
            phi_a3 = arg0;
            if (temp_v0_3 >= 0) {
                sp18 = (gScreenModeSelection << 5) + (temp_v0_3 * 8) + &D_800E7188;
            }
            phi_v1 = arg0->unk4;
            phi_t0 = sp18;
            goto block_13;
        }
        temp_v0_4 = (temp_a1 * 8) + &D_800E7108;
        phi_t0 = temp_v0_4;
        if ((temp_a3->unkC == temp_v0_4->unk0) && (temp_a3->unk10 == temp_v0_4->unk2)) {
            temp_a3->unk4 = 0;
            return;
        }
block_13:
        if ((phi_v1 != 2) || (phi_a3->unk8 != 1)) {
            func_800A91D8(phi_a3, phi_t0->unk0, phi_t0->unk2, phi_a3);
        }
        /* Duplicate return node #16. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAC18.s")
#endif

void func_800AADD4(struct_8018D9E0_entry *arg0) {
    s32 playerId;
    s8 characterSelectionIndex;

    playerId = arg0->type - 0x34;
    characterSelectionIndex = gCharacterGridSelections[playerId];
    arg0->priority = 0xE - (playerId * 2);
    func_800AAF94(arg0, characterSelectionIndex - 1);
}

void func_800AAE18(struct_8018D9E0_entry *arg0) {
    s32 temp_v0;

    temp_v0 = func_800AAFCC(arg0->type - 0x2B);
    if (temp_v0 >= 0) {
        arg0->priority = 0xE - (temp_v0 * 2);
    }
    else {
        arg0->priority = 6;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9E0;
extern ? D_8018DEE0;

s32 *func_800AAE68(void) {
    s32 *temp_v1;
    s32 *phi_v1;

    phi_v1 = &D_8018D9E0;
loop_1:
    if ((D_8018EDF3 - 1 + 0xB) != *phi_v1) {
        temp_v1 = phi_v1 + 0x28;
        phi_v1 = temp_v1;
        if (&D_8018DEE0 < temp_v1) {
loop_3:
            goto loop_3;
        }
        goto loop_1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAE68.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9E0;
extern ? D_8018DEE0;

s32 *func_800AAEB4(s32 arg0) {
    s32 *temp_v1;
    s32 *phi_v1;

    phi_v1 = &D_8018D9E0;
loop_1:
    if ((arg0 + 0x2B) != *phi_v1) {
        temp_v1 = phi_v1 + 0x28;
        phi_v1 = temp_v1;
        if (&D_8018DEE0 < temp_v1) {
loop_3:
            goto loop_3;
        }
        goto loop_1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAEB4.s")
#endif

struct_8018D9E0_entry *func_800AAEF4(s32 arg0) {
    struct_8018D9E0_entry *entry = D_8018D9E0;
    for (; !(entry > (&D_8018D9E0[D_8018D9E0_SIZE])); entry++) {
        if (entry->type == arg0) {
            goto escape;
        }
    }

    // I don't know why they'd want a function that could potentially hard lock the game...
    while(1);
escape:
    return entry;
}

struct_8018D9E0_entry *func_800AAF30(s32 arg0) {
    struct_8018D9E0_entry *entry = D_8018D9E0;
    for (; !(entry > (&D_8018D9E0[D_8018D9E0_SIZE])); entry++) {
        if (entry->type == arg0) {
            goto escape;
        }
    }

    return NULL;
escape:
    return entry;
}

s32 func_800AAF70(s32 arg0) {
    struct_8018D9E0_entry *temp;
    temp = func_800AAEB4(arg0);
    return temp->unk4;
}

void func_800AAF94(struct_8018D9E0_entry *arg0, s32 arg1) {
    struct_8018D9E0_entry *temp_v0;

    temp_v0 = func_800AAEB4(arg1);
    arg0->column = temp_v0->column;
    arg0->row = temp_v0->row;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 gCharacterGridSelections;

s32 func_800AAFCC(s32 arg0) {
    s32 temp_v1;
    s8 *phi_a2;
    s32 phi_v1;
    s32 phi_v0;
    s32 phi_v1_2;

    phi_a2 = &gCharacterGridSelections;
    phi_v1 = 0;
    phi_v0 = 0;
loop_1:
    phi_v1_2 = phi_v1;
    if ((arg0 + 1) == *phi_a2) {
        phi_v0 = 1;
    } else {
        temp_v1 = phi_v1 + 1;
        phi_a2 += 1;
        phi_v1 = temp_v1;
        phi_v1_2 = temp_v1;
        if (temp_v1 != 4) {
            goto loop_1;
        }
    }
    if (phi_v0 != 0) {
        return phi_v1_2;
    }
    return -1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAFCC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AB020(void *arg0) {
    s32 temp_t0;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 1:
        arg0->unk4 = 4;
        /* fallthrough */
    case 4:
        temp_v0 = arg0->unk1C;
        if (temp_v0 > 0) {
            temp_t0 = (temp_v0 - (temp_v0 / 12)) - 2;
            arg0->unk1C = temp_t0;
            if (temp_t0 < 0) {
                arg0->unk1C = 0;
                return;
            }
        default:
            return;
        }
        arg0->unk1C = 0;
        arg0->unk4 = 0;
        return;
    case 2:
        arg0->unk4 = 3;
        /* Duplicate return node #8. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB020.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AB098(void *arg0) {
    s32 temp_t8;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        if (arg0->unk0 == (gCupSelection + 0x53)) {
            arg0->unk4 = 2;
            return;
        }
        arg0->unk4 = 1;
        return;
    case 4:
        if (arg0->unk0 == (gCupSelection + 0x53)) {
            arg0->unk4 = 2;
            arg0->unk1C = 0;
            return;
        }
        arg0->unk4 = 1;
    case 1:
        temp_v0 = arg0->unk1C;
        temp_t8 = temp_v0 + 2;
        if ((temp_v0 < 0x20) && (arg0->unk1C = temp_t8, ((temp_t8 < 0x20) == 0))) {
            arg0->unk1C = 0x20;
            return;
        }
    default:
        return;
    case 3:
        if (arg0->unk0 == (gCupSelection + 0x53)) {
            arg0->unk4 = 2;
        }
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB098.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A91D8(s16, s16);                          /* extern */
static ? D_800E7148;                                /* unable to generate initializer; const */

void func_800AB164(void *arg0) {
    void *sp1C;
    u32 temp_t1;
    void *temp_v0;
    void *temp_v0_2;

    if (arg0->unk0 == (gCupSelection + 0x53)) {
        arg0->unk14 = 0xA;
    } else {
        arg0->unk14 = 4;
    }
    temp_t1 = arg0->unk4;
    switch (temp_t1) {
    case 0:
        temp_v0 = (arg0->unk0 * 8) - 0x298 + &D_800E7148;
        arg0->unkC = temp_v0->unk0;
        arg0->unk10 = temp_v0->unk2;
        return;
    case 2:
        func_800A91D8(0x80, 0x3B);
        return;
    case 3:
        temp_v0_2 = (arg0->unk0 * 8) - 0x298 + &D_800E7148;
        sp1C = temp_v0_2;
        func_800A91D8(temp_v0_2->unk0, temp_v0_2->unk2);
        if ((temp_v0_2->unk0 == arg0->unkC) && (temp_v0_2->unk2 == arg0->unk10)) {
            arg0->unk4 = 0;
        }
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB164.s")
#endif

void func_800AB260(struct_8018D9E0_entry *arg0) {
    s32 temp = (arg0->type - 0x58);
    if (temp == gCupSelection) {
        arg0->visible = 1;
    }
    else{
        arg0->visible = 0;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A594(s32, ?, s32, void *); // extern
void *segmented_to_virtual_dupe(segment_address_t); // extern
extern ? D_800E7E34;
extern s8 gCupSelection;
extern ? gCupCourseOrder;

void func_800AB290(void *arg0) {
    s16 temp_t2;
    s8 temp_v0;
    void *temp_a3;

    temp_v0 = gCupSelection;
    temp_a3 = arg0;
    if (temp_v0 != arg0->unk1C) {
        arg0->unk1C = temp_v0;
        temp_t2 = *(&gCupCourseOrder - 0xBE + ((gCupSelection * 8) + (arg0->unk0 * 2)));
        arg0 = temp_a3;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7E34 + (temp_t2 * 4))), arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB290.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800AAEF4(s32, s32, void *); // extern
extern s8 D_8018EDEC;
extern s8 gCupSelection;

void func_800AB314(void *arg0) {
    s32 sp3C;
    void *sp24;
    void **sp1C;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_t2;
    s32 temp_t5;
    s32 temp_t7;
    s32 temp_v0;
    void **temp_v1;
    void **phi_v1;
    s32 phi_a1;
    s32 phi_v0;
    s8 phi_a0;
    s32 phi_a1_2;
    void **phi_v1_2;

    phi_v1 = &sp24;
    phi_a1 = 0;
    phi_a1_2 = 0;
    do {
        sp1C = phi_v1;
        sp3C = phi_a1;
        arg0 = arg0;
        temp_a1 = phi_a1 + 1;
        temp_v1 = phi_v1 + 4;
        temp_v1->unk-4 = func_800AAEF4(phi_a1 + 0x5F, phi_a1, arg0);
        phi_v1 = temp_v1;
        phi_a1 = temp_a1;
    } while (temp_a1 < 4);
    if (gModeSelection != GRAND_PRIX) {
        if (D_8018EDEC != 1) {
            arg0->unk4 = 0;
            arg0->unk20 = 0;
            if (gCupCourseSelection == CUP_COURSE_ONE) {
                sp24->unk15 = 1;
                if (arg0->unk1C != 0) {
                    arg0->unk1C = 0;
                }
            } else {
                sp24->unk15 = 0;
            }
            if (gCupCourseSelection == CUP_COURSE_TWO) {
                sp28->unk15 = 1;
                if (arg0->unk1C != 1) {
                    arg0->unk1C = 1;
                }
            } else {
                sp28->unk15 = 0;
            }
            if (gCupCourseSelection == CUP_COURSE_THREE) {
                sp2C->unk15 = 1;
                if (arg0->unk1C != 2) {
                    arg0->unk1C = 2;
                }
            } else {
                sp2C->unk15 = 0;
            }
            if (gCupCourseSelection == CUP_COURSE_FOUR) {
                sp30->unk15 = 1;
                if (arg0->unk1C != 3) {
                    arg0->unk1C = 3;
                    return;
                }
                // Duplicate return node #80. Try simplifying control flow for better match
                return;
            }
            sp30->unk15 = 0;
            return;
        }
        arg0->unk4 = 3;
        sp24->unk15 = 1;
        sp24->unk14 = 6;
        sp28->unk15 = 1;
        sp28->unk14 = 6;
        sp2C->unk15 = 1;
        sp2C->unk14 = 6;
        sp30->unk15 = 1;
        sp30->unk14 = 6;
        return;
    }
    temp_v0 = arg0->unk4;
    phi_v0 = temp_v0;
    phi_a0 = 1;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {

                } else if (D_8018EDEC != 3) {
                    arg0->unk4 = 0;
                    arg0->unk20 = 0;
                    arg0->unk1C = 0;
                    phi_v0 = 0;
                }
            } else {
                temp_t7 = arg0->unk20 + 1;
                arg0->unk20 = temp_t7;
                if (temp_t7 >= 0x1A) {
                    arg0->unk4 = 3;
                    arg0->unk20 = 0;
                }
                if (D_8018EDEC != 3) {
                    arg0->unk4 = 0;
                    arg0->unk20 = 0;
                    arg0->unk1C = 0;
                }
                phi_v0 = arg0->unk4;
            }
        } else if ((arg0->unk1C / 4) != gCupSelection) {
            arg0->unk4 = 0;
            arg0->unk20 = 0;
            arg0->unk1C = 0;
            phi_v0 = 0;
        } else {
            temp_t2 = arg0->unk20 + 1;
            arg0->unk20 = temp_t2;
            if (temp_t2 >= 0x1F) {
                arg0->unk20 = 0;
                arg0->unk1C = (gCupSelection * 4) + (((arg0->unk1C % 4) + 1) % 4);
                phi_v0 = arg0->unk4;
            } else {
                if (D_8018EDEC == 3) {
                    arg0->unk4 = 2;
                    arg0->unk20 = 0;
                }
                phi_v0 = arg0->unk4;
            }
        }
    } else {
        if ((arg0->unk1C / 4) == gCupSelection) {
            temp_t5 = arg0->unk20 + 1;
            arg0->unk20 = temp_t5;
            if (temp_t5 >= 0x33) {
                arg0->unk4 = 1;
                arg0->unk20 = 0;
                arg0->unk1C = (gCupSelection * 4) + 1;
            }
        } else {
            arg0->unk20 = 0;
            arg0->unk1C = gCupSelection * 4;
        }
        phi_a0 = 1;
        if (D_8018EDEC == 3) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
        }
        phi_v0 = arg0->unk4;
    }
    if ((phi_v0 != 0) && (phi_v0 != phi_a0)) {
        if (phi_v0 != 2) {
            if (phi_v0 != 3) {
                return;
            }
            sp24->unk15 = phi_a0;
            sp24->unk14 = 6;
            sp28->unk15 = phi_a0;
            sp28->unk14 = 6;
            sp2C->unk15 = phi_a0;
            sp2C->unk14 = 6;
            sp30->unk15 = phi_a0;
            sp30->unk14 = 6;
            return;
        }
        phi_v1_2 = &sp24;
        do {
            if (phi_a1_2 == (arg0->unk1C % 4)) {
                phi_v1_2->unk0->unk14 = 6;
            } else if (arg0->unk20 < (phi_a1_2 * 5)) {
                phi_v1_2->unk0->unk14 = 4;
            } else {
                phi_v1_2->unk0->unk14 = 8;
            }
            phi_v1_2->unk0->unk15 = phi_a0;
            if ((phi_a1_2 + 1) == (arg0->unk1C % 4)) {
                phi_v1_2->unk4->unk14 = 6;
            } else if (arg0->unk20 < ((phi_a1_2 * 5) + 5)) {
                phi_v1_2->unk4->unk14 = 4;
            } else {
                phi_v1_2->unk4->unk14 = 8;
            }
            temp_a1_2 = phi_a1_2 + 2;
            phi_v1_2->unk4->unk15 = phi_a0;
            phi_a1_2 = temp_a1_2;
            phi_v1_2 += 8;
        } while (temp_a1_2 != 4);
        return;
    }
    if ((arg0->unk1C & 3) == 0) {
        sp24->unk15 = phi_a0;
    } else {
        sp24->unk15 = 0;
    }
    sp24->unk14 = 6;
    if ((arg0->unk1C % 4) == 1) {
        sp28->unk15 = phi_a0;
    } else {
        sp28->unk15 = 0;
    }
    sp28->unk14 = 6;
    if ((arg0->unk1C % 4) == 2) {
        sp2C->unk15 = phi_a0;
    } else {
        sp2C->unk15 = 0;
    }
    sp2C->unk14 = 6;
    if ((arg0->unk1C % 4) == 3) {
        sp30->unk15 = phi_a0;
    } else {
        sp30->unk15 = 0;
    }
    sp30->unk14 = 6;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB314.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A9208(s16); // extern
extern ? D_800E7248;
extern ? D_800E7258;
extern s8 D_8018EDEC;

void func_800AB904(void *arg0) {
    s16 temp_a1;
    s16 temp_a1_2;
    s8 temp_v0;

    temp_v0 = D_8018EDEC;
    if (temp_v0 != 1) {
        if ((temp_v0 != 2) && (temp_v0 != 3)) {
            return;
        }
        temp_a1 = *((arg0->unk0 * 8) - 0x328 + &D_800E7258);
        if (temp_a1 != arg0->unkC) {
            func_800A9208(temp_a1);
        }
        // Duplicate return node #8. Try simplifying control flow for better match
        return;
    }
    temp_a1_2 = *((arg0->unk0 * 8) - 0x328 + &D_800E7248);
    if (temp_a1_2 != arg0->unkC) {
        func_800A9208(temp_a1_2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB904.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A594(s32, ?, s32); // extern
? func_800A91D8(void *, s16, s16); // extern
s32 func_800B54C0(s8, s32); // extern
void *segmented_to_virtual_dupe(segment_address_t); // extern
extern ? D_800E7268;
extern ? D_800E7E20;
extern s8 D_8018EDEC;
extern s8 gCupSelection;

void func_800AB9B0(void *arg0) {
    s32 temp_v0_2;
    s32 temp_v0_3;
    s8 temp_v0;
    void *temp_v1;

    temp_v0 = gCupSelection;
    if (temp_v0 != arg0->unk1C) {
        arg0->unk1C = temp_v0;
        temp_v0_2 = func_800B54C0(gCupSelection, gCCSelection);
        arg0->unk20 = temp_v0_2;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7E20 + (((gCCSelection / 2) * 0x10) + -(temp_v0_2 * 4)))));
        arg0->unkC = D_800E7268.unk0;
        arg0->unk10 = D_800E7268.unk2;
    }
    temp_v0_3 = arg0->unk4;
    temp_v1 = &D_800E7268 + (temp_v0_3 * 8);
    if (temp_v0_3 != 0) {
        if (temp_v0_3 != 1) {
            return;
        }
        func_800A91D8(arg0, temp_v1->unk0, temp_v1->unk2);
        if (D_8018EDEC == 1) {
            arg0->unk4 = 0;
        }
        // Duplicate return node #9. Try simplifying control flow for better match
        return;
    }
    func_800A91D8(arg0, temp_v1->unk0, temp_v1->unk2);
    if (D_8018EDEC == 3) {
        arg0->unk4 = 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB9B0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E7430;

void func_800ABAE8(void *arg0) {
    s32 temp_v0;
    void *temp_v0_2;
    s32 phi_v1;

    temp_v0 = arg0->unk0;
    if (temp_v0 == 0x8C) {
        phi_v1 = 4;
    } else {
        phi_v1 = temp_v0 - 0x78;
    }
    temp_v0_2 = (phi_v1 * 8) + &D_800E7430;
    arg0->unkC = temp_v0_2->unk0;
    arg0->unk10 = temp_v0_2->unk2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABAE8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E7430;
extern s8 gTimeTrialDataCourseIndex;

void func_800ABB24(void *arg0) {
    s32 temp_t7;
    s8 temp_v0;
    void *temp_v1;

    temp_v0 = gTimeTrialDataCourseIndex;
    temp_v1 = ((temp_v0 / 4) * 8) + &D_800E7430;
    arg0->unkC = temp_v1->unk0 - 2;
    temp_t7 = arg0->unk1C + 0x10;
    arg0->unk10 = temp_v1->unk2 + ((temp_v0 % 4) * 0x32) + 0x13;
    arg0->unk1C = temp_t7;
    if (temp_t7 >= 0x100) {
        arg0->unk1C = temp_t7 - 0x100;
        arg0->unk20 = (arg0->unk20 + 1) % 3;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABB24.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E7430;

void func_800ABBCC(void *arg0) {
    s32 temp_v0;
    void *temp_v1;

    temp_v0 = arg0->unk0 - 0x7C;
    temp_v1 = ((temp_v0 / 4) * 8) + &D_800E7430;
    arg0->unkC = temp_v1->unk0;
    arg0->unk10 = temp_v1->unk2 + ((temp_v0 % 4) * 0x32) + 0x14;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABBCC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800ABCF4(); // extern
extern s8 D_8018EE08;

void func_800ABC38(void *arg0) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;

    func_800ABCF4();
    temp_v0 = D_80164A28;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
                goto block_13;
            }
            temp_v0_2 = arg0->unk10;
            if (temp_v0_2 >= -0x13) {
                arg0->unk10 = temp_v0_2 - 2;
                return;
            }
            goto block_13;
        }
        temp_v0_3 = arg0->unk10;
        if (temp_v0_3 >= -0x13) {
            arg0->unk10 = temp_v0_3 - 2;
            return;
        }
block_13:
        arg0->unk0 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABC38.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 get_string_width(s32); // extern
? func_800A9208(void *, s32); // extern
extern s32 D_800DC540;
extern ? D_800E7500;
extern f64 D_800F2630;
extern f64 D_800F2638;
extern f64 D_800F2640;

void func_800ABCF4(void *arg0) {
    f64 temp_f0;
    s32 temp_t1;
    s32 temp_t1_2;
    s32 temp_v0;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            func_800A9208(arg0, arg0->unk20);
            temp_t1 = arg0->unk18 + 1;
            temp_f0 = temp_t1 - 0xA;
            arg0->unk1C = (arg0->unk20 - arg0->unkC) / 4;
            arg0->unk18 = temp_t1;
            arg0->unk24 = (temp_f0 * D_800F2638 * temp_f0) + D_800F2640;
            if ((temp_t1 >= 9) && (arg0->unk24 > 1.0)) {
                arg0->unk24 = 1.0f;
            }
            // Duplicate return node #12. Try simplifying control flow for better match
            return;
        }
        goto block_5;
    }
    arg0->unkC = 0;
    arg0->unk4 = 1;
    arg0->unk20 = (get_string_width(*(&D_800E7500 + (D_800DC540 * 4))) / 2) + 0xA0;
block_5:
    func_800A9208(arg0, arg0->unk20);
    temp_t1_2 = (arg0->unk20 - arg0->unkC) / 4;
    arg0->unk1C = temp_t1_2;
    if (temp_t1_2 >= 9) {
        arg0->unk1C = 8;
    }
    arg0->unk24 = (arg0->unk1C * D_800F2630) + 1.0;
    if (arg0->unkC >= (arg0->unk20 - 0x14)) {
        arg0->unk4 = 2;
        arg0->unk18 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABCF4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800ABF68(); // extern
extern s8 D_8018EE08;

void func_800ABEAC(void *arg0) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;

    func_800ABF68();
    temp_v0 = D_80164A28;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
                goto block_13;
            }
            temp_v0_2 = arg0->unk10;
            if (temp_v0_2 < 0x104) {
                arg0->unk10 = temp_v0_2 + 2;
                return;
            }
            goto block_13;
        }
        temp_v0_3 = arg0->unk10;
        if (temp_v0_3 < 0x104) {
            arg0->unk10 = temp_v0_3 + 2;
            return;
        }
block_13:
        arg0->unk0 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABEAC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 get_string_width(s32); // extern
? func_800A9208(void *, s32); // extern
extern ? D_800E7524;
extern f64 D_800F2648;
extern f64 D_800F2650;
extern f64 D_800F2658;

void func_800ABF68(void *arg0) {
    f64 temp_f0;
    s32 temp_t3;
    s32 temp_t3_2;
    s32 temp_v0;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            func_800A9208(arg0, arg0->unk20);
            temp_t3 = arg0->unk18 + 1;
            temp_f0 = temp_t3 - 0xA;
            arg0->unk1C = (arg0->unkC - arg0->unk20) / 4;
            arg0->unk18 = temp_t3;
            arg0->unk24 = (temp_f0 * D_800F2650 * temp_f0) + D_800F2658;
            if ((temp_t3 >= 9) && (arg0->unk24 > 1.0)) {
                arg0->unk24 = 1.0f;
            }
            // Duplicate return node #12. Try simplifying control flow for better match
            return;
        }
        goto block_5;
    }
    arg0->unkC = 0x140;
    arg0->unk4 = 1;
    arg0->unk20 = 0xA0 - (get_string_width(*(&D_800E7524 + (gCurrentCourseId * 4))) / 2);
block_5:
    func_800A9208(arg0, arg0->unk20);
    temp_t3_2 = (arg0->unkC - arg0->unk20) / 4;
    arg0->unk1C = temp_t3_2;
    if (temp_t3_2 >= 9) {
        arg0->unk1C = 8;
    }
    arg0->unk24 = (arg0->unk1C * D_800F2648) + 1.0;
    if ((arg0->unk20 + 0x14) >= arg0->unkC) {
        arg0->unk4 = 2;
        arg0->unk18 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABF68.s")
#endif

void func_800AC300(struct_8018D9E0_entry *arg0) {
    if (arg0->unk20 < ++arg0->unk1C) {
        arg0->type = 0;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800921B4(); // extern
? add_8018D9E0_entry(?, ?, ?, ?); // extern
? func_800A9208(void *, ?); // extern
extern s32 D_800DDB24;
extern s8 D_8018D9D8;

void func_800AC324(void *arg0) {
    s32 temp_t1;
    s32 temp_v0;
    s32 temp_v0_2;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                temp_v0_2 = arg0->unk1C;
                arg0->unkC = temp_v0_2;
                if (temp_v0_2 < 0x14A) {
                    if (D_8018D9D8 != 0) {
                        arg0->unk1C = temp_v0_2 + 0x20;
                        return;
                    }
                    arg0->unk1C = temp_v0_2 + 0x10;
                    return;
                }
                arg0->unk0 = 0;
                // Duplicate return node #17. Try simplifying control flow for better match
                return;
            }
            temp_t1 = arg0->unk20 + 1;
            arg0->unk20 = temp_t1;
            if (((D_8018D9D8 != 0) || (temp_t1 >= 0x5B)) && (D_800DDB24 != 0)) {
                arg0->unk4 = 3;
                arg0->unk1C = arg0->unkC;
                add_8018D9E0_entry(0xAB, 0, 0, 0);
                return;
            }
            // Duplicate return node #17. Try simplifying control flow for better match
            return;
        }
        func_800A9208(arg0, 0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
        return;
    }
    arg0->unkC = 0x14A;
    arg0->unk4 = 1;
    func_800921B4();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AC324.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s8 *func_800921B4();                                /* extern */
s8 *func_800B536C(s32, s32, s32, void *);           /* extern */
s8 *func_800CA330(?, s32);                          /* extern */
s8 *play_sound2(?, s32, u8 *, void *);              /* extern */
extern s8 D_800DC5EC;
extern void *D_800DC5F0;
extern s16 D_8015F894;
extern ? D_80164360;
extern ? D_80164478;
extern s8 D_8018D9BC;
extern s8 D_8018D9D8;
extern s8 D_8018EDF3;
static s32 D_800DDB24 = 1;
static s8 gGP1stPlaceReward = 9;        /* const */
static s8 gGP2ndPlaceReward = 6;        /* const */
static s8 gGP3rdPlaceReward = 3;        /* const */
static s8 gGP4thPlaceReward = 1;        /* const */


//Something related to the point allotment screens at the end of a grand prix race
// Its unclear what exactly arg0 is, although unk4 of that struct(?) appears to be
// a form of a "current state" tracker. Each time this function runs it
// advances which "state" its in
s8 *func_800AC458(void *arg0) {
    s32 place;
    s32 sp18;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_4;
    s32 temp_a2;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_t3_2;
    s32 temp_t5;
    s32 temp_t7;
    s32 temp_t8;
    s32 temp_v0_3;
    s32 temp_v0_6;
    s8 *temp_v0;
    s8 *temp_v0_4;
    s8 *temp_v0_5;
    u16 temp_t4;
    u32 temp_v0_2;
    u8 *temp_a2_2;
    u8 temp_t0;
    void *temp_a3;
    void *temp_v1;
    void *temp_v1_2;
    s32 phi_a0;
    void *phi_a3;
    s32 phi_t1;
    s8 *phi_v0;
    s32 phi_a1;
    s8 *phi_v0_2;

    temp_v0_2 = arg0->unk4;
    temp_a3 = arg0;
    phi_a3 = temp_a3;
    phi_v0_2 = temp_v0_2;
    switch (temp_v0_2) {
    case 0:
        temp_a3->unkC = -0xA0;
        temp_a3->unk4 = 1;
        // Copy point rewards from data to some temp memory
        D_8018D9BC->unk0 = gGP1stPlaceReward;
        D_8018D9BC->unk1 = gGP2ndPlaceReward;
        D_8018D9BC->unk2 = gGP3rdPlaceReward;
        D_8018D9BC->unk3 = gGP4thPlaceReward;
        temp_a3->unk20 = temp_a3->unkC;
        return &D_8018D9BC;
    case 1:
        temp_a1 = temp_a3->unk20;
        temp_a3->unkC = temp_a1;
        phi_a0 = 0x10;
        if (D_8018D9D8 != 0) {
            phi_a0 = 0x20;
        }
        temp_a2 = temp_a1 + phi_a0;
        if (temp_a2 < 0) {
            temp_a3->unk20 = temp_a2;
            temp_v0 = D_800DC5EC;
            temp_v0->unk30 = temp_v0->unk30 + phi_a0;
            temp_v1 = D_800DC5F0;
            temp_v1->unk30 = temp_v1->unk30 - phi_a0;
            return temp_v0;
        }
        temp_a3->unk20 = 0;
        temp_a3->unkC = 0;
        temp_a3->unk4 = 2;
        temp_a3->unk1C = 0;
        D_800DC5EC->unk30 = 0xF0;
        D_800DC5F0->unk30 = 0x50;
        return &D_800DC5EC;
    case 2:
        temp_a3->unkC = 0;
        temp_t5 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t5;
        if (((D_8018D9D8 != 0) || (temp_t5 >= 0x1F)) && (D_800DDB24 != 0)) {
            temp_a3->unk4 = 3;
            temp_a3->unk1C = 0;
            temp_a3->unk20 = 0;
            return temp_v0_2;
        }
    default:
        return phi_v0_2;
    // Allocating point rewards for the players that finished the race
    // in 1st, 2nd, 3rd and 4th place
    case 3:
    case 4:
    case 5:
    case 6:
        temp_t3 = temp_a3->unk1C + 1;
        // Using the "state" variable to deduce which player we're allocating points for
        temp_a1_2 = temp_v0_2 - 3;
        temp_a3->unk1C = temp_t3;
        if (((temp_t3 % 3) == 0) || (D_8018D9D8 != 0)) {
            temp_a2_2 = D_8018D9BC + temp_a1_2;
            temp_t0 = *temp_a2_2;
            if (temp_t0 > 0) {
                *temp_a2_2 = temp_t0 - 1;
                temp_t4 = *(&gPlayers->characterId + (*(&D_80164360 + (temp_a1_2 * 2)) * 0xDD8));
                sp18 = 0;
                arg0 = temp_a3;
                gGPPointsByCharacterId[temp_t4] += 1;
                place = temp_a1_2;
                play_sound2(0x49008017, temp_a1_2, temp_a2_2, temp_a3);
                phi_a3 = arg0;
                if ((*(D_8018D9BC + temp_a1_2) == 0) && (arg0->unk20 == 0)) {
                    arg0->unk20 = 1;
                    arg0->unk1C = 0;
                }
            }
        }
        phi_t1 = 0;
        phi_v0_2 = &D_8018D9BC;
        if ((phi_a3->unk20 != 0) && ((temp_v0_6 = phi_a3->unk1C, phi_v0_2 = temp_v0_6, ((temp_v0_6 < 0xB) == 0)) || ((D_8018D9D8 != 0) && (temp_v0_6 >= 4)))) {
            phi_t1 = 1;
        }
        if (phi_t1 != 0) {
            temp_v0_3 = phi_a3->unk4;
            phi_a3->unk20 = 0;
            phi_a3->unk1C = 0;
            // If not done alloting points
            if (temp_v0_3 < 6) {
                phi_a3->unk4 = temp_v0_3 + 1;
                return temp_v0_3;
            }
            phi_a3->unk4 = 7;
            return temp_v0_3;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 7:
        temp_t2 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t2;
        if ((((D_8018D9D8 != 0) && (temp_t2 >= 0xB)) || (temp_a3->unk1C >= 0x3D)) && (D_800DDB24 != 0)) {
            temp_a3->unk4 = 8;
            temp_a3->unk1C = 0;
            return temp_v0_2;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 8:
        temp_t8 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t8;
        if (D_8018D9D8 != 0) {
            temp_a3->unk1C = temp_t8 + 5;
        }
        if (temp_a3->unk1C >= 0x29) {
            temp_a3->unk4 = 9;
            return temp_v0_2;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 9:
        temp_t7 = temp_a3->unk1C - 1;
        temp_a3->unk1C = temp_t7;
        if (D_8018D9D8 != 0) {
            temp_a3->unk1C = temp_t7 - 5;
        }
        if ((temp_a3->unk1C <= 0) && (temp_a3->unk4 = 0xA, temp_a3->unk1C = 0, phi_a1 = 0, phi_v0_2 = gCharacterIdByGPOverallRank, (gCupCourseSelection == CUP_COURSE_FOUR))) {
            phi_v0 = gCharacterIdByGPOverallRank;
loop_41:
            if (*(&D_80164478 + (*phi_v0 * 2)) < D_8018EDF3) {
                return func_800B536C(phi_a1, phi_a1, 8, temp_a3);
            }
            temp_a1_3 = phi_a1 + 1;
            temp_v0_4 = phi_v0 + 1;
            phi_v0 = temp_v0_4;
            phi_a1 = temp_a1_3;
            if (temp_a1_3 == 8) {
                return temp_v0_4;
            }
            goto loop_41;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 10:
        temp_t3_2 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t3_2;
        if (temp_t3_2 > 0) {
            temp_a3->unk4 = 0xB;
            temp_a3->unk1C = 0;
            return func_800921B4();
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 11:
        if ((D_8018D9D8 != 0) && (D_800DDB24 != 0)) {
            temp_a3->unk4 = 0xC;
            temp_a3->unk20 = temp_a3->unk10;
            return play_sound2(0x49008015);
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 12:
        temp_a1_4 = temp_a3->unk20;
        temp_a3->unk10 = temp_a1_4;
        if (temp_a1_4 < 0xF0) {
            temp_a3->unk20 = temp_a1_4 + 0x10;
            temp_v0_5 = D_800DC5EC;
            temp_v0_5->unk32 = temp_v0_5->unk32 + 0x10;
            temp_v1_2 = D_800DC5F0;
            temp_v1_2->unk32 = temp_v1_2->unk32 - 0x10;
            return temp_v0_5;
        }
        temp_a3->unk20 = 0;
        temp_a3->unk4 = 0xD;
        temp_a3->unk1C = 0;
        D_800DC5EC->unk32 = 0x12C;
        D_800DC5F0->unk32 = -0x3C;
        D_8015F894 = 4;
        phi_v0_2 = func_800CA330(0x19, temp_a1_4);
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AC458.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A9208(?); // extern

void func_800AC978(void *arg0) {
    s32 temp_v0;
    s32 temp_v0_2;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                temp_v0_2 = arg0->unk1C;
                if (temp_v0_2 != 0) {
                    arg0->unk1C = temp_v0_2 - 0x33;
                }
                // Duplicate return node #10. Try simplifying control flow for better match
                return;
            }
            // Duplicate return node #10. Try simplifying control flow for better match
            return;
        }
        func_800A9208(0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            return;
        }
        return;
    }
    arg0->unkC = 0x14A;
    arg0->unk4 = 1;
    arg0->unk1C = 0xFF;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AC978.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?, void *); // extern
s32 func_800B4520(void *); // extern
? func_800CA330(?); // extern
? play_sound2(?, void *); // extern
extern void *gControllerFive;
extern f64 D_800F26C0;
extern f64 D_800F26C8;
extern f64 D_800F26D0;

void func_800ACA14(void *arg0) {
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    s32 temp_a0;
    s32 temp_v0;
    s32 temp_v0_3;
    s32 temp_v0_4;
    u16 temp_v1;
    u16 temp_v1_2;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_t5;
    void *temp_v0_2;
    s32 phi_a0;
    void *phi_a1;
    u16 phi_v1;
    void *phi_a1_2;
    s32 phi_v0;
    void *phi_a1_3;
    void *phi_a1_4;

    temp_v0 = arg0->unk4;
    temp_a1 = arg0;
    phi_a1_3 = temp_a1;
    phi_a1_4 = temp_a1;
    if (temp_v0 != 0) {
        if ((temp_v0 != 0xB) && (temp_v0 != 0xC)) {
            phi_v0 = arg0->unk20;
        } else {
            arg0 = temp_a1;
            temp_a1_2 = arg0;
            phi_a1 = temp_a1_2;
            phi_a1_4 = temp_a1_2;
            if (func_800B4520(temp_a1) != 0) {

            } else {
                temp_v0_2 = gControllerFive;
                temp_v1 = temp_v0_2->unk6;
                temp_a0 = temp_v1 | temp_v0_2->unkC;
                phi_a0 = temp_a0;
                phi_v1 = temp_v1;
                if ((temp_a0 & 0x800) != 0) {
                    temp_v0_3 = temp_a1_2->unk4;
                    if (temp_v0_3 >= 0xC) {
                        temp_a1_2->unk4 = temp_v0_3 - 1;
                        arg0 = temp_a1_2;
                        play_sound2(0x49008000, temp_a1_2);
                        temp_f0 = arg0->unk24;
                        phi_a1 = arg0;
                        if (temp_f0 < D_800F26C0) {
                            arg0->unk24 = temp_f0 + 4.0;
                        }
                        arg0->unk8 = -1;
                        temp_t5 = gControllerFive;
                        temp_v1_2 = temp_t5->unk6;
                        phi_a0 = temp_v1_2 | temp_t5->unkC;
                        phi_v1 = temp_v1_2;
                    }
                }
                phi_a1_2 = phi_a1;
                if ((phi_a0 & 0x400) != 0) {
                    temp_v0_4 = phi_a1->unk4;
                    if (temp_v0_4 < 0xC) {
                        phi_a1->unk4 = temp_v0_4 + 1;
                        arg0 = phi_a1;
                        play_sound2(0x49008000, phi_a1);
                        temp_f0_2 = arg0->unk24;
                        phi_a1_2 = arg0;
                        if (temp_f0_2 < D_800F26C8) {
                            arg0->unk24 = temp_f0_2 + 4.0;
                        }
                        arg0->unk8 = 1;
                        phi_v1 = gControllerFive->unk6;
                    }
                }
                phi_a1_4 = phi_a1_2;
                if ((phi_v1 & 0x9000) != 0) {
                    arg0 = phi_a1_2;
                    func_8009DFE0(0x1E, phi_a1_2);
                    func_800CA330(0x19);
                    play_sound2(0x4900801B);
                    temp_f0_3 = arg0->unk24;
                    phi_a1_4 = arg0;
                    if (temp_f0_3 < D_800F26D0) {
                        arg0->unk24 = temp_f0_3 + 4.0;
                    }
                }
            }
            goto block_24;
        }
    } else {
        if (temp_a1->unk20 >= 0xB) {
            temp_a1->unk1C = temp_a1->unk1C + 3;
        }
        if (temp_a1->unk1C >= 0x65) {
            temp_a1->unk4 = 0xB;
            temp_a1->unk1C = 0;
        }
block_24:
        phi_v0 = phi_a1_4->unk20;
        phi_a1_3 = phi_a1_4;
    }
    if (phi_v0 < 0x28) {
        phi_a1_3->unk20 = phi_v0 + 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ACA14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?, void *);                         /* extern */
? add_8018D9E0_entry(s32, ?, ?, s8);                     /* extern */
void *func_800AAEF4(?, void *);                     /* extern */
? play_sound2(?, void *);                           /* extern */

void func_800ACC50(void *arg0) {
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    s32 temp_a0;
    s32 temp_s0;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_v0_3;
    u16 temp_v1;
    u16 temp_v1_2;
    u32 temp_t6;
    u32 temp_v0_2;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_t8_2;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_a0;
    void *phi_a1;
    u16 phi_v1;
    void *phi_a1_2;
    temp_t6 = arg0->unk4;
    temp_a1 = arg0;
    switch (temp_t6) {
    case 0:
        temp_t8 = temp_a1->unk1C + 3;
        temp_a1->unk1C = temp_t8;
        if ((temp_t8 >= 0x65) && (temp_a1->unk4 = 1, temp_a1->unk1C = 0, phi_s0 = 0, (D_8018EDF3 > ZERO_PLAYERS_SELECTED))) {
            do {
                add_8018D9E0_entry(phi_s0 + 0xB1, 0, 0, 5 - phi_s0);
                temp_s0 = phi_s0 + 1;
                phi_s0 = temp_s0;
            } while (temp_s0 < D_8018EDF3);
            return;
        }
    default:
        return;
    case 1:
        arg0 = temp_a1;
        if (func_800AAEF4(0xB1, temp_a1)->unk4 >= 2) {
            arg0->unk4 = 2;
            return;
        }
        /* Duplicate return node #30. Try simplifying control flow for better match */
        return;
    case 2:
        temp_t9 = temp_a1->unk1C + 0x20;
        temp_a1->unk1C = temp_t9;
        if (temp_t9 >= 0x100) {
            if (gModeSelection == VERSUS) {
                temp_a1->unk4 = D_8018EDF4;
            } else {
                temp_a1->unk4 = D_8018EDF6;
            }
            temp_a1->unk1C = 0;
            return;
        }
        /* Duplicate return node #30. Try simplifying control flow for better match */
        return;
    case 10:
    case 11:
    case 12:
    case 13:
        arg0 = temp_a1;
        temp_a1_2 = arg0;
        phi_a1 = temp_a1_2;
        if (func_800B4520(arg0) == 0) {
            temp_v0 = gControllerFive;
            temp_v1 = temp_v0->unk6;
            temp_a0 = temp_v1 | temp_v0->unkC;
            phi_a0 = temp_a0;
            phi_v1 = temp_v1;
            if ((temp_a0 & 0x800) != 0) {
                temp_v0_2 = temp_a1_2->unk4;
                if (temp_v0_2 >= 0xB) {
                    temp_a1_2->unk4 = temp_v0_2 - 1;
                    arg0 = temp_a1_2;
                    play_sound2(0x49008000, temp_a1_2);
                    temp_f0 = arg0->unk24;
                    phi_a1 = arg0;
                    if (temp_f0 < 4.2) {
                        arg0->unk24 = temp_f0 + 4.0;
                    }
                    arg0->unk8 = -1;
                    temp_t8_2 = gControllerFive;
                    temp_v1_2 = temp_t8_2->unk6;
                    phi_a0 = temp_v1_2 | temp_t8_2->unkC;
                    phi_v1 = temp_v1_2;
                }
            }
            phi_a1_2 = phi_a1;
            if ((phi_a0 & 0x400) != 0) {
                temp_v0_3 = phi_a1->unk4;
                if (temp_v0_3 < 0xD) {
                    phi_a1->unk4 = temp_v0_3 + 1;
                    arg0 = phi_a1;
                    play_sound2(0x49008000, phi_a1);
                    temp_f0_2 = arg0->unk24;
                    phi_a1_2 = arg0;
                    if (temp_f0_2 < 4.2) {
                        arg0->unk24 = temp_f0_2 + 4.0;
                    }
                    arg0->unk8 = 1;
                    phi_v1 = gControllerFive->unk6;
                }
            }
            if ((phi_v1 & 0x9000) != 0) {
                arg0 = phi_a1_2;
                func_8009DFE0(0x1E, phi_a1_2);
                play_sound2(0x49008016);
                if (gModeSelection == VERSUS) {
                    D_8018EDF4 = arg0->unk4;
                } else {
                    D_8018EDF6 = arg0->unk4;
                }
                temp_f0_3 = arg0->unk24;
                if (temp_f0_3 < 4.2) {
                    arg0->unk24 = temp_f0_3 + 4.0;
                }
            }
        }
        /* Duplicate return node #30. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ACC50.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A640(s32, ?, s32, s32);                  /* extern */
? func_800A9208(void *, s16, s32);                  /* extern */
? func_800A9278(void *, s16);                       /* extern */
void *func_800AAEF4(?, s8, s32);                    /* extern */
? func_800C90F4(s32, s32, s32);                     /* extern */
? func_800CA24C(s32);                               /* extern */
extern ? gPlayerPositions;
extern ? D_8018DEE4;
static ? D_800E72F8;                                /* unable to generate initializer; const */
static ? D_800E7300;                                /* unable to generate initializer; const */
static ? D_800E8380;                                /* unable to generate initializer; const */
static ? D_800E83A0;                                /* unable to generate initializer; const */
static ? D_800E8440;                                /* unable to generate initializer; const */
static ? D_800E85F7;                                /* unable to generate initializer; const */
static ? gCharacterSelections;                                /* unable to generate initializer; const */
static ? D_800EFD64;                                /* unable to generate initializer; const */

void func_800ACF40(void *arg0) {
    s16 *sp3C;
    s32 sp38;
    s32 sp34;
    s32 sp24;
    s16 *temp_v0_2;
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_t7_2;
    s32 temp_v0;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s8 temp_a1;
    u32 temp_t7;
    s32 phi_v1;

    temp_v0 = arg0->unk0;
    temp_t7 = arg0->unk4;
    temp_a1 = *(&D_800EFD64 + *(&D_800E85F7 + temp_v0));
    temp_a2 = temp_v0 - 0xB1;
    switch (temp_t7) {
    case 0:
        arg0->unkC = D_800E72F8.unk0;
        arg0->unk4 = 1;
        arg0->unk10 = D_800E72F8.unk2;
        return;
    case 1:
        temp_v0_2 = ((D_8018EDF3 << 5) + (temp_a2 * 8)) - 0x40 + &D_800E7300;
        sp3C = temp_v0_2;
        func_800A9208(arg0, *temp_v0_2, temp_a2);
        func_800A9278(arg0, sp3C->unk2);
        if (sp3C->unk0 == arg0->unkC) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_v0_3 = gModeSelection;
        phi_v1 = 0;
        if (temp_v0_3 != 2) {
            if (temp_v0_3 != 3) {

            } else if (temp_a2 != gPlayerWinningIndex) {
                goto block_11;
            }
        } else if (*(&gPlayerPositions + (temp_a2 * 4)) != 0) {
block_11:
            phi_v1 = 1;
        }
        if ((phi_v1 == 0) && (temp_t7_2 = arg0->unk20 + 1, arg0->unk20 = temp_t7_2, ((temp_t7_2 < 0x1F) == 0)) && (sp34 = temp_a1, sp38 = temp_a2, ((func_800AAEF4(0xB0, temp_a1, temp_a2)->unk4 < 2) == 0))) {
            sp38 = temp_a2;
            func_8009A640(arg0->unk18, 0, temp_a2, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_a1 * 4))));
            arg0->unk4 = 3;
            temp_a0 = temp_a2 & 0xFF;
            sp24 = temp_a0;
            func_800CA24C(temp_a0);
            func_800C90F4(temp_a0, (*(&gCharacterSelections + temp_a2) * 0x10) + 0x29008007, temp_a2);
            return;
        }
        /* Duplicate return node #18. Try simplifying control flow for better match */
        return;
    case 3:
        temp_v0_4 = temp_a1 * 4;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *(&D_800E8440 + temp_v0_4)) {
            sp38 = temp_a2;
            func_8009A640(arg0->unk18, 0, temp_a2, segmented_to_virtual_dupe(*(&D_800E83A0 + temp_v0_4)));
            arg0->unk4 = 4;
        }
        /* Duplicate return node #18. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ACF40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800921B4();                                  /* extern */
? add_8018D9E0_entry(?, ?, ?, ?);                        /* extern */
? func_800A9208(void *, ?);                         /* extern */

void func_800AD1A4(void *arg0) {
    s32 temp_t2;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        arg0->unkC = 0x14A;
        arg0->unk4 = 1;
        func_800921B4();
        add_8018D9E0_entry(0xBB, 0, 0, 0);
        return;
    case 1:
        func_800A9208(arg0, 0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_t2 = arg0->unk20 + 1;
        arg0->unk20 = temp_t2;
        if (temp_t2 >= 0x15) {
            arg0->unk4 = 3;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 3:
        if (D_8018D9D8 != 0) {
            func_800921B4();
            arg0->unk4 = 4;
            arg0->unk1C = arg0->unkC;
            add_8018D9E0_entry(0xBA, 0, 0, 0);
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 4:
        temp_v0 = arg0->unk1C;
        arg0->unkC = temp_v0;
        if (temp_v0 < 0x14A) {
            if (D_8018D9D8 != 0) {
                arg0->unk1C = temp_v0 + 0x20;
                return;
            }
            arg0->unk1C = temp_v0 + 0x10;
            return;
        }
        arg0->unk0 = 0;
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AD1A4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_800B4520();                                /* extern */
s32 func_800B5F30();                                /* extern */
s32 func_800B6348(s32);                             /* extern */
? func_800B6708();                                  /* extern */
s32 osPfsFindFile(? *, u16, s32, ? *, ? *, ? *);    /* extern */
? play_sound2(?, u16);                              /* extern */
extern void *D_800DC5EC;
extern void *D_800DC5F0;
extern u16 D_80162DD4;
extern s32 D_80162DF8;
extern void *D_8018D9BC;
extern s8 D_8018D9D8;
extern ? D_8018E868;
extern s32 D_8018EB78;
extern s32 D_8018EB7C;
extern s32 gControllerPakNumPagesFree;
extern ? D_8018EB84;
extern s8 D_8018EDF5;
static u16 D_800E86F0;                              /* type too large by 2; unable to generate initializer; const */
static s32 D_800E86F4 = 0x4E4B544A;                 /* const */
static s8 D_800E86F8 = 0;                           /* const */
static ? D_800F2E64;                                /* unable to generate initializer; const */
static ? D_800F2E74;                                /* unable to generate initializer; const */

void func_800AD2E8(void *arg0) {
    s32 sp28;
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    f64 temp_f0_4;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a2;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s8 temp_t3;
    struct Controller *temp_t6;
    struct Controller *temp_v1_2;
    u16 temp_a1;
    u16 temp_a1_2;
    u32 temp_t2;
    u32 temp_t9;
    u32 temp_v0;
    u32 temp_v0_3;
    u32 temp_v0_4;
    u32 temp_v0_5;
    u32 temp_v0_6;
    void *temp_v0_2;
    void *temp_v1;
    s32 phi_a1;
    s32 phi_a0;
    u16 phi_a1_2;
    u16 phi_a1_3;
    s32 phi_v1;
    s32 phi_v1_2;

    temp_v0 = arg0->unk4;
    if (temp_v0 < 0x20) {
        switch (temp_v0) {                          /* switch 1 */
        case 0:                                     /* switch 1 */
            arg0->unkC = -0xA0;
            arg0->unk4 = 1;
            D_8018D9BC->unk0 = gGP1stPlaceReward;
            D_8018D9BC->unk1 = gGP2ndPlaceReward;
            D_8018D9BC->unk2 = gGP3rdPlaceReward;
            D_8018D9BC->unk3 = gGP4thPlaceReward;
            arg0->unk20 = arg0->unkC;
            return;
        case 1:                                     /* switch 1 */
            temp_a0 = arg0->unk20;
            arg0->unkC = temp_a0;
            phi_a1 = 0x10;
            if (D_8018D9D8 != 0) {
                phi_a1 = 0x20;
            }
            temp_a2 = temp_a0 + phi_a1;
            if (temp_a2 < 0) {
                arg0->unk20 = temp_a2;
                temp_v0_2 = D_800DC5EC;
                temp_v0_2->unk30 = temp_v0_2->unk30 + phi_a1;
                temp_v1 = D_800DC5F0;
                temp_v1->unk30 = temp_v1->unk30 - phi_a1;
                return;
            }
            arg0->unk20 = 0;
            arg0->unkC = 0;
            temp_t3 = D_8018EDF5;
            arg0->unk4 = temp_t3;
            if ((temp_t3 == 9) && (D_80162DF8 == 1)) {
                arg0->unk4 = temp_t3 - 1;
            }
            D_800DC5EC->unk30 = 0xF0;
            D_800DC5F0->unk30 = 0x50;
            return;
        case 5:                                     /* switch 1 */
        case 6:                                     /* switch 1 */
        case 7:                                     /* switch 1 */
        case 8:                                     /* switch 1 */
        case 9:                                     /* switch 1 */
        case 10:                                    /* switch 1 */
            if (func_800B4520() == 0) {
                temp_v1_2 = gControllerOne;
                temp_a1 = temp_v1_2->buttonPressed;
                temp_a0_2 = temp_a1 | temp_v1_2->stickPressed;
                phi_a0 = temp_a0_2;
                phi_a1_2 = temp_a1;
                if ((temp_a0_2 & 0x800) != 0) {
                    temp_v0_3 = arg0->unk4;
                    temp_t2 = temp_v0_3 - 1;
                    if (temp_v0_3 >= 6) {
                        arg0->unk4 = temp_t2;
                        if ((D_80162DF8 == 1) && (temp_t2 == 9)) {
                            arg0->unk4 = temp_t2 - 1;
                        }
                        play_sound2(0x49008000, temp_a1);
                        temp_f0 = arg0->unk24;
                        if (temp_f0 < 4.2) {
                            arg0->unk24 = temp_f0 + 4.0;
                        }
                        arg0->unk8 = -1;
                        temp_t6 = gControllerOne;
                        temp_a1_2 = temp_t6->buttonPressed;
                        phi_a0 = temp_a1_2 | temp_t6->stickPressed;
                        phi_a1_2 = temp_a1_2;
                    }
                }
                phi_a1_3 = phi_a1_2;
                if ((phi_a0 & 0x400) != 0) {
                    temp_v0_4 = arg0->unk4;
                    temp_t9 = temp_v0_4 + 1;
                    if (temp_v0_4 < 0xA) {
                        arg0->unk4 = temp_t9;
                        if ((D_80162DF8 == 1) && (temp_t9 == 9)) {
                            arg0->unk4 = temp_t9 + 1;
                        }
                        temp_v0_5 = arg0->unk4;
                        if ((temp_v0_5 == 0xA) && (D_80162DD4 != 0)) {
                            arg0->unk4 = temp_v0_5 - 2;
                            phi_a1_3 = gControllerOne->buttonPressed;
                        } else {
                            play_sound2(0x49008000, phi_a1_2);
                            temp_f0_2 = arg0->unk24;
                            if (temp_f0_2 < 4.2) {
                                arg0->unk24 = temp_f0_2 + 4.0;
                            }
                            arg0->unk8 = 1;
                            phi_a1_3 = gControllerOne->buttonPressed;
                        }
                    }
                }
                if ((phi_a1_3 & 0x9000) != 0) {
                    temp_v0_6 = arg0->unk4;
                    if (temp_v0_6 == 0xA) {
                        temp_f0_3 = arg0->unk24;
                        phi_v1 = 0;
                        if (temp_f0_3 < 4.2) {
                            arg0->unk24 = temp_f0_3 + 4.0;
                        }
                        if (D_800E86F8 != 0) {
                            sp28 = 0;
                            temp_v0_7 = osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84);
                            if (temp_v0_7 != 0) {
                                if (temp_v0_7 != 2) {
                                    if (temp_v0_7 != 5) {
                                        goto block_42;
                                    }
                                } else {
block_42:
                                    D_800E86F8 = 0;
                                }
                            } else {
                                func_800B6708();
                                arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x11;
                                sp28 = 1;
                                play_sound2(0x49008001);
                                phi_v1 = 1;
                            }
                        }
                        if (phi_v1 == 0) {
                            if (D_800E86F8 == 0) {
                                sp28 = phi_v1;
                                temp_v0_8 = func_800B5F30();
                                phi_v1_2 = phi_v1;
                                switch (temp_v0_8) { /* switch 2 */
                                case -1:            /* switch 2 */
                                    arg0->unk4 = 0xB;
                                    phi_v1_2 = 1;
                                    break;
                                case -3:            /* switch 2 */
                                case -2:            /* switch 2 */
                                    arg0->unk4 = 0xC;
                                    phi_v1_2 = 1;
                                    break;
                                case 1:             /* switch 2 */
                                case 11:            /* switch 2 */
                                    arg0->unk4 = 0xB;
                                    phi_v1_2 = 1;
                                    break;
                                case 10:            /* switch 2 */
                                    arg0->unk4 = 0xC;
                                    phi_v1_2 = 1;
                                    break;
                                default:            /* switch 2 */
                                    arg0->unk4 = 0xC;
                                    phi_v1_2 = 1;
                                    break;
                                }
                                if (phi_v1_2 != 0) {
                                    play_sound2(0x4900FF07);
                                    return;
                                }
                                if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) == 0) {
                                    func_800B6708();
                                    arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x11;
                                    play_sound2(0x49008001);
                                    return;
                                }
                                goto block_56;
                            }
block_56:
                            if (D_8018EB7C >= D_8018EB78) {
                                arg0->unk4 = 0xE;
                                play_sound2(0x4900FF07);
                                return;
                            }
                            if (gControllerPakNumPagesFree >= 0x79) {
                                arg0->unk4 = 0x13;
                                arg0->unk1C = 0;
                                play_sound2(0x49008001);
                                return;
                            }
                            arg0->unk4 = 0xE;
                            play_sound2(0x4900FF07);
                            return;
                        }
                        /* Duplicate return node #127. Try simplifying control flow for better match */
                        return;
                    }
                    arg0->unk1C = temp_v0_6;
                    D_8018EDF5 = temp_v0_6;
                    arg0->unk4 = 0x1E;
                    arg0->unk20 = arg0->unk10;
                    play_sound2(0x49008015, phi_a1_3);
                    temp_f0_4 = arg0->unk24;
                    if (temp_f0_4 < 4.2) {
                        arg0->unk24 = temp_f0_4 + 4.0;
                    }
                    /* Duplicate return node #127. Try simplifying control flow for better match */
                    return;
                }
                /* Duplicate return node #127. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #127. Try simplifying control flow for better match */
            return;
        }
    } else {
    case 2:                                         /* switch 1 */
    case 3:                                         /* switch 1 */
    case 4:                                         /* switch 1 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AD2E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?, void *, struct Controller *, s32 *); /* extern */
? func_800C9F90(?);                                 /* extern */
? func_800CA330(?);                                 /* extern */
? func_8028DF38(?, void *, struct Controller *, s32 *); /* extern */
? play_sound2(?, void *, struct Controller *, s32 *); /* extern */
static ? D_800F0B50;                                /* unable to generate initializer; const */
static ? D_800F0B54;                                /* unable to generate initializer; const */

void func_800ADF48(void *arg0) {
    struct Controller *sp18;
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    s32 temp_a0;
    s32 temp_t2;
    s32 temp_v0_2;
    s8 temp_v0_3;
    struct Controller *temp_a2;
    u16 temp_v1;
    u16 temp_v1_2;
    u32 temp_t7;
    u32 temp_v0;
    void *temp_a1;
    s32 phi_a0;
    void *phi_a1;
    u16 phi_v1;
    void *phi_a1_2;

    if (D_800DC5FC != 0) {
        temp_t7 = arg0->unk4;
        switch (temp_t7) {
        case 0:
            arg0->unk4 = *(&D_800F0B50 + gModeSelection);
            return;
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 21:
        case 22:
        case 23:
        case 24:
        case 31:
        case 32:
        case 41:
        case 42:
        case 43:
        case 44:
            arg0 = arg0;
            temp_a1 = arg0;
            phi_a1 = temp_a1;
            if (func_800B4520(arg0) == 0) {
                temp_t2 = (D_800DC5FC * 0x10) - 0x10;
                temp_a2 = temp_t2 + gControllers;
                temp_v1 = temp_a2->buttonPressed;
                temp_a0 = temp_v1 | temp_a2->stickPressed;
                phi_a0 = temp_a0;
                phi_v1 = temp_v1;
                if ((temp_a0 & 0x800) != 0) {
                    temp_v0 = temp_a1->unk4;
                    if (*(&D_800F0B50 + gModeSelection) < temp_v0) {
                        temp_a1->unk4 = temp_v0 - 1;
                        sp18 = temp_a2;
                        arg0 = temp_a1;
                        play_sound2(0x49008000, temp_a1, temp_a2, &gModeSelection);
                        temp_f0 = arg0->unk24;
                        phi_a1 = arg0;
                        if (temp_f0 < 4.2) {
                            arg0->unk24 = temp_f0 + 4.0;
                        }
                        arg0->unk8 = -1;
                        temp_v1_2 = temp_a2->buttonPressed;
                        phi_a0 = temp_v1_2 | temp_a2->stickPressed;
                        phi_v1 = temp_v1_2;
                    }
                }
                phi_a1_2 = phi_a1;
                if ((phi_a0 & 0x400) != 0) {
                    temp_v0_2 = phi_a1->unk4;
                    if (temp_v0_2 < *(&D_800F0B54 + gModeSelection)) {
                        phi_a1->unk4 = temp_v0_2 + 1;
                        sp18 = temp_t2 + gControllers;
                        arg0 = phi_a1;
                        play_sound2(0x49008000, phi_a1, temp_t2 + gControllers, &gModeSelection);
                        temp_f0_2 = arg0->unk24;
                        phi_a1_2 = arg0;
                        if (temp_f0_2 < 4.2) {
                            arg0->unk24 = temp_f0_2 + 4.0;
                        }
                        arg0->unk8 = 1;
                        phi_v1 = (temp_t2 + gControllers)->buttonPressed;
                    }
                }
                if (((phi_v1 & 0x4000) != 0) && (temp_v0_3 = *(&D_800F0B50 + gModeSelection), (phi_a1_2->unk4 != temp_v0_3))) {
                    phi_a1_2->unk4 = temp_v0_3;
                    play_sound2(0x49008002, phi_a1_2, temp_t2 + gControllers, &gModeSelection);
                    return;
                }
                if ((phi_v1 & 0x9000) != 0) {
                    if (phi_a1_2->unk4 == *(&D_800F0B50 + gModeSelection)) {
                        phi_a1_2->unk4 = 0;
                        D_800DC5FC = 0;
                        func_8028DF38(0x1E, phi_a1_2, temp_t2 + gControllers, &gModeSelection);
                        func_800C9F90(0);
                        return;
                    }
                    arg0 = phi_a1_2;
                    func_8009DFE0(0x1E, phi_a1_2, temp_t2 + gControllers, &gModeSelection);
                    play_sound2(0x4900801B);
                    func_800CA330(0x3C);
                    temp_f0_3 = arg0->unk24;
                    if (temp_f0_3 < 4.2) {
                        arg0->unk24 = temp_f0_3 + 4.0;
                        return;
                    }
                    /* Duplicate return node #24. Try simplifying control flow for better match */
                    return;
                }
                /* Duplicate return node #24. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #24. Try simplifying control flow for better match */
            return;
        }
    } else {
        arg0->unk4 = 0;
    default:
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ADF48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?);                                 /* extern */
? func_800B6708();                                  /* extern */
? func_800CA330(?);                                 /* extern */
? func_800CA388(?);                                 /* extern */
s32 osPfsFindFile(? *, u16, s32, ? *, ? *, ? *);    /* extern */
? play_sound2(?, s32);                              /* extern */
extern ? D_8018E868;
extern ? D_8018EB84;
extern ? D_8018EE10;
static ? D_800F2E64;                                /* unable to generate initializer; const */
static ? D_800F2E74;                                /* unable to generate initializer; const */
s16 D_800DC5B8;                                     /* unable to generate initializer */
u16 D_800E86F0;                                     /* unable to generate initializer; const */

void func_800AE218(void *arg0) {
    s32 sp28;
    f64 temp_f0;
    f64 temp_f0_10;
    f64 temp_f0_11;
    f64 temp_f0_2;
    f64 temp_f0_3;
    f64 temp_f0_4;
    f64 temp_f0_5;
    f64 temp_f0_6;
    f64 temp_f0_7;
    f64 temp_f0_8;
    f64 temp_f0_9;
    s32 temp_a0_4;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_t5;
    s32 temp_t6_2;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    u16 temp_a0;
    u16 temp_a0_2;
    u16 temp_a0_3;
    u16 temp_a0_5;
    u16 temp_a0_6;
    void *temp_t0;
    void *temp_t2;
    void *temp_t6;
    void *temp_v0_2;
    void *temp_v0_5;
    void *temp_v0_6;
    s32 phi_a1;
    u16 phi_a0;
    s32 phi_v1;
    s32 phi_v1_2;
    s32 phi_a1_2;
    s32 phi_a1_3;
    u16 phi_a0_2;

    if (arg0->unk4 != 0) {
        D_800DC5B8 = 0;
    }
    switch (arg0->unk4) {                           /* switch 1 */
    case 0:                                         /* switch 1 */
        temp_v0 = arg0->unk1C;
        if (temp_v0 < 0x1E) {
            arg0->unk1C = temp_v0 + 1;
        }
        if ((gControllerOne->unk6 & 0x1000) != 0) {
            arg0->unk4 = 0xF;
            play_sound2(0x49008005);
            return;
        }
        if (D_8018CAE0 != 0) {
            arg0->unk4 = 1;
            arg0->unk1C = 0;
            return;
        }
    default:                                        /* switch 1 */
        return;
    case 1:                                         /* switch 1 */
        temp_t5 = arg0->unk1C + 3;
        arg0->unk1C = temp_t5;
        if (temp_t5 >= 0x8D) {
            arg0->unk4 = 0xF;
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 11:                                        /* switch 1 */
    case 12:                                        /* switch 1 */
    case 13:                                        /* switch 1 */
    case 14:                                        /* switch 1 */
    case 15:                                        /* switch 1 */
    case 16:                                        /* switch 1 */
        if (func_800B4520() == 0) {
            temp_v0_2 = gControllerOne;
            temp_a0 = temp_v0_2->unk6;
            temp_a1 = temp_a0 | temp_v0_2->unkC;
            phi_a1 = temp_a1;
            phi_a0 = temp_a0;
            if ((temp_a1 & 0x800) != 0) {
                temp_v1 = arg0->unk4;
                if (temp_v1 >= 0xC) {
                    arg0->unk4 = temp_v1 - 1;
                    play_sound2(0x49008000, temp_a1);
                    temp_f0 = arg0->unk24;
                    if (temp_f0 < 4.2) {
                        arg0->unk24 = temp_f0 + 4.0;
                    }
                    arg0->unk8 = -1;
                    temp_t2 = gControllerOne;
                    temp_a0_2 = temp_t2->unk6;
                    phi_a1 = temp_a0_2 | temp_t2->unkC;
                    phi_a0 = temp_a0_2;
                }
            }
            if ((phi_a1 & 0x400) != 0) {
                temp_v1_2 = arg0->unk4;
                if (temp_v1_2 < 0x10) {
                    arg0->unk4 = temp_v1_2 + 1;
                    play_sound2(0x49008000, phi_a1);
                    temp_f0_2 = arg0->unk24;
                    if (temp_f0_2 < 4.2) {
                        arg0->unk24 = temp_f0_2 + 4.0;
                    }
                    arg0->unk8 = 1;
                    phi_a0 = gControllerOne->unk6;
                }
            }
            if ((phi_a0 & 0x9000) != 0) {
                if (arg0->unk4 == 0x10) {
                    temp_f0_3 = arg0->unk24;
                    phi_v1 = 0;
                    if (temp_f0_3 < 4.2) {
                        arg0->unk24 = temp_f0_3 + 4.0;
                    }
                    if (D_800E86F8 != 0) {
                        sp28 = 0;
                        temp_v0_3 = osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84);
                        if (temp_v0_3 != 0) {
                            if (temp_v0_3 != 2) {
                                if (temp_v0_3 != 5) {
                                    goto block_34;
                                }
                            } else {
block_34:
                                D_800E86F8 = 0;
                            }
                        } else {
                            func_800B6708();
                            arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x1E;
                            phi_v1 = 1;
                        }
                    }
                    if (phi_v1 != 0) {
                        play_sound2(0x49008001);
                        return;
                    }
                    if (D_800E86F8 == 0) {
                        sp28 = phi_v1;
                        temp_v0_4 = func_800B5F30();
                        phi_v1_2 = phi_v1;
                        switch (temp_v0_4) {        /* switch 2 */
                        case -1:                    /* switch 2 */
                            arg0->unk4 = 0x15;
                            phi_v1_2 = 1;
                            break;
                        case -3:                    /* switch 2 */
                        case -2:                    /* switch 2 */
                            arg0->unk4 = 0x16;
                            phi_v1_2 = 1;
                            break;
                        case 1:                     /* switch 2 */
                        case 11:                    /* switch 2 */
                            arg0->unk4 = 0x15;
                            phi_v1_2 = 1;
                            break;
                        case 10:                    /* switch 2 */
                            arg0->unk4 = 0x16;
                            phi_v1_2 = 1;
                            break;
                        default:                    /* switch 2 */
                            arg0->unk4 = 0x16;
                            phi_v1_2 = 1;
                            break;
                        }
                        if (phi_v1_2 != 0) {
                            play_sound2(0x4900FF07);
                            return;
                        }
                        if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) == 0) {
                            func_800B6708();
                            arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x1E;
                            play_sound2(0x49008001);
                            return;
                        }
                        goto block_49;
                    }
block_49:
                    if (D_8018EB7C >= D_8018EB78) {
                        arg0->unk4 = 0x18;
                        play_sound2(0x4900FF07);
                        return;
                    }
                    if (D_8018EB80 >= 0x79) {
                        arg0->unk4 = 0x20;
                        arg0->unk1C = 0;
                        play_sound2(0x49008001);
                        return;
                    }
                    arg0->unk4 = 0x18;
                    play_sound2(0x4900FF07);
                    return;
                }
                func_8009DFE0(0x1E);
                play_sound2(0x49008016);
                func_800CA330(0x19);
                func_800CA388(0x19);
                temp_f0_4 = arg0->unk24;
                if (temp_f0_4 < 4.2) {
                    arg0->unk24 = temp_f0_4 + 4.0;
                    return;
                }
                /* Duplicate return node #109. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #109. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 21:                                        /* switch 1 */
    case 22:                                        /* switch 1 */
    case 23:                                        /* switch 1 */
    case 24:                                        /* switch 1 */
    case 25:                                        /* switch 1 */
    case 26:                                        /* switch 1 */
    case 41:                                        /* switch 1 */
        if (((gControllerOne->unk6 & 0xD000) != 0) && (arg0->unk4 = 0x10, play_sound2(0x49008002), temp_f0_5 = arg0->unk24, (temp_f0_5 < 4.2))) {
            arg0->unk24 = temp_f0_5 + 4.0;
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 30:                                        /* switch 1 */
    case 31:                                        /* switch 1 */
        arg0->unk20 = arg0->unk4 - 0x1E;
        if (func_800B639C((gCupSelection * 4) + gCupCourseSelection) != arg0->unk20) {
            temp_v0_5 = gControllerOne;
            temp_a1_2 = temp_v0_5->unk6 | temp_v0_5->unkC;
            phi_a1_2 = temp_a1_2;
            if ((temp_a1_2 & 0x800) != 0) {
                temp_v1_3 = arg0->unk4;
                if (temp_v1_3 >= 0x1F) {
                    arg0->unk4 = temp_v1_3 - 1;
                    play_sound2(0x49008000, temp_a1_2);
                    temp_f0_6 = arg0->unk24;
                    if (temp_f0_6 < 4.2) {
                        arg0->unk24 = temp_f0_6 + 4.0;
                    }
                    arg0->unk8 = -1;
                    temp_t0 = gControllerOne;
                    phi_a1_2 = temp_t0->unk6 | temp_t0->unkC;
                }
            }
            if ((phi_a1_2 & 0x400) != 0) {
                temp_v1_4 = arg0->unk4;
                if (temp_v1_4 < 0x1F) {
                    arg0->unk4 = temp_v1_4 + 1;
                    play_sound2(0x49008000, phi_a1_2);
                    temp_f0_7 = arg0->unk24;
                    if (temp_f0_7 < 4.2) {
                        arg0->unk24 = temp_f0_7 + 4.0;
                    }
                    arg0->unk8 = 1;
                }
            }
        }
        temp_a0_3 = gControllerOne->unk6;
        if ((temp_a0_3 & 0x4000) != 0) {
            arg0->unk4 = 0x10;
            play_sound2(0x49008002);
            return;
        }
        if ((temp_a0_3 & 0x9000) != 0) {
            temp_a0_4 = arg0->unk20;
            if (((temp_a0_4 << 7) + &D_8018EE10)->unk4 == 0) {
                arg0->unk4 = 0x28;
                arg0->unk1C = 0;
            } else if (func_800B63F0(temp_a0_4) == 0) {
                arg0->unk4 = 0x1A;
            } else {
                arg0->unk4 = 0x23;
            }
            play_sound2(0x49008001);
            temp_f0_8 = arg0->unk24;
            if (temp_f0_8 < 4.2) {
                arg0->unk24 = temp_f0_8 + 4.0;
                return;
            }
            /* Duplicate return node #109. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 32:                                        /* switch 1 */
        if ((arg0->unk1C == 1) && (func_800B6A68() != 0)) {
            arg0->unk4 = 0x19;
            return;
        }
        temp_t9 = arg0->unk1C + 1;
        arg0->unk1C = temp_t9;
        if (temp_t9 >= 2) {
            arg0->unk4 = 0x1E;
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 35:                                        /* switch 1 */
    case 36:                                        /* switch 1 */
        temp_v0_6 = gControllerOne;
        temp_a0_5 = temp_v0_6->unk6;
        temp_a1_3 = temp_a0_5 | temp_v0_6->unkC;
        phi_a1_3 = temp_a1_3;
        phi_a0_2 = temp_a0_5;
        if (((temp_a1_3 & 0x800) != 0) && (arg0->unk4 >= 0x24)) {
            arg0->unk4 = arg0->unk4 - 1;
            play_sound2(0x49008000, temp_a1_3);
            temp_f0_9 = arg0->unk24;
            if (temp_f0_9 < 4.2) {
                arg0->unk24 = temp_f0_9 + 4.0;
            }
            arg0->unk8 = -1;
            temp_t6 = gControllerOne;
            temp_a0_6 = temp_t6->unk6;
            phi_a1_3 = temp_a0_6 | temp_t6->unkC;
            phi_a0_2 = temp_a0_6;
        }
        if ((phi_a1_3 & 0x400) != 0) {
            temp_v1_5 = arg0->unk4;
            if (temp_v1_5 < 0x24) {
                arg0->unk4 = temp_v1_5 + 1;
                play_sound2(0x49008000, phi_a1_3);
                temp_f0_10 = arg0->unk24;
                if (temp_f0_10 < 4.2) {
                    arg0->unk24 = temp_f0_10 + 4.0;
                }
                arg0->unk8 = 1;
                phi_a0_2 = gControllerOne->unk6;
            }
        }
        if ((phi_a0_2 & 0x4000) != 0) {
            arg0->unk4 = arg0->unk20 + 0x1E;
            play_sound2(0x49008002);
            return;
        }
        if ((phi_a0_2 & 0x9000) != 0) {
            if (arg0->unk4 == 0x24) {
                arg0->unk4 = 0x28;
                arg0->unk1C = 0;
                play_sound2(0x49008001);
                temp_f0_11 = arg0->unk24;
                if (temp_f0_11 < 4.2) {
                    arg0->unk24 = temp_f0_11 + 4.0;
                    return;
                }
                /* Duplicate return node #109. Try simplifying control flow for better match */
                return;
            }
            arg0->unk4 = arg0->unk20 + 0x1E;
            play_sound2(0x49008002);
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 40:                                        /* switch 1 */
        if (arg0->unk1C == 1) {
            if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) != 0) {
                arg0->unk4 = 0x29;
                play_sound2(0x4900FF07);
                return;
            }
            if (func_800B6178(arg0->unk20) != 0) {
                arg0->unk4 = 0x29;
                play_sound2(0x4900FF07);
                return;
            }
            goto block_107;
        }
block_107:
        temp_t6_2 = arg0->unk1C + 1;
        arg0->unk1C = temp_t6_2;
        if (temp_t6_2 >= 2) {
            arg0->unk4 = 0x10;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AE218.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 get_string_width(? *);                             /* extern */
? func_800A9208(void *, ?);                         /* extern */
? func_800A94C8(void *, ?, ?);                      /* extern */
? func_800C90F4(?, s32);                            /* extern */

void func_800AEC54(void *arg0) {
    s32 temp_t5;
    s32 temp_t9;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        arg0->unkC = (get_string_width("NOW-MEET THE COURSE GHOST!!!") / 2) + 0x140;
        arg0->unk10 = 0xDA;
        arg0->unk4 = 1;
        func_800C90F4(0, (D_80162DE4 * 0x10) + 0x29008001);
        return;
    case 1:
        func_800A9208(arg0, 0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            arg0->unk1C = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_t5 = arg0->unk1C + 1;
        arg0->unk1C = temp_t5;
        if (temp_t5 >= 0x3D) {
            arg0->unk4 = 3;
            arg0->unk1C = 0;
            return;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    case 4:
        temp_t9 = arg0->unk1C + 1;
        arg0->unk1C = temp_t9;
        if (temp_t9 >= 6) {
            arg0->unk0 = 0;
            return;
        }
    case 3:
        func_800A94C8(arg0, 0xA0, -1);
        if (((arg0->unkC + 0x14) == -(get_string_width("NOW-MEET THE COURSE GHOST!!!") / 2)) && (arg0->unk4 == 3)) {
            arg0->unk4 = 4;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEC54.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A594(s32, ?, s32, void *); // extern
s32 func_800B5B94(); // extern
? func_800B6708(); // extern
void *segmented_to_virtual_dupe(segment_address_t); // extern
extern ? D_800E7E34;
extern s8 gTimeTrialDataCourseIndex;
extern ? D_8018EE10;
extern ? gCupCourseOrder;

void func_800AEDBC(void *arg0) {
    s8 temp_v0;
    s8 temp_v0_2;
    void *temp_a3;

    temp_v0 = gTimeTrialDataCourseIndex;
    temp_a3 = arg0;
    if (temp_v0 != arg0->unk1C) {
        arg0->unk1C = temp_v0;
        temp_v0_2 = gTimeTrialDataCourseIndex;
        arg0 = temp_a3;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7E34 + (*(&gCupCourseOrder + (((temp_v0_2 / 4) * 8) + ((temp_v0_2 % 4) * 2))) * 4))), arg0);
        if (func_800B5B94() == 0) {
            func_800B6708();
            return;
        }
        D_8018EE10.unk4 = 0;
        D_8018EE10.unk84 = 0;
        // Duplicate return node #4. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEDBC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 D_8018EDEC;

void func_800AEE90(void *arg0) {
    if (D_8018EDEC != 0xB) {
        arg0->unk15 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEE90.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 D_8018EDEC;

void func_800AEEBC(void *arg0) {
    if (D_8018EDEC != 0xC) {
        arg0->unk15 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEEBC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 D_8018EDEC;

void func_800AEEE8(void *arg0) {
    if (D_8018EDEC != 0xD) {
        arg0->unk15 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEEE8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B4E24(?); // extern
extern u32 D_8018CA78;
extern s8 D_8018CAE0;
extern s8 D_8018ED90;

void func_800AEF14(s32 *arg0) {
    if (D_8018CAE0 != 0) {
        if (D_8018CA78 < (func_800B4E24(4) & 0xFFFFF)) {
            D_8018ED90 = 1;
        }
        *arg0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEF14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_80162DF8;
extern s8 D_8018CAE0;

void func_800AEF74(void *arg0) {
    s32 temp_v0;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            // Duplicate return node #10. Try simplifying control flow for better match
            return;
        }
        arg0->unk1C = arg0->unk1C + 1;
        if (D_8018CAE0 == 1) {
            arg0->unk4 = 2;
        }
        // Duplicate return node #10. Try simplifying control flow for better match
        return;
    }
    if (D_80162DF8 == 1) {
        arg0->unk4 = 1;
        arg0->unk1C = 0;
        return;
    }
    if (D_8018CAE0 == 1) {
        arg0->unk4 = 2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEF74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?);                                 /* extern */
? add_8018D9E0_entry(s32, ?, ?, ?);                      /* extern */
? func_800CA330(?);                                 /* extern */
? func_800CA388(?);                                 /* extern */
? play_sound2(?);                                   /* extern */

void func_800AF004(void *arg0) {
    s32 temp_t1;
    s32 temp_t6_2;
    s32 temp_t8;
    u32 temp_t6;
    u32 temp_t9;
    void *temp_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        temp_t8 = arg0->unk1C + 3;
        arg0->unk1C = temp_t8;
        if (temp_t8 >= 0x65) {
            arg0->unk1C = 0;
            arg0->unk4 = 1;
            gCupSelection = gCupSelection % 4;
            gCCSelection = gCCSelection % 4;
            add_8018D9E0_entry(0x12C, 0, 0, 4);
            return;
        }
    default:
        return;
    case 1:
    case 2:
    case 3:
    case 4:
        temp_t6_2 = arg0->unk1C + 1;
        arg0->unk1C = temp_t6_2;
        if (temp_t6_2 >= 9) {
            arg0->unk1C = 0;
            temp_t9 = arg0->unk4 + 1;
            arg0->unk4 = temp_t9;
            add_8018D9E0_entry(temp_t9 + 0x12B, 0, 0, 4);
            return;
        }
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    case 5:
        temp_t1 = arg0->unk1C + 1;
        arg0->unk1C = temp_t1;
        if ((temp_t1 >= 0x65) && ((temp_v0 = gControllerFive, (temp_v0->unk6 != 0)) || (temp_v0->unkC != 0))) {
            arg0->unk4 = 6;
            arg0->unk1C = 0;
            if (D_802874F5 < 3) {
                play_sound2(0x49008016);
                return;
            }
            play_sound2(0x4900801B);
            return;
        }
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    case 6:
        func_8009DFE0(0x1E);
        func_800CA330(0x19);
        func_800CA388(0x19);
        arg0->unk4 = 7;
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF004.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A91D8(s16, s16); // extern
extern ? D_800E7458;
extern ? D_800E7480;

void func_800AF1AC(void *arg0) {
    void *sp18;
    s32 temp_v0;
    s32 temp_v1;
    void *temp_v0_2;
    void *temp_v0_3;

    temp_v0 = arg0->unk4;
    temp_v1 = arg0->unk0 - 0x12C;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        temp_v0_2 = (temp_v1 * 8) + &D_800E7480;
        sp18 = temp_v0_2;
        func_800A91D8(temp_v0_2->unk0, temp_v0_2->unk2);
        if ((temp_v0_2->unk0 == arg0->unkC) && (temp_v0_2->unk2 == arg0->unk10)) {
            arg0->unk4 = 2;
        }
        return;
    }
    temp_v0_3 = (temp_v1 * 8) + &D_800E7458;
    arg0->unkC = temp_v0_3->unk0;
    arg0->unk4 = 1;
    arg0->unk10 = temp_v0_3->unk2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF1AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A640(s32, ?, s32, s32);                  /* extern */
? func_800A91D8(void *, s16, s16);                  /* extern */
? func_800C90F4(?, s32);                            /* extern */
? func_800CA0A0();                                  /* extern */
? func_800CA0B8(? *, ? *);                          /* extern */
void *segmented_to_virtual_dupe(segment_address_t);            /* extern */
extern ? D_8018DEE4;
extern ? D_802874D8;
static ? D_800E7458;                                /* unable to generate initializer; const */
static ? D_800E7480;                                /* unable to generate initializer; const */
static ? D_800E8380;                                /* unable to generate initializer; const */
static ? D_800E83A0;                                /* unable to generate initializer; const */
static ? D_800E8440;                                /* unable to generate initializer; const */
static ? D_800EFD64;                                /* unable to generate initializer; const */

void func_800AF270(void *arg0) {
    s32 sp30;
    void *sp20;
    s32 temp_t2;
    s32 temp_v1;
    s32 temp_v1_2;
    s8 temp_t6;
    s8 temp_v0;
    u32 temp_t8;
    void *temp_v0_2;
    void *temp_v0_3;

    temp_t6 = D_802874D8.unk1E;
    sp30 = temp_t6;
    temp_t8 = arg0->unk4;
    temp_v0 = *(&D_800EFD64 + temp_t6);
    temp_v1 = arg0->unk0 - 0x12C;
    switch (temp_t8) {
    case 0:
        temp_v0_2 = (temp_v1 * 8) + &D_800E7458;
        arg0->unkC = temp_v0_2->unk0;
        arg0->unk4 = 1;
        arg0->unk10 = temp_v0_2->unk2;
        return;
    case 1:
        temp_v0_3 = (temp_v1 * 8) + &D_800E7480;
        sp20 = temp_v0_3;
        func_800A91D8(arg0, temp_v0_3->unk0, temp_v0_3->unk2);
        if ((temp_v0_3->unk0 == arg0->unkC) && (temp_v0_3->unk2 == arg0->unk10)) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_t2 = arg0->unk20 + 1;
        arg0->unk20 = temp_t2;
        if (temp_t2 >= 0x1F) {
            if (D_802874D8.unk1D >= 3) {
                arg0->unk4 = 4;
                func_800CA0B8(&D_800E8380, &D_802874D8);
                func_800C90F4(0, (sp30 * 0x10) + 0x29008003);
                func_800CA0A0();
                return;
            }
            arg0->unk4 = 3;
            func_8009A640(arg0->unk18, 0, sp30, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_v0 * 4))));
            func_800CA0B8();
            func_800C90F4(0, (sp30 * 0x10) + 0x29008007);
            func_800CA0A0();
            return;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    case 3:
        temp_v1_2 = temp_v0 * 4;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *(&D_800E8440 + temp_v1_2)) {
            func_8009A640(arg0->unk18, 0, sp30, segmented_to_virtual_dupe(*(&D_800E83A0 + temp_v1_2)));
            arg0->unk4 = 4;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF270.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800AF4DC(); // extern
? func_800AF740(); // extern
extern ? D_802850CC;

void func_800AF480(s32 *arg0) {
    s8 temp_v1;

    temp_v1 = *(&D_802850CC + ((*arg0 - 0x190) * 0x10));
    if ((temp_v1 == 0) || (temp_v1 != 1)) {
        func_800AF4DC();
        return;
    }
    func_800AF740();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF480.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A9208(void *, s32);                       /* extern */
? func_800A94C8(void *, s32, ?);                    /* extern */
static ? D_802850C0;                                /* unable to generate initializer */
static ? D_802854B0;                                /* unable to generate initializer */

void func_800AF4DC(void *arg0) {
    void *sp20;
    f64 temp_f0;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;
    u32 temp_t9;
    void *temp_v1;

    temp_t9 = arg0->unk4;
    temp_v0 = arg0->unk0 - 0x190;
    temp_v1 = (temp_v0 * 0x10) + &D_802850C0;
    arg0->unk10 = temp_v1->unk6;
    switch (temp_t9) {
    case 0:
        arg0->unk4 = 1;
        arg0->unkC = temp_v1->unk4;
        sp20 = temp_v1;
        arg0->unk20 = ((get_string_width(*(&D_802854B0 + (temp_v0 * 4))) * temp_v1->unk0) / 2.0f) + temp_v1->unk8;
        /* fallthrough */
    case 1:
        func_800A9208(arg0, arg0->unk20);
        temp_t6 = (arg0->unk20 - arg0->unkC) / 4;
        arg0->unk1C = temp_t6;
        if (temp_t6 >= 9) {
            arg0->unk1C = 8;
        }
        arg0->unk24 = (arg0->unk1C * 0.05) + 1.0;
        if (arg0->unkC >= (arg0->unk20 - 0x14)) {
            arg0->unk4 = 2;
            arg0->unk18 = 0;
            return;
        }
    default:
        return;
    case 2:
        func_800A9208(arg0, arg0->unk20);
        temp_t6_2 = arg0->unk18 + 1;
        temp_f0 = temp_t6_2 - 0xA;
        arg0->unk1C = (arg0->unk20 - arg0->unkC) / 4;
        arg0->unk18 = temp_t6_2;
        arg0->unk24 = (temp_f0 * 0.0085 * temp_f0) + 0.4;
        if ((temp_t6_2 >= 9) && (arg0->unk24 > 1.0)) {
            arg0->unk4 = 3;
            arg0->unk24 = 1.0f;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 3:
        if (D_8018ED91 != 0) {
            arg0->unk4 = 4;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 4:
        func_800A94C8(arg0, arg0->unk20, 1);
        if (arg0->unk10 > 480.0) {
            arg0->unk0 = 0;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF4DC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A9208(void *, s32);                       /* extern */
? func_800A94C8(void *, s32, ?);                    /* extern */
static ? D_802850C0;                                /* unable to generate initializer */
static ? D_802854B0;                                /* unable to generate initializer */

void func_800AF740(void *arg0) {
    void *sp20;
    f64 temp_f0;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;
    u32 temp_t9;
    void *temp_v1;

    temp_t9 = arg0->unk4;
    temp_v0 = arg0->unk0 - 0x190;
    temp_v1 = (temp_v0 * 0x10) + &D_802850C0;
    arg0->unk10 = temp_v1->unk6;
    switch (temp_t9) {
    case 0:
        arg0->unk4 = 1;
        arg0->unkC = temp_v1->unk4;
        sp20 = temp_v1;
        arg0->unk20 = temp_v1->unk8 - ((get_string_width(*(&D_802854B0 + (temp_v0 * 4))) * temp_v1->unk0) / 2.0f);
        /* fallthrough */
    case 1:
        func_800A9208(arg0, arg0->unk20);
        temp_t6 = (arg0->unkC - arg0->unk20) / 4;
        arg0->unk1C = temp_t6;
        if (temp_t6 >= 9) {
            arg0->unk1C = 8;
        }
        arg0->unk24 = (arg0->unk1C * 0.05) + 1.0;
        if ((arg0->unk20 + 0x14) >= arg0->unkC) {
            arg0->unk4 = 2;
            arg0->unk18 = 0;
            return;
        }
    default:
        return;
    case 2:
        func_800A9208(arg0, arg0->unk20);
        temp_t6_2 = arg0->unk18 + 1;
        temp_f0 = temp_t6_2 - 0xA;
        arg0->unk1C = (arg0->unkC - arg0->unk20) / 4;
        arg0->unk18 = temp_t6_2;
        arg0->unk24 = (temp_f0 * 0.0085 * temp_f0) + 0.4;
        if ((temp_t6_2 >= 9) && (arg0->unk24 > 1.0)) {
            arg0->unk4 = 3;
            arg0->unk24 = 1.0f;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 3:
        if (D_8018ED91 != 0) {
            arg0->unk4 = 4;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 4:
        func_800A94C8(arg0, arg0->unk20, -1);
        if (arg0->unk10 > 480.0) {
            arg0->unk0 = 0;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF740.s")
#endif
